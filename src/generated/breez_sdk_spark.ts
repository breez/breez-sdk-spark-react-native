// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceEventListener,
  type UniffiVTableCallbackInterfaceLogger,
  type UniffiVTableCallbackInterfaceBitcoinChainService,
  type UniffiVTableCallbackInterfacePaymentObserver,
  type UniffiVTableCallbackInterfaceStorage,
} from './breez_sdk_spark-ffi';
import {
  type BitcoinAddressDetails,
  type Bolt11InvoiceDetails,
  type ExternalInputParser,
  type FiatCurrency,
  type FiatService,
  type LnurlPayRequestDetails,
  type Rate,
  type RestClient,
  InputType,
  SuccessAction,
  SuccessActionProcessed,
} from './breez_sdk_common';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterCallback,
  FfiConverterInt32,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterObjectWithCallbacks,
  FfiConverterOptional,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiRustCallAsync,
  uniffiTraitInterfaceCall,
  uniffiTraitInterfaceCallAsync,
  uniffiTraitInterfaceCallAsyncWithError,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
import uniffiBreezSdkCommonModule from './breez_sdk_common';
const {
  FfiConverterTypeBitcoinAddressDetails,
  FfiConverterTypeBolt11InvoiceDetails,
  FfiConverterTypeExternalInputParser,
  FfiConverterTypeFiatCurrency,
  FfiConverterTypeFiatService,
  FfiConverterTypeInputType,
  FfiConverterTypeLnurlPayRequestDetails,
  FfiConverterTypeRate,
  FfiConverterTypeRestClient,
  FfiConverterTypeSuccessAction,
  FfiConverterTypeSuccessActionProcessed,
} = uniffiBreezSdkCommonModule.converters;
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Connects to the Spark network using the provided configuration and mnemonic.
 *
 * # Arguments
 *
 * * `request` - The connection request object
 *
 * # Returns
 *
 * Result containing either the initialized `BreezSdk` or an `SdkError`
 */
export async function connect(
  request: ConnectRequest,
  asyncOpts_?: { signal: AbortSignal }
): Promise<BreezSdkInterface> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_connect(
          FfiConverterTypeConnectRequest.lower(request)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_free_pointer,
      /*liftFunc:*/ FfiConverterTypeBreezSdk.lift.bind(
        FfiConverterTypeBreezSdk
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export function defaultConfig(network: Network): Config {
  return FfiConverterTypeConfig.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_default_config(
          FfiConverterTypeNetwork.lower(network),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function defaultStorage(dataDir: string): Storage /*throws*/ {
  return FfiConverterTypeStorage.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_default_storage(
          FfiConverterString.lower(dataDir),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function initLogging(
  logDir: string | undefined,
  appLogger: Logger | undefined,
  logFilter: string | undefined
): void /*throws*/ {
  uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError),
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_init_logging(
        FfiConverterOptionalString.lower(logDir),
        FfiConverterOptionalTypeLogger.lower(appLogger),
        FfiConverterOptionalString.lower(logFilter),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}

/**
 * Trait for event listeners
 */
export interface EventListener {
  /**
   * Called when an event occurs
   */
  onEvent(event: SdkEvent, asyncOpts_?: { signal: AbortSignal }): Promise<void>;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEventListener: {
  vtable: UniffiVTableCallbackInterfaceEventListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onEvent: (
      uniffiHandle: bigint,
      event: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeEventListener.lift(uniffiHandle);
        return await jsCallback.onEvent(FfiConverterTypeSdkEvent.lift(event), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // EventListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeEventListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(
      uniffiCallbackInterfaceEventListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeEventListener = new FfiConverterCallback<EventListener>();

export interface Logger {
  log(l: LogEntry): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLogger: {
  vtable: UniffiVTableCallbackInterfaceLogger;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    log: (uniffiHandle: bigint, l: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeLogger.lift(uniffiHandle);
        return jsCallback.log(FfiConverterTypeLogEntry.lift(l));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Logger: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeLogger.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(
      uniffiCallbackInterfaceLogger.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeLogger = new FfiConverterCallback<Logger>();

export type CheckLightningAddressRequest = {
  username: string;
};

/**
 * Generated factory for {@link CheckLightningAddressRequest} record objects.
 */
export const CheckLightningAddressRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      CheckLightningAddressRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CheckLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CheckLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<CheckLightningAddressRequest>,
  });
})();

const FfiConverterTypeCheckLightningAddressRequest = (() => {
  type TypeName = CheckLightningAddressRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        username: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.username, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.username);
    }
  }
  return new FFIConverter();
})();

export type ClaimDepositRequest = {
  txid: string;
  vout: /*u32*/ number;
  maxFee: Fee | undefined;
};

/**
 * Generated factory for {@link ClaimDepositRequest} record objects.
 */
export const ClaimDepositRequest = (() => {
  const defaults = () => ({ maxFee: undefined });
  const create = (() => {
    return uniffiCreateRecord<ClaimDepositRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ClaimDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ClaimDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ClaimDepositRequest>,
  });
})();

const FfiConverterTypeClaimDepositRequest = (() => {
  type TypeName = ClaimDepositRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        maxFee: FfiConverterOptionalTypeFee.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterOptionalTypeFee.write(value.maxFee, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterOptionalTypeFee.allocationSize(value.maxFee)
      );
    }
  }
  return new FFIConverter();
})();

export type ClaimDepositResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link ClaimDepositResponse} record objects.
 */
export const ClaimDepositResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ClaimDepositResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ClaimDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ClaimDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ClaimDepositResponse>,
  });
})();

const FfiConverterTypeClaimDepositResponse = (() => {
  type TypeName = ClaimDepositResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

export type Config = {
  apiKey: string | undefined;
  network: Network;
  syncIntervalSecs: /*u32*/ number;
  maxDepositClaimFee: Fee | undefined;
  /**
   * The domain used for receiving through lnurl-pay and lightning address.
   */
  lnurlDomain: string | undefined;
  /**
   * When this is set to `true` we will prefer to use spark payments over
   * lightning when sending and receiving. This has the benefit of lower fees
   * but is at the cost of privacy.
   */
  preferSparkOverLightning: boolean;
  /**
   * A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
   * is not recognized. See [`ExternalInputParser`] for more details on how to configure
   * external parsing.
   */
  externalInputParsers: Array<ExternalInputParser> | undefined;
  /**
   * The SDK includes some default external input parsers
   * ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
   * Set this to false in order to prevent their use.
   */
  useDefaultExternalInputParsers: boolean;
};

/**
 * Generated factory for {@link Config} record objects.
 */
export const Config = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Config, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Config>,
  });
})();

const FfiConverterTypeConfig = (() => {
  type TypeName = Config;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        apiKey: FfiConverterOptionalString.read(from),
        network: FfiConverterTypeNetwork.read(from),
        syncIntervalSecs: FfiConverterUInt32.read(from),
        maxDepositClaimFee: FfiConverterOptionalTypeFee.read(from),
        lnurlDomain: FfiConverterOptionalString.read(from),
        preferSparkOverLightning: FfiConverterBool.read(from),
        externalInputParsers:
          FfiConverterOptionalArrayTypeExternalInputParser.read(from),
        useDefaultExternalInputParsers: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.apiKey, into);
      FfiConverterTypeNetwork.write(value.network, into);
      FfiConverterUInt32.write(value.syncIntervalSecs, into);
      FfiConverterOptionalTypeFee.write(value.maxDepositClaimFee, into);
      FfiConverterOptionalString.write(value.lnurlDomain, into);
      FfiConverterBool.write(value.preferSparkOverLightning, into);
      FfiConverterOptionalArrayTypeExternalInputParser.write(
        value.externalInputParsers,
        into
      );
      FfiConverterBool.write(value.useDefaultExternalInputParsers, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.apiKey) +
        FfiConverterTypeNetwork.allocationSize(value.network) +
        FfiConverterUInt32.allocationSize(value.syncIntervalSecs) +
        FfiConverterOptionalTypeFee.allocationSize(value.maxDepositClaimFee) +
        FfiConverterOptionalString.allocationSize(value.lnurlDomain) +
        FfiConverterBool.allocationSize(value.preferSparkOverLightning) +
        FfiConverterOptionalArrayTypeExternalInputParser.allocationSize(
          value.externalInputParsers
        ) +
        FfiConverterBool.allocationSize(value.useDefaultExternalInputParsers)
      );
    }
  }
  return new FFIConverter();
})();

export type ConnectRequest = {
  config: Config;
  seed: Seed;
  storageDir: string;
};

/**
 * Generated factory for {@link ConnectRequest} record objects.
 */
export const ConnectRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ConnectRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ConnectRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ConnectRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ConnectRequest>,
  });
})();

const FfiConverterTypeConnectRequest = (() => {
  type TypeName = ConnectRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        config: FfiConverterTypeConfig.read(from),
        seed: FfiConverterTypeSeed.read(from),
        storageDir: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeConfig.write(value.config, into);
      FfiConverterTypeSeed.write(value.seed, into);
      FfiConverterString.write(value.storageDir, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeConfig.allocationSize(value.config) +
        FfiConverterTypeSeed.allocationSize(value.seed) +
        FfiConverterString.allocationSize(value.storageDir)
      );
    }
  }
  return new FFIConverter();
})();

export type Credentials = {
  username: string;
  password: string;
};

/**
 * Generated factory for {@link Credentials} record objects.
 */
export const Credentials = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Credentials, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Credentials}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Credentials}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Credentials>,
  });
})();

const FfiConverterTypeCredentials = (() => {
  type TypeName = Credentials;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        username: FfiConverterString.read(from),
        password: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.username, into);
      FfiConverterString.write(value.password, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.username) +
        FfiConverterString.allocationSize(value.password)
      );
    }
  }
  return new FFIConverter();
})();

export type DepositInfo = {
  txid: string;
  vout: /*u32*/ number;
  amountSats: /*u64*/ bigint;
  refundTx: string | undefined;
  refundTxId: string | undefined;
  claimError: DepositClaimError | undefined;
};

/**
 * Generated factory for {@link DepositInfo} record objects.
 */
export const DepositInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<DepositInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link DepositInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link DepositInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<DepositInfo>,
  });
})();

const FfiConverterTypeDepositInfo = (() => {
  type TypeName = DepositInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        amountSats: FfiConverterUInt64.read(from),
        refundTx: FfiConverterOptionalString.read(from),
        refundTxId: FfiConverterOptionalString.read(from),
        claimError: FfiConverterOptionalTypeDepositClaimError.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterUInt64.write(value.amountSats, into);
      FfiConverterOptionalString.write(value.refundTx, into);
      FfiConverterOptionalString.write(value.refundTxId, into);
      FfiConverterOptionalTypeDepositClaimError.write(value.claimError, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterUInt64.allocationSize(value.amountSats) +
        FfiConverterOptionalString.allocationSize(value.refundTx) +
        FfiConverterOptionalString.allocationSize(value.refundTxId) +
        FfiConverterOptionalTypeDepositClaimError.allocationSize(
          value.claimError
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Request to get the balance of the wallet
 */
export type GetInfoRequest = {
  ensureSynced: boolean | undefined;
};

/**
 * Generated factory for {@link GetInfoRequest} record objects.
 */
export const GetInfoRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetInfoRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetInfoRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetInfoRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetInfoRequest>,
  });
})();

const FfiConverterTypeGetInfoRequest = (() => {
  type TypeName = GetInfoRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ensureSynced: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalBool.write(value.ensureSynced, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalBool.allocationSize(value.ensureSynced);
    }
  }
  return new FFIConverter();
})();

/**
 * Response containing the balance of the wallet
 */
export type GetInfoResponse = {
  /**
   * The balance in satoshis
   */
  balanceSats: /*u64*/ bigint;
  /**
   * The balances of the tokens in the wallet keyed by the token identifier
   */
  tokenBalances: Map<string, TokenBalance>;
};

/**
 * Generated factory for {@link GetInfoResponse} record objects.
 */
export const GetInfoResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetInfoResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetInfoResponse>,
  });
})();

const FfiConverterTypeGetInfoResponse = (() => {
  type TypeName = GetInfoResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        balanceSats: FfiConverterUInt64.read(from),
        tokenBalances: FfiConverterMapStringTypeTokenBalance.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.balanceSats, into);
      FfiConverterMapStringTypeTokenBalance.write(value.tokenBalances, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.balanceSats) +
        FfiConverterMapStringTypeTokenBalance.allocationSize(
          value.tokenBalances
        )
      );
    }
  }
  return new FFIConverter();
})();

export type GetPaymentRequest = {
  paymentId: string;
};

/**
 * Generated factory for {@link GetPaymentRequest} record objects.
 */
export const GetPaymentRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetPaymentRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetPaymentRequest>,
  });
})();

const FfiConverterTypeGetPaymentRequest = (() => {
  type TypeName = GetPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentId, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.paymentId);
    }
  }
  return new FFIConverter();
})();

export type GetPaymentResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link GetPaymentResponse} record objects.
 */
export const GetPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetPaymentResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetPaymentResponse>,
  });
})();

const FfiConverterTypeGetPaymentResponse = (() => {
  type TypeName = GetPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

export type GetTokensMetadataRequest = {
  tokenIdentifiers: Array<string>;
};

/**
 * Generated factory for {@link GetTokensMetadataRequest} record objects.
 */
export const GetTokensMetadataRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      GetTokensMetadataRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetTokensMetadataRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetTokensMetadataRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<GetTokensMetadataRequest>,
  });
})();

const FfiConverterTypeGetTokensMetadataRequest = (() => {
  type TypeName = GetTokensMetadataRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        tokenIdentifiers: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.tokenIdentifiers, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayString.allocationSize(value.tokenIdentifiers);
    }
  }
  return new FFIConverter();
})();

export type GetTokensMetadataResponse = {
  tokensMetadata: Array<TokenMetadata>;
};

/**
 * Generated factory for {@link GetTokensMetadataResponse} record objects.
 */
export const GetTokensMetadataResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      GetTokensMetadataResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetTokensMetadataResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetTokensMetadataResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<GetTokensMetadataResponse>,
  });
})();

const FfiConverterTypeGetTokensMetadataResponse = (() => {
  type TypeName = GetTokensMetadataResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        tokensMetadata: FfiConverterArrayTypeTokenMetadata.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeTokenMetadata.write(value.tokensMetadata, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeTokenMetadata.allocationSize(
        value.tokensMetadata
      );
    }
  }
  return new FFIConverter();
})();

export type LightningAddressInfo = {
  description: string;
  lightningAddress: string;
  lnurl: string;
  username: string;
};

/**
 * Generated factory for {@link LightningAddressInfo} record objects.
 */
export const LightningAddressInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LightningAddressInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LightningAddressInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LightningAddressInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LightningAddressInfo>,
  });
})();

const FfiConverterTypeLightningAddressInfo = (() => {
  type TypeName = LightningAddressInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterString.read(from),
        lightningAddress: FfiConverterString.read(from),
        lnurl: FfiConverterString.read(from),
        username: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.description, into);
      FfiConverterString.write(value.lightningAddress, into);
      FfiConverterString.write(value.lnurl, into);
      FfiConverterString.write(value.username, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.lightningAddress) +
        FfiConverterString.allocationSize(value.lnurl) +
        FfiConverterString.allocationSize(value.username)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Response from listing fiat currencies
 */
export type ListFiatCurrenciesResponse = {
  /**
   * The list of fiat currencies
   */
  currencies: Array<FiatCurrency>;
};

/**
 * Generated factory for {@link ListFiatCurrenciesResponse} record objects.
 */
export const ListFiatCurrenciesResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListFiatCurrenciesResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListFiatCurrenciesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListFiatCurrenciesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ListFiatCurrenciesResponse>,
  });
})();

const FfiConverterTypeListFiatCurrenciesResponse = (() => {
  type TypeName = ListFiatCurrenciesResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        currencies: FfiConverterArrayTypeFiatCurrency.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeFiatCurrency.write(value.currencies, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeFiatCurrency.allocationSize(value.currencies);
    }
  }
  return new FFIConverter();
})();

/**
 * Response from listing fiat rates
 */
export type ListFiatRatesResponse = {
  /**
   * The list of fiat rates
   */
  rates: Array<Rate>;
};

/**
 * Generated factory for {@link ListFiatRatesResponse} record objects.
 */
export const ListFiatRatesResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListFiatRatesResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListFiatRatesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListFiatRatesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ListFiatRatesResponse>,
  });
})();

const FfiConverterTypeListFiatRatesResponse = (() => {
  type TypeName = ListFiatRatesResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        rates: FfiConverterArrayTypeRate.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeRate.write(value.rates, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeRate.allocationSize(value.rates);
    }
  }
  return new FFIConverter();
})();

/**
 * Request to list payments with optional filters and pagination
 */
export type ListPaymentsRequest = {
  typeFilter: Array<PaymentType> | undefined;
  statusFilter: Array<PaymentStatus> | undefined;
  assetFilter: AssetFilter | undefined;
  /**
   * Only include payments created after this timestamp (inclusive)
   */
  fromTimestamp: /*u64*/ bigint | undefined;
  /**
   * Only include payments created before this timestamp (exclusive)
   */
  toTimestamp: /*u64*/ bigint | undefined;
  /**
   * Number of records to skip
   */
  offset: /*u32*/ number | undefined;
  /**
   * Maximum number of records to return
   */
  limit: /*u32*/ number | undefined;
  sortAscending: boolean | undefined;
};

/**
 * Generated factory for {@link ListPaymentsRequest} record objects.
 */
export const ListPaymentsRequest = (() => {
  const defaults = () => ({
    typeFilter: undefined,
    statusFilter: undefined,
    assetFilter: undefined,
    fromTimestamp: undefined,
    toTimestamp: undefined,
    offset: undefined,
    limit: undefined,
    sortAscending: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<ListPaymentsRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListPaymentsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListPaymentsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ListPaymentsRequest>,
  });
})();

const FfiConverterTypeListPaymentsRequest = (() => {
  type TypeName = ListPaymentsRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        typeFilter: FfiConverterOptionalArrayTypePaymentType.read(from),
        statusFilter: FfiConverterOptionalArrayTypePaymentStatus.read(from),
        assetFilter: FfiConverterOptionalTypeAssetFilter.read(from),
        fromTimestamp: FfiConverterOptionalUInt64.read(from),
        toTimestamp: FfiConverterOptionalUInt64.read(from),
        offset: FfiConverterOptionalUInt32.read(from),
        limit: FfiConverterOptionalUInt32.read(from),
        sortAscending: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalArrayTypePaymentType.write(value.typeFilter, into);
      FfiConverterOptionalArrayTypePaymentStatus.write(
        value.statusFilter,
        into
      );
      FfiConverterOptionalTypeAssetFilter.write(value.assetFilter, into);
      FfiConverterOptionalUInt64.write(value.fromTimestamp, into);
      FfiConverterOptionalUInt64.write(value.toTimestamp, into);
      FfiConverterOptionalUInt32.write(value.offset, into);
      FfiConverterOptionalUInt32.write(value.limit, into);
      FfiConverterOptionalBool.write(value.sortAscending, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalArrayTypePaymentType.allocationSize(
          value.typeFilter
        ) +
        FfiConverterOptionalArrayTypePaymentStatus.allocationSize(
          value.statusFilter
        ) +
        FfiConverterOptionalTypeAssetFilter.allocationSize(value.assetFilter) +
        FfiConverterOptionalUInt64.allocationSize(value.fromTimestamp) +
        FfiConverterOptionalUInt64.allocationSize(value.toTimestamp) +
        FfiConverterOptionalUInt32.allocationSize(value.offset) +
        FfiConverterOptionalUInt32.allocationSize(value.limit) +
        FfiConverterOptionalBool.allocationSize(value.sortAscending)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Response from listing payments
 */
export type ListPaymentsResponse = {
  /**
   * The list of payments
   */
  payments: Array<Payment>;
};

/**
 * Generated factory for {@link ListPaymentsResponse} record objects.
 */
export const ListPaymentsResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListPaymentsResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListPaymentsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListPaymentsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ListPaymentsResponse>,
  });
})();

const FfiConverterTypeListPaymentsResponse = (() => {
  type TypeName = ListPaymentsResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payments: FfiConverterArrayTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypePayment.write(value.payments, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypePayment.allocationSize(value.payments);
    }
  }
  return new FFIConverter();
})();

export type ListUnclaimedDepositsRequest = {};

/**
 * Generated factory for {@link ListUnclaimedDepositsRequest} record objects.
 */
export const ListUnclaimedDepositsRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListUnclaimedDepositsRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ListUnclaimedDepositsRequest>,
  });
})();

const FfiConverterTypeListUnclaimedDepositsRequest = (() => {
  type TypeName = ListUnclaimedDepositsRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export type ListUnclaimedDepositsResponse = {
  deposits: Array<DepositInfo>;
};

/**
 * Generated factory for {@link ListUnclaimedDepositsResponse} record objects.
 */
export const ListUnclaimedDepositsResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListUnclaimedDepositsResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ListUnclaimedDepositsResponse>,
  });
})();

const FfiConverterTypeListUnclaimedDepositsResponse = (() => {
  type TypeName = ListUnclaimedDepositsResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        deposits: FfiConverterArrayTypeDepositInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeDepositInfo.write(value.deposits, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeDepositInfo.allocationSize(value.deposits);
    }
  }
  return new FFIConverter();
})();

/**
 * Represents the payment LNURL info
 */
export type LnurlPayInfo = {
  lnAddress: string | undefined;
  comment: string | undefined;
  domain: string | undefined;
  metadata: string | undefined;
  processedSuccessAction: SuccessActionProcessed | undefined;
  rawSuccessAction: SuccessAction | undefined;
};

/**
 * Generated factory for {@link LnurlPayInfo} record objects.
 */
export const LnurlPayInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnurlPayInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlPayInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlPayInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlPayInfo>,
  });
})();

const FfiConverterTypeLnurlPayInfo = (() => {
  type TypeName = LnurlPayInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lnAddress: FfiConverterOptionalString.read(from),
        comment: FfiConverterOptionalString.read(from),
        domain: FfiConverterOptionalString.read(from),
        metadata: FfiConverterOptionalString.read(from),
        processedSuccessAction:
          FfiConverterOptionalTypeSuccessActionProcessed.read(from),
        rawSuccessAction: FfiConverterOptionalTypeSuccessAction.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.lnAddress, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterOptionalString.write(value.domain, into);
      FfiConverterOptionalString.write(value.metadata, into);
      FfiConverterOptionalTypeSuccessActionProcessed.write(
        value.processedSuccessAction,
        into
      );
      FfiConverterOptionalTypeSuccessAction.write(value.rawSuccessAction, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.lnAddress) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterOptionalString.allocationSize(value.domain) +
        FfiConverterOptionalString.allocationSize(value.metadata) +
        FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(
          value.processedSuccessAction
        ) +
        FfiConverterOptionalTypeSuccessAction.allocationSize(
          value.rawSuccessAction
        )
      );
    }
  }
  return new FFIConverter();
})();

export type LnurlPayRequest = {
  prepareResponse: PrepareLnurlPayResponse;
};

/**
 * Generated factory for {@link LnurlPayRequest} record objects.
 */
export const LnurlPayRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnurlPayRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlPayRequest>,
  });
})();

const FfiConverterTypeLnurlPayRequest = (() => {
  type TypeName = LnurlPayRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prepareResponse: FfiConverterTypePrepareLnurlPayResponse.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePrepareLnurlPayResponse.write(
        value.prepareResponse,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePrepareLnurlPayResponse.allocationSize(
        value.prepareResponse
      );
    }
  }
  return new FFIConverter();
})();

export type LnurlPayResponse = {
  payment: Payment;
  successAction: SuccessActionProcessed | undefined;
};

/**
 * Generated factory for {@link LnurlPayResponse} record objects.
 */
export const LnurlPayResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnurlPayResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlPayResponse>,
  });
})();

const FfiConverterTypeLnurlPayResponse = (() => {
  type TypeName = LnurlPayResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
        successAction:
          FfiConverterOptionalTypeSuccessActionProcessed.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
      FfiConverterOptionalTypeSuccessActionProcessed.write(
        value.successAction,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePayment.allocationSize(value.payment) +
        FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(
          value.successAction
        )
      );
    }
  }
  return new FFIConverter();
})();

export type LogEntry = {
  line: string;
  level: string;
};

/**
 * Generated factory for {@link LogEntry} record objects.
 */
export const LogEntry = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LogEntry, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LogEntry}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LogEntry}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LogEntry>,
  });
})();

const FfiConverterTypeLogEntry = (() => {
  type TypeName = LogEntry;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        line: FfiConverterString.read(from),
        level: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.line, into);
      FfiConverterString.write(value.level, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.line) +
        FfiConverterString.allocationSize(value.level)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Represents a payment (sent or received)
 */
export type Payment = {
  /**
   * Unique identifier for the payment
   */
  id: string;
  /**
   * Type of payment (send or receive)
   */
  paymentType: PaymentType;
  /**
   * Status of the payment
   */
  status: PaymentStatus;
  /**
   * Amount in satoshis or token base units
   */
  amount: U128;
  /**
   * Fee paid in satoshis or token base units
   */
  fees: U128;
  /**
   * Timestamp of when the payment was created
   */
  timestamp: /*u64*/ bigint;
  /**
   * Method of payment. Sometimes the payment details is empty so this field
   * is used to determine the payment method.
   */
  method: PaymentMethod;
  /**
   * Details of the payment
   */
  details: PaymentDetails | undefined;
};

/**
 * Generated factory for {@link Payment} record objects.
 */
export const Payment = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Payment, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Payment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Payment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Payment>,
  });
})();

const FfiConverterTypePayment = (() => {
  type TypeName = Payment;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        paymentType: FfiConverterTypePaymentType.read(from),
        status: FfiConverterTypePaymentStatus.read(from),
        amount: FfiConverterTypeu128.read(from),
        fees: FfiConverterTypeu128.read(from),
        timestamp: FfiConverterUInt64.read(from),
        method: FfiConverterTypePaymentMethod.read(from),
        details: FfiConverterOptionalTypePaymentDetails.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterTypePaymentType.write(value.paymentType, into);
      FfiConverterTypePaymentStatus.write(value.status, into);
      FfiConverterTypeu128.write(value.amount, into);
      FfiConverterTypeu128.write(value.fees, into);
      FfiConverterUInt64.write(value.timestamp, into);
      FfiConverterTypePaymentMethod.write(value.method, into);
      FfiConverterOptionalTypePaymentDetails.write(value.details, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterTypePaymentType.allocationSize(value.paymentType) +
        FfiConverterTypePaymentStatus.allocationSize(value.status) +
        FfiConverterTypeu128.allocationSize(value.amount) +
        FfiConverterTypeu128.allocationSize(value.fees) +
        FfiConverterUInt64.allocationSize(value.timestamp) +
        FfiConverterTypePaymentMethod.allocationSize(value.method) +
        FfiConverterOptionalTypePaymentDetails.allocationSize(value.details)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Metadata associated with a payment that cannot be extracted from the Spark operator.
 */
export type PaymentMetadata = {
  lnurlPayInfo: LnurlPayInfo | undefined;
  lnurlDescription: string | undefined;
};

/**
 * Generated factory for {@link PaymentMetadata} record objects.
 */
export const PaymentMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PaymentMetadata, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PaymentMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PaymentMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PaymentMetadata>,
  });
})();

const FfiConverterTypePaymentMetadata = (() => {
  type TypeName = PaymentMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lnurlPayInfo: FfiConverterOptionalTypeLnurlPayInfo.read(from),
        lnurlDescription: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeLnurlPayInfo.write(value.lnurlPayInfo, into);
      FfiConverterOptionalString.write(value.lnurlDescription, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeLnurlPayInfo.allocationSize(
          value.lnurlPayInfo
        ) + FfiConverterOptionalString.allocationSize(value.lnurlDescription)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareLnurlPayRequest = {
  amountSats: /*u64*/ bigint;
  payRequest: LnurlPayRequestDetails;
  comment: string | undefined;
  validateSuccessActionUrl: boolean | undefined;
};

/**
 * Generated factory for {@link PrepareLnurlPayRequest} record objects.
 */
export const PrepareLnurlPayRequest = (() => {
  const defaults = () => ({
    comment: undefined,
    validateSuccessActionUrl: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<
      PrepareLnurlPayRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareLnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareLnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareLnurlPayRequest>,
  });
})();

const FfiConverterTypePrepareLnurlPayRequest = (() => {
  type TypeName = PrepareLnurlPayRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amountSats: FfiConverterUInt64.read(from),
        payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from),
        comment: FfiConverterOptionalString.read(from),
        validateSuccessActionUrl: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.amountSats, into);
      FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterOptionalBool.write(value.validateSuccessActionUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.amountSats) +
        FfiConverterTypeLnurlPayRequestDetails.allocationSize(
          value.payRequest
        ) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterOptionalBool.allocationSize(value.validateSuccessActionUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareLnurlPayResponse = {
  amountSats: /*u64*/ bigint;
  comment: string | undefined;
  payRequest: LnurlPayRequestDetails;
  feeSats: /*u64*/ bigint;
  invoiceDetails: Bolt11InvoiceDetails;
  successAction: SuccessAction | undefined;
};

/**
 * Generated factory for {@link PrepareLnurlPayResponse} record objects.
 */
export const PrepareLnurlPayResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PrepareLnurlPayResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareLnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareLnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareLnurlPayResponse>,
  });
})();

const FfiConverterTypePrepareLnurlPayResponse = (() => {
  type TypeName = PrepareLnurlPayResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amountSats: FfiConverterUInt64.read(from),
        comment: FfiConverterOptionalString.read(from),
        payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from),
        feeSats: FfiConverterUInt64.read(from),
        invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.read(from),
        successAction: FfiConverterOptionalTypeSuccessAction.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.amountSats, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into);
      FfiConverterUInt64.write(value.feeSats, into);
      FfiConverterTypeBolt11InvoiceDetails.write(value.invoiceDetails, into);
      FfiConverterOptionalTypeSuccessAction.write(value.successAction, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.amountSats) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterTypeLnurlPayRequestDetails.allocationSize(
          value.payRequest
        ) +
        FfiConverterUInt64.allocationSize(value.feeSats) +
        FfiConverterTypeBolt11InvoiceDetails.allocationSize(
          value.invoiceDetails
        ) +
        FfiConverterOptionalTypeSuccessAction.allocationSize(
          value.successAction
        )
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareSendPaymentRequest = {
  paymentRequest: string;
  /**
   * Amount to send. By default is denominated in sats.
   * If a token identifier is provided, the amount will be denominated in the token base units.
   */
  amount: U128 | undefined;
  /**
   * If provided, the payment will be for a token
   * May only be provided if the payment request is a spark address
   */
  tokenIdentifier: string | undefined;
};

/**
 * Generated factory for {@link PrepareSendPaymentRequest} record objects.
 */
export const PrepareSendPaymentRequest = (() => {
  const defaults = () => ({ amount: undefined, tokenIdentifier: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      PrepareSendPaymentRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareSendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareSendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareSendPaymentRequest>,
  });
})();

const FfiConverterTypePrepareSendPaymentRequest = (() => {
  type TypeName = PrepareSendPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentRequest: FfiConverterString.read(from),
        amount: FfiConverterOptionalTypeu128.read(from),
        tokenIdentifier: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentRequest, into);
      FfiConverterOptionalTypeu128.write(value.amount, into);
      FfiConverterOptionalString.write(value.tokenIdentifier, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.paymentRequest) +
        FfiConverterOptionalTypeu128.allocationSize(value.amount) +
        FfiConverterOptionalString.allocationSize(value.tokenIdentifier)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareSendPaymentResponse = {
  paymentMethod: SendPaymentMethod;
  /**
   * Amount to send. By default is denominated in sats.
   * If a token identifier is provided, the amount will be denominated in the token base units.
   */
  amount: U128;
  /**
   * The presence of this field indicates that the payment is for a token
   * If empty, it is a Bitcoin payment
   */
  tokenIdentifier: string | undefined;
};

/**
 * Generated factory for {@link PrepareSendPaymentResponse} record objects.
 */
export const PrepareSendPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PrepareSendPaymentResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareSendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareSendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareSendPaymentResponse>,
  });
})();

const FfiConverterTypePrepareSendPaymentResponse = (() => {
  type TypeName = PrepareSendPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentMethod: FfiConverterTypeSendPaymentMethod.read(from),
        amount: FfiConverterTypeu128.read(from),
        tokenIdentifier: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeSendPaymentMethod.write(value.paymentMethod, into);
      FfiConverterTypeu128.write(value.amount, into);
      FfiConverterOptionalString.write(value.tokenIdentifier, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeSendPaymentMethod.allocationSize(value.paymentMethod) +
        FfiConverterTypeu128.allocationSize(value.amount) +
        FfiConverterOptionalString.allocationSize(value.tokenIdentifier)
      );
    }
  }
  return new FFIConverter();
})();

export type ProvisionalPayment = {
  /**
   * Unique identifier for the payment
   */
  paymentId: string;
  /**
   * Amount in satoshis or token base units
   */
  amount: U128;
  /**
   * Details of the payment
   */
  details: ProvisionalPaymentDetails;
};

/**
 * Generated factory for {@link ProvisionalPayment} record objects.
 */
export const ProvisionalPayment = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ProvisionalPayment, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ProvisionalPayment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ProvisionalPayment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ProvisionalPayment>,
  });
})();

const FfiConverterTypeProvisionalPayment = (() => {
  type TypeName = ProvisionalPayment;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentId: FfiConverterString.read(from),
        amount: FfiConverterTypeu128.read(from),
        details: FfiConverterTypeProvisionalPaymentDetails.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentId, into);
      FfiConverterTypeu128.write(value.amount, into);
      FfiConverterTypeProvisionalPaymentDetails.write(value.details, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.paymentId) +
        FfiConverterTypeu128.allocationSize(value.amount) +
        FfiConverterTypeProvisionalPaymentDetails.allocationSize(value.details)
      );
    }
  }
  return new FFIConverter();
})();

export type ReceivePaymentRequest = {
  paymentMethod: ReceivePaymentMethod;
};

/**
 * Generated factory for {@link ReceivePaymentRequest} record objects.
 */
export const ReceivePaymentRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ReceivePaymentRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReceivePaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReceivePaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ReceivePaymentRequest>,
  });
})();

const FfiConverterTypeReceivePaymentRequest = (() => {
  type TypeName = ReceivePaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentMethod: FfiConverterTypeReceivePaymentMethod.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeReceivePaymentMethod.write(value.paymentMethod, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeReceivePaymentMethod.allocationSize(
        value.paymentMethod
      );
    }
  }
  return new FFIConverter();
})();

export type ReceivePaymentResponse = {
  paymentRequest: string;
  feeSats: /*u64*/ bigint;
};

/**
 * Generated factory for {@link ReceivePaymentResponse} record objects.
 */
export const ReceivePaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ReceivePaymentResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReceivePaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReceivePaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ReceivePaymentResponse>,
  });
})();

const FfiConverterTypeReceivePaymentResponse = (() => {
  type TypeName = ReceivePaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentRequest: FfiConverterString.read(from),
        feeSats: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentRequest, into);
      FfiConverterUInt64.write(value.feeSats, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.paymentRequest) +
        FfiConverterUInt64.allocationSize(value.feeSats)
      );
    }
  }
  return new FFIConverter();
})();

export type RefundDepositRequest = {
  txid: string;
  vout: /*u32*/ number;
  destinationAddress: string;
  fee: Fee;
};

/**
 * Generated factory for {@link RefundDepositRequest} record objects.
 */
export const RefundDepositRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RefundDepositRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RefundDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RefundDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RefundDepositRequest>,
  });
})();

const FfiConverterTypeRefundDepositRequest = (() => {
  type TypeName = RefundDepositRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        destinationAddress: FfiConverterString.read(from),
        fee: FfiConverterTypeFee.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterString.write(value.destinationAddress, into);
      FfiConverterTypeFee.write(value.fee, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterString.allocationSize(value.destinationAddress) +
        FfiConverterTypeFee.allocationSize(value.fee)
      );
    }
  }
  return new FFIConverter();
})();

export type RefundDepositResponse = {
  txId: string;
  txHex: string;
};

/**
 * Generated factory for {@link RefundDepositResponse} record objects.
 */
export const RefundDepositResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RefundDepositResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RefundDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RefundDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RefundDepositResponse>,
  });
})();

const FfiConverterTypeRefundDepositResponse = (() => {
  type TypeName = RefundDepositResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txId: FfiConverterString.read(from),
        txHex: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txId, into);
      FfiConverterString.write(value.txHex, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txId) +
        FfiConverterString.allocationSize(value.txHex)
      );
    }
  }
  return new FFIConverter();
})();

export type RegisterLightningAddressRequest = {
  username: string;
  description: string | undefined;
};

/**
 * Generated factory for {@link RegisterLightningAddressRequest} record objects.
 */
export const RegisterLightningAddressRequest = (() => {
  const defaults = () => ({ description: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      RegisterLightningAddressRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RegisterLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RegisterLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RegisterLightningAddressRequest>,
  });
})();

const FfiConverterTypeRegisterLightningAddressRequest = (() => {
  type TypeName = RegisterLightningAddressRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        username: FfiConverterString.read(from),
        description: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.username, into);
      FfiConverterOptionalString.write(value.description, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.username) +
        FfiConverterOptionalString.allocationSize(value.description)
      );
    }
  }
  return new FFIConverter();
})();

export type SendOnchainFeeQuote = {
  id: string;
  expiresAt: /*u64*/ bigint;
  speedFast: SendOnchainSpeedFeeQuote;
  speedMedium: SendOnchainSpeedFeeQuote;
  speedSlow: SendOnchainSpeedFeeQuote;
};

/**
 * Generated factory for {@link SendOnchainFeeQuote} record objects.
 */
export const SendOnchainFeeQuote = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SendOnchainFeeQuote, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendOnchainFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendOnchainFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendOnchainFeeQuote>,
  });
})();

const FfiConverterTypeSendOnchainFeeQuote = (() => {
  type TypeName = SendOnchainFeeQuote;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        expiresAt: FfiConverterUInt64.read(from),
        speedFast: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),
        speedMedium: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),
        speedSlow: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterUInt64.write(value.expiresAt, into);
      FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedFast, into);
      FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedMedium, into);
      FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedSlow, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterUInt64.allocationSize(value.expiresAt) +
        FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(
          value.speedFast
        ) +
        FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(
          value.speedMedium
        ) +
        FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(value.speedSlow)
      );
    }
  }
  return new FFIConverter();
})();

export type SendOnchainSpeedFeeQuote = {
  userFeeSat: /*u64*/ bigint;
  l1BroadcastFeeSat: /*u64*/ bigint;
};

/**
 * Generated factory for {@link SendOnchainSpeedFeeQuote} record objects.
 */
export const SendOnchainSpeedFeeQuote = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SendOnchainSpeedFeeQuote,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendOnchainSpeedFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendOnchainSpeedFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<SendOnchainSpeedFeeQuote>,
  });
})();

const FfiConverterTypeSendOnchainSpeedFeeQuote = (() => {
  type TypeName = SendOnchainSpeedFeeQuote;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userFeeSat: FfiConverterUInt64.read(from),
        l1BroadcastFeeSat: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.userFeeSat, into);
      FfiConverterUInt64.write(value.l1BroadcastFeeSat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.userFeeSat) +
        FfiConverterUInt64.allocationSize(value.l1BroadcastFeeSat)
      );
    }
  }
  return new FFIConverter();
})();

export type SendPaymentRequest = {
  prepareResponse: PrepareSendPaymentResponse;
  options: SendPaymentOptions | undefined;
};

/**
 * Generated factory for {@link SendPaymentRequest} record objects.
 */
export const SendPaymentRequest = (() => {
  const defaults = () => ({ options: undefined });
  const create = (() => {
    return uniffiCreateRecord<SendPaymentRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendPaymentRequest>,
  });
})();

const FfiConverterTypeSendPaymentRequest = (() => {
  type TypeName = SendPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prepareResponse: FfiConverterTypePrepareSendPaymentResponse.read(from),
        options: FfiConverterOptionalTypeSendPaymentOptions.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePrepareSendPaymentResponse.write(
        value.prepareResponse,
        into
      );
      FfiConverterOptionalTypeSendPaymentOptions.write(value.options, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePrepareSendPaymentResponse.allocationSize(
          value.prepareResponse
        ) +
        FfiConverterOptionalTypeSendPaymentOptions.allocationSize(value.options)
      );
    }
  }
  return new FFIConverter();
})();

export type SendPaymentResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link SendPaymentResponse} record objects.
 */
export const SendPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SendPaymentResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendPaymentResponse>,
  });
})();

const FfiConverterTypeSendPaymentResponse = (() => {
  type TypeName = SendPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

/**
 * Request to sync the wallet with the Spark network
 */
export type SyncWalletRequest = {};

/**
 * Generated factory for {@link SyncWalletRequest} record objects.
 */
export const SyncWalletRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SyncWalletRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SyncWalletRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SyncWalletRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SyncWalletRequest>,
  });
})();

const FfiConverterTypeSyncWalletRequest = (() => {
  type TypeName = SyncWalletRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

/**
 * Response from synchronizing the wallet
 */
export type SyncWalletResponse = {};

/**
 * Generated factory for {@link SyncWalletResponse} record objects.
 */
export const SyncWalletResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SyncWalletResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SyncWalletResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SyncWalletResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SyncWalletResponse>,
  });
})();

const FfiConverterTypeSyncWalletResponse = (() => {
  type TypeName = SyncWalletResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export type TokenBalance = {
  balance: U128;
  tokenMetadata: TokenMetadata;
};

/**
 * Generated factory for {@link TokenBalance} record objects.
 */
export const TokenBalance = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TokenBalance, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TokenBalance}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TokenBalance}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TokenBalance>,
  });
})();

const FfiConverterTypeTokenBalance = (() => {
  type TypeName = TokenBalance;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        balance: FfiConverterTypeu128.read(from),
        tokenMetadata: FfiConverterTypeTokenMetadata.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeu128.write(value.balance, into);
      FfiConverterTypeTokenMetadata.write(value.tokenMetadata, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeu128.allocationSize(value.balance) +
        FfiConverterTypeTokenMetadata.allocationSize(value.tokenMetadata)
      );
    }
  }
  return new FFIConverter();
})();

export type TokenMetadata = {
  identifier: string;
  /**
   * Hex representation of the issuer public key
   */
  issuerPublicKey: string;
  name: string;
  ticker: string;
  /**
   * Number of decimals the token uses
   */
  decimals: /*u32*/ number;
  maxSupply: U128;
  isFreezable: boolean;
};

/**
 * Generated factory for {@link TokenMetadata} record objects.
 */
export const TokenMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TokenMetadata, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TokenMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TokenMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TokenMetadata>,
  });
})();

const FfiConverterTypeTokenMetadata = (() => {
  type TypeName = TokenMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        identifier: FfiConverterString.read(from),
        issuerPublicKey: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        ticker: FfiConverterString.read(from),
        decimals: FfiConverterUInt32.read(from),
        maxSupply: FfiConverterTypeu128.read(from),
        isFreezable: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.identifier, into);
      FfiConverterString.write(value.issuerPublicKey, into);
      FfiConverterString.write(value.name, into);
      FfiConverterString.write(value.ticker, into);
      FfiConverterUInt32.write(value.decimals, into);
      FfiConverterTypeu128.write(value.maxSupply, into);
      FfiConverterBool.write(value.isFreezable, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.identifier) +
        FfiConverterString.allocationSize(value.issuerPublicKey) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.ticker) +
        FfiConverterUInt32.allocationSize(value.decimals) +
        FfiConverterTypeu128.allocationSize(value.maxSupply) +
        FfiConverterBool.allocationSize(value.isFreezable)
      );
    }
  }
  return new FFIConverter();
})();

export type TxStatus = {
  confirmed: boolean;
  blockHeight: /*u32*/ number | undefined;
  blockTime: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link TxStatus} record objects.
 */
export const TxStatus = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TxStatus, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TxStatus}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TxStatus}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TxStatus>,
  });
})();

const FfiConverterTypeTxStatus = (() => {
  type TypeName = TxStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        confirmed: FfiConverterBool.read(from),
        blockHeight: FfiConverterOptionalUInt32.read(from),
        blockTime: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.confirmed, into);
      FfiConverterOptionalUInt32.write(value.blockHeight, into);
      FfiConverterOptionalUInt64.write(value.blockTime, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterBool.allocationSize(value.confirmed) +
        FfiConverterOptionalUInt32.allocationSize(value.blockHeight) +
        FfiConverterOptionalUInt64.allocationSize(value.blockTime)
      );
    }
  }
  return new FFIConverter();
})();

export type Utxo = {
  txid: string;
  vout: /*u32*/ number;
  value: /*u64*/ bigint;
  status: TxStatus;
};

/**
 * Generated factory for {@link Utxo} record objects.
 */
export const Utxo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Utxo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Utxo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Utxo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Utxo>,
  });
})();

const FfiConverterTypeUtxo = (() => {
  type TypeName = Utxo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        value: FfiConverterUInt64.read(from),
        status: FfiConverterTypeTxStatus.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterUInt64.write(value.value, into);
      FfiConverterTypeTxStatus.write(value.status, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterUInt64.allocationSize(value.value) +
        FfiConverterTypeTxStatus.allocationSize(value.status)
      );
    }
  }
  return new FFIConverter();
})();

export type WaitForPaymentRequest = {
  identifier: WaitForPaymentIdentifier;
};

/**
 * Generated factory for {@link WaitForPaymentRequest} record objects.
 */
export const WaitForPaymentRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      WaitForPaymentRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WaitForPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WaitForPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WaitForPaymentRequest>,
  });
})();

const FfiConverterTypeWaitForPaymentRequest = (() => {
  type TypeName = WaitForPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        identifier: FfiConverterTypeWaitForPaymentIdentifier.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeWaitForPaymentIdentifier.write(value.identifier, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeWaitForPaymentIdentifier.allocationSize(
        value.identifier
      );
    }
  }
  return new FFIConverter();
})();

export type WaitForPaymentResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link WaitForPaymentResponse} record objects.
 */
export const WaitForPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      WaitForPaymentResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WaitForPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WaitForPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<WaitForPaymentResponse>,
  });
})();

const FfiConverterTypeWaitForPaymentResponse = (() => {
  type TypeName = WaitForPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type U128 = bigint;

// FfiConverter for U128
const FfiConverterTypeu128 = (() => {
  type TsType = U128;
  type FfiType = Uint8Array;
  const intermediateConverter = FfiConverterString;
  class FFIConverter implements FfiConverter<FfiType, TsType> {
    lift(value: FfiType): TsType {
      const intermediate = intermediateConverter.lift(value);
      return BigInt(intermediate);
    }
    lower(value: TsType): FfiType {
      const intermediate = value.toString();
      return intermediateConverter.lower(intermediate);
    }
    read(from: RustBuffer): TsType {
      const intermediate = intermediateConverter.read(from);
      return BigInt(intermediate);
    }
    write(value: TsType, into: RustBuffer): void {
      const intermediate = value.toString();
      intermediateConverter.write(intermediate, into);
    }
    allocationSize(value: TsType): number {
      const intermediate = value.toString();
      return intermediateConverter.allocationSize(intermediate);
    }
  }

  return new FFIConverter();
})();

// Enum: AssetFilter
export enum AssetFilter_Tags {
  Bitcoin = 'Bitcoin',
  Token = 'Token',
}
/**
 * A field of [`ListPaymentsRequest`] when listing payments filtered by asset
 */
export const AssetFilter = (() => {
  type Bitcoin__interface = {
    tag: AssetFilter_Tags.Bitcoin;
  };

  class Bitcoin_ extends UniffiEnum implements Bitcoin__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AssetFilter';
    readonly tag = AssetFilter_Tags.Bitcoin;
    constructor() {
      super('AssetFilter', 'Bitcoin');
    }

    static new(): Bitcoin_ {
      return new Bitcoin_();
    }

    static instanceOf(obj: any): obj is Bitcoin_ {
      return obj.tag === AssetFilter_Tags.Bitcoin;
    }
  }

  type Token__interface = {
    tag: AssetFilter_Tags.Token;
    inner: Readonly<{ tokenIdentifier: string | undefined }>;
  };

  class Token_ extends UniffiEnum implements Token__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AssetFilter';
    readonly tag = AssetFilter_Tags.Token;
    readonly inner: Readonly<{ tokenIdentifier: string | undefined }>;
    constructor(inner: {
      /**
       * Optional token identifier to filter by
       */ tokenIdentifier: string | undefined;
    }) {
      super('AssetFilter', 'Token');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Optional token identifier to filter by
       */ tokenIdentifier: string | undefined;
    }): Token_ {
      return new Token_(inner);
    }

    static instanceOf(obj: any): obj is Token_ {
      return obj.tag === AssetFilter_Tags.Token;
    }
  }

  function instanceOf(obj: any): obj is AssetFilter {
    return obj[uniffiTypeNameSymbol] === 'AssetFilter';
  }

  return Object.freeze({
    instanceOf,
    Bitcoin: Bitcoin_,
    Token: Token_,
  });
})();

/**
 * A field of [`ListPaymentsRequest`] when listing payments filtered by asset
 */

export type AssetFilter = InstanceType<
  (typeof AssetFilter)[keyof Omit<typeof AssetFilter, 'instanceOf'>]
>;

// FfiConverter for enum AssetFilter
const FfiConverterTypeAssetFilter = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AssetFilter;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AssetFilter.Bitcoin();
        case 2:
          return new AssetFilter.Token({
            tokenIdentifier: FfiConverterOptionalString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AssetFilter_Tags.Bitcoin: {
          ordinalConverter.write(1, into);
          return;
        }
        case AssetFilter_Tags.Token: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.tokenIdentifier, into);
          return;
        }
        default:
          // Throwing from here means that AssetFilter_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AssetFilter_Tags.Bitcoin: {
          return ordinalConverter.allocationSize(1);
        }
        case AssetFilter_Tags.Token: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalString.allocationSize(
            inner.tokenIdentifier
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: ChainServiceError

// Enum: ChainServiceError
export enum ChainServiceError_Tags {
  InvalidAddress = 'InvalidAddress',
  ServiceConnectivity = 'ServiceConnectivity',
  Generic = 'Generic',
}
export const ChainServiceError = (() => {
  type InvalidAddress__interface = {
    tag: ChainServiceError_Tags.InvalidAddress;
    inner: Readonly<[string]>;
  };

  class InvalidAddress_
    extends UniffiError
    implements InvalidAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ChainServiceError';
    readonly tag = ChainServiceError_Tags.InvalidAddress;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ChainServiceError', 'InvalidAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidAddress_ {
      return new InvalidAddress_(v0);
    }

    static instanceOf(obj: any): obj is InvalidAddress_ {
      return obj.tag === ChainServiceError_Tags.InvalidAddress;
    }

    static hasInner(obj: any): obj is InvalidAddress_ {
      return InvalidAddress_.instanceOf(obj);
    }

    static getInner(obj: InvalidAddress_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type ServiceConnectivity__interface = {
    tag: ChainServiceError_Tags.ServiceConnectivity;
    inner: Readonly<[string]>;
  };

  class ServiceConnectivity_
    extends UniffiError
    implements ServiceConnectivity__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ChainServiceError';
    readonly tag = ChainServiceError_Tags.ServiceConnectivity;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ChainServiceError', 'ServiceConnectivity');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): ServiceConnectivity_ {
      return new ServiceConnectivity_(v0);
    }

    static instanceOf(obj: any): obj is ServiceConnectivity_ {
      return obj.tag === ChainServiceError_Tags.ServiceConnectivity;
    }

    static hasInner(obj: any): obj is ServiceConnectivity_ {
      return ServiceConnectivity_.instanceOf(obj);
    }

    static getInner(obj: ServiceConnectivity_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Generic__interface = {
    tag: ChainServiceError_Tags.Generic;
    inner: Readonly<[string]>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ChainServiceError';
    readonly tag = ChainServiceError_Tags.Generic;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ChainServiceError', 'Generic');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Generic_ {
      return new Generic_(v0);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === ChainServiceError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is ChainServiceError {
    return obj[uniffiTypeNameSymbol] === 'ChainServiceError';
  }

  return Object.freeze({
    instanceOf,
    InvalidAddress: InvalidAddress_,
    ServiceConnectivity: ServiceConnectivity_,
    Generic: Generic_,
  });
})();

export type ChainServiceError = InstanceType<
  (typeof ChainServiceError)[keyof Omit<typeof ChainServiceError, 'instanceOf'>]
>;

// FfiConverter for enum ChainServiceError
const FfiConverterTypeChainServiceError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ChainServiceError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ChainServiceError.InvalidAddress(
            FfiConverterString.read(from)
          );
        case 2:
          return new ChainServiceError.ServiceConnectivity(
            FfiConverterString.read(from)
          );
        case 3:
          return new ChainServiceError.Generic(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ChainServiceError_Tags.InvalidAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ChainServiceError_Tags.ServiceConnectivity: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ChainServiceError_Tags.Generic: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that ChainServiceError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ChainServiceError_Tags.InvalidAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ChainServiceError_Tags.ServiceConnectivity: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ChainServiceError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: DepositClaimError
export enum DepositClaimError_Tags {
  DepositClaimFeeExceeded = 'DepositClaimFeeExceeded',
  MissingUtxo = 'MissingUtxo',
  Generic = 'Generic',
}
export const DepositClaimError = (() => {
  type DepositClaimFeeExceeded__interface = {
    tag: DepositClaimError_Tags.DepositClaimFeeExceeded;
    inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }>;
  };

  class DepositClaimFeeExceeded_
    extends UniffiEnum
    implements DepositClaimFeeExceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DepositClaimError';
    readonly tag = DepositClaimError_Tags.DepositClaimFeeExceeded;
    readonly inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }>;
    constructor(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }) {
      super('DepositClaimError', 'DepositClaimFeeExceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }): DepositClaimFeeExceeded_ {
      return new DepositClaimFeeExceeded_(inner);
    }

    static instanceOf(obj: any): obj is DepositClaimFeeExceeded_ {
      return obj.tag === DepositClaimError_Tags.DepositClaimFeeExceeded;
    }
  }

  type MissingUtxo__interface = {
    tag: DepositClaimError_Tags.MissingUtxo;
    inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
  };

  class MissingUtxo_ extends UniffiEnum implements MissingUtxo__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DepositClaimError';
    readonly tag = DepositClaimError_Tags.MissingUtxo;
    readonly inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
    constructor(inner: { tx: string; vout: /*u32*/ number }) {
      super('DepositClaimError', 'MissingUtxo');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { tx: string; vout: /*u32*/ number }): MissingUtxo_ {
      return new MissingUtxo_(inner);
    }

    static instanceOf(obj: any): obj is MissingUtxo_ {
      return obj.tag === DepositClaimError_Tags.MissingUtxo;
    }
  }

  type Generic__interface = {
    tag: DepositClaimError_Tags.Generic;
    inner: Readonly<{ message: string }>;
  };

  class Generic_ extends UniffiEnum implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DepositClaimError';
    readonly tag = DepositClaimError_Tags.Generic;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('DepositClaimError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === DepositClaimError_Tags.Generic;
    }
  }

  function instanceOf(obj: any): obj is DepositClaimError {
    return obj[uniffiTypeNameSymbol] === 'DepositClaimError';
  }

  return Object.freeze({
    instanceOf,
    DepositClaimFeeExceeded: DepositClaimFeeExceeded_,
    MissingUtxo: MissingUtxo_,
    Generic: Generic_,
  });
})();

export type DepositClaimError = InstanceType<
  (typeof DepositClaimError)[keyof Omit<typeof DepositClaimError, 'instanceOf'>]
>;

// FfiConverter for enum DepositClaimError
const FfiConverterTypeDepositClaimError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = DepositClaimError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new DepositClaimError.DepositClaimFeeExceeded({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
            maxFee: FfiConverterTypeFee.read(from),
            actualFee: FfiConverterUInt64.read(from),
          });
        case 2:
          return new DepositClaimError.MissingUtxo({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
          });
        case 3:
          return new DepositClaimError.Generic({
            message: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case DepositClaimError_Tags.DepositClaimFeeExceeded: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          FfiConverterTypeFee.write(inner.maxFee, into);
          FfiConverterUInt64.write(inner.actualFee, into);
          return;
        }
        case DepositClaimError_Tags.MissingUtxo: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          return;
        }
        case DepositClaimError_Tags.Generic: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that DepositClaimError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case DepositClaimError_Tags.DepositClaimFeeExceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          size += FfiConverterTypeFee.allocationSize(inner.maxFee);
          size += FfiConverterUInt64.allocationSize(inner.actualFee);
          return size;
        }
        case DepositClaimError_Tags.MissingUtxo: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          return size;
        }
        case DepositClaimError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Fee
export enum Fee_Tags {
  Fixed = 'Fixed',
  Rate = 'Rate',
}
export const Fee = (() => {
  type Fixed__interface = {
    tag: Fee_Tags.Fixed;
    inner: Readonly<{ amount: /*u64*/ bigint }>;
  };

  class Fixed_ extends UniffiEnum implements Fixed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Fee';
    readonly tag = Fee_Tags.Fixed;
    readonly inner: Readonly<{ amount: /*u64*/ bigint }>;
    constructor(inner: { amount: /*u64*/ bigint }) {
      super('Fee', 'Fixed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { amount: /*u64*/ bigint }): Fixed_ {
      return new Fixed_(inner);
    }

    static instanceOf(obj: any): obj is Fixed_ {
      return obj.tag === Fee_Tags.Fixed;
    }
  }

  type Rate__interface = {
    tag: Fee_Tags.Rate;
    inner: Readonly<{ satPerVbyte: /*u64*/ bigint }>;
  };

  class Rate_ extends UniffiEnum implements Rate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Fee';
    readonly tag = Fee_Tags.Rate;
    readonly inner: Readonly<{ satPerVbyte: /*u64*/ bigint }>;
    constructor(inner: { satPerVbyte: /*u64*/ bigint }) {
      super('Fee', 'Rate');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { satPerVbyte: /*u64*/ bigint }): Rate_ {
      return new Rate_(inner);
    }

    static instanceOf(obj: any): obj is Rate_ {
      return obj.tag === Fee_Tags.Rate;
    }
  }

  function instanceOf(obj: any): obj is Fee {
    return obj[uniffiTypeNameSymbol] === 'Fee';
  }

  return Object.freeze({
    instanceOf,
    Fixed: Fixed_,
    Rate: Rate_,
  });
})();

export type Fee = InstanceType<
  (typeof Fee)[keyof Omit<typeof Fee, 'instanceOf'>]
>;

// FfiConverter for enum Fee
const FfiConverterTypeFee = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Fee;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Fee.Fixed({ amount: FfiConverterUInt64.read(from) });
        case 2:
          return new Fee.Rate({ satPerVbyte: FfiConverterUInt64.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Fee_Tags.Fixed: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.amount, into);
          return;
        }
        case Fee_Tags.Rate: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.satPerVbyte, into);
          return;
        }
        default:
          // Throwing from here means that Fee_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Fee_Tags.Fixed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner.amount);
          return size;
        }
        case Fee_Tags.Rate: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt64.allocationSize(inner.satPerVbyte);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum KeySetType {
  Default,
  Taproot,
  NativeSegwit,
  WrappedSegwit,
  Legacy,
}

const FfiConverterTypeKeySetType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = KeySetType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return KeySetType.Default;
        case 2:
          return KeySetType.Taproot;
        case 3:
          return KeySetType.NativeSegwit;
        case 4:
          return KeySetType.WrappedSegwit;
        case 5:
          return KeySetType.Legacy;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case KeySetType.Default:
          return ordinalConverter.write(1, into);
        case KeySetType.Taproot:
          return ordinalConverter.write(2, into);
        case KeySetType.NativeSegwit:
          return ordinalConverter.write(3, into);
        case KeySetType.WrappedSegwit:
          return ordinalConverter.write(4, into);
        case KeySetType.Legacy:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum Network {
  Mainnet,
  Regtest,
}

const FfiConverterTypeNetwork = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Network;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Network.Mainnet;
        case 2:
          return Network.Regtest;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Network.Mainnet:
          return ordinalConverter.write(1, into);
        case Network.Regtest:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum OnchainConfirmationSpeed {
  Fast,
  Medium,
  Slow,
}

const FfiConverterTypeOnchainConfirmationSpeed = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = OnchainConfirmationSpeed;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return OnchainConfirmationSpeed.Fast;
        case 2:
          return OnchainConfirmationSpeed.Medium;
        case 3:
          return OnchainConfirmationSpeed.Slow;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case OnchainConfirmationSpeed.Fast:
          return ordinalConverter.write(1, into);
        case OnchainConfirmationSpeed.Medium:
          return ordinalConverter.write(2, into);
        case OnchainConfirmationSpeed.Slow:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: PaymentDetails
export enum PaymentDetails_Tags {
  Spark = 'Spark',
  Token = 'Token',
  Lightning = 'Lightning',
  Withdraw = 'Withdraw',
  Deposit = 'Deposit',
}
export const PaymentDetails = (() => {
  type Spark__interface = {
    tag: PaymentDetails_Tags.Spark;
  };

  class Spark_ extends UniffiEnum implements Spark__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Spark;
    constructor() {
      super('PaymentDetails', 'Spark');
    }

    static new(): Spark_ {
      return new Spark_();
    }

    static instanceOf(obj: any): obj is Spark_ {
      return obj.tag === PaymentDetails_Tags.Spark;
    }
  }

  type Token__interface = {
    tag: PaymentDetails_Tags.Token;
    inner: Readonly<{ metadata: TokenMetadata; txHash: string }>;
  };

  class Token_ extends UniffiEnum implements Token__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Token;
    readonly inner: Readonly<{ metadata: TokenMetadata; txHash: string }>;
    constructor(inner: { metadata: TokenMetadata; txHash: string }) {
      super('PaymentDetails', 'Token');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { metadata: TokenMetadata; txHash: string }): Token_ {
      return new Token_(inner);
    }

    static instanceOf(obj: any): obj is Token_ {
      return obj.tag === PaymentDetails_Tags.Token;
    }
  }

  type Lightning__interface = {
    tag: PaymentDetails_Tags.Lightning;
    inner: Readonly<{
      description: string | undefined;
      preimage: string | undefined;
      invoice: string;
      paymentHash: string;
      destinationPubkey: string;
      lnurlPayInfo: LnurlPayInfo | undefined;
    }>;
  };

  class Lightning_ extends UniffiEnum implements Lightning__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Lightning;
    readonly inner: Readonly<{
      description: string | undefined;
      preimage: string | undefined;
      invoice: string;
      paymentHash: string;
      destinationPubkey: string;
      lnurlPayInfo: LnurlPayInfo | undefined;
    }>;
    constructor(inner: {
      /**
       * Represents the invoice description
       */ description: string | undefined;
      /**
       * The preimage of the paid invoice (proof of payment).
       */ preimage: string | undefined;
      /**
       * Represents the Bolt11/Bolt12 invoice associated with a payment
       * In the case of a Send payment, this is the invoice paid by the user
       * In the case of a Receive payment, this is the invoice paid to the user
       */ invoice: string;
      /**
       * The payment hash of the invoice
       */ paymentHash: string;
      /**
       * The invoice destination/payee pubkey
       */ destinationPubkey: string;
      /**
       * Lnurl payment information if this was an lnurl payment.
       */ lnurlPayInfo: LnurlPayInfo | undefined;
    }) {
      super('PaymentDetails', 'Lightning');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Represents the invoice description
       */ description: string | undefined;
      /**
       * The preimage of the paid invoice (proof of payment).
       */ preimage: string | undefined;
      /**
       * Represents the Bolt11/Bolt12 invoice associated with a payment
       * In the case of a Send payment, this is the invoice paid by the user
       * In the case of a Receive payment, this is the invoice paid to the user
       */ invoice: string;
      /**
       * The payment hash of the invoice
       */ paymentHash: string;
      /**
       * The invoice destination/payee pubkey
       */ destinationPubkey: string;
      /**
       * Lnurl payment information if this was an lnurl payment.
       */ lnurlPayInfo: LnurlPayInfo | undefined;
    }): Lightning_ {
      return new Lightning_(inner);
    }

    static instanceOf(obj: any): obj is Lightning_ {
      return obj.tag === PaymentDetails_Tags.Lightning;
    }
  }

  type Withdraw__interface = {
    tag: PaymentDetails_Tags.Withdraw;
    inner: Readonly<{ txId: string }>;
  };

  class Withdraw_ extends UniffiEnum implements Withdraw__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Withdraw;
    readonly inner: Readonly<{ txId: string }>;
    constructor(inner: { txId: string }) {
      super('PaymentDetails', 'Withdraw');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { txId: string }): Withdraw_ {
      return new Withdraw_(inner);
    }

    static instanceOf(obj: any): obj is Withdraw_ {
      return obj.tag === PaymentDetails_Tags.Withdraw;
    }
  }

  type Deposit__interface = {
    tag: PaymentDetails_Tags.Deposit;
    inner: Readonly<{ txId: string }>;
  };

  class Deposit_ extends UniffiEnum implements Deposit__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Deposit;
    readonly inner: Readonly<{ txId: string }>;
    constructor(inner: { txId: string }) {
      super('PaymentDetails', 'Deposit');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { txId: string }): Deposit_ {
      return new Deposit_(inner);
    }

    static instanceOf(obj: any): obj is Deposit_ {
      return obj.tag === PaymentDetails_Tags.Deposit;
    }
  }

  function instanceOf(obj: any): obj is PaymentDetails {
    return obj[uniffiTypeNameSymbol] === 'PaymentDetails';
  }

  return Object.freeze({
    instanceOf,
    Spark: Spark_,
    Token: Token_,
    Lightning: Lightning_,
    Withdraw: Withdraw_,
    Deposit: Deposit_,
  });
})();

export type PaymentDetails = InstanceType<
  (typeof PaymentDetails)[keyof Omit<typeof PaymentDetails, 'instanceOf'>]
>;

// FfiConverter for enum PaymentDetails
const FfiConverterTypePaymentDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PaymentDetails.Spark();
        case 2:
          return new PaymentDetails.Token({
            metadata: FfiConverterTypeTokenMetadata.read(from),
            txHash: FfiConverterString.read(from),
          });
        case 3:
          return new PaymentDetails.Lightning({
            description: FfiConverterOptionalString.read(from),
            preimage: FfiConverterOptionalString.read(from),
            invoice: FfiConverterString.read(from),
            paymentHash: FfiConverterString.read(from),
            destinationPubkey: FfiConverterString.read(from),
            lnurlPayInfo: FfiConverterOptionalTypeLnurlPayInfo.read(from),
          });
        case 4:
          return new PaymentDetails.Withdraw({
            txId: FfiConverterString.read(from),
          });
        case 5:
          return new PaymentDetails.Deposit({
            txId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PaymentDetails_Tags.Spark: {
          ordinalConverter.write(1, into);
          return;
        }
        case PaymentDetails_Tags.Token: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeTokenMetadata.write(inner.metadata, into);
          FfiConverterString.write(inner.txHash, into);
          return;
        }
        case PaymentDetails_Tags.Lightning: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.description, into);
          FfiConverterOptionalString.write(inner.preimage, into);
          FfiConverterString.write(inner.invoice, into);
          FfiConverterString.write(inner.paymentHash, into);
          FfiConverterString.write(inner.destinationPubkey, into);
          FfiConverterOptionalTypeLnurlPayInfo.write(inner.lnurlPayInfo, into);
          return;
        }
        case PaymentDetails_Tags.Withdraw: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.txId, into);
          return;
        }
        case PaymentDetails_Tags.Deposit: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.txId, into);
          return;
        }
        default:
          // Throwing from here means that PaymentDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PaymentDetails_Tags.Spark: {
          return ordinalConverter.allocationSize(1);
        }
        case PaymentDetails_Tags.Token: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeTokenMetadata.allocationSize(inner.metadata);
          size += FfiConverterString.allocationSize(inner.txHash);
          return size;
        }
        case PaymentDetails_Tags.Lightning: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterOptionalString.allocationSize(inner.description);
          size += FfiConverterOptionalString.allocationSize(inner.preimage);
          size += FfiConverterString.allocationSize(inner.invoice);
          size += FfiConverterString.allocationSize(inner.paymentHash);
          size += FfiConverterString.allocationSize(inner.destinationPubkey);
          size += FfiConverterOptionalTypeLnurlPayInfo.allocationSize(
            inner.lnurlPayInfo
          );
          return size;
        }
        case PaymentDetails_Tags.Withdraw: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.txId);
          return size;
        }
        case PaymentDetails_Tags.Deposit: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.txId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum PaymentMethod {
  Lightning,
  Spark,
  Token,
  Deposit,
  Withdraw,
  Unknown,
}

const FfiConverterTypePaymentMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentMethod.Lightning;
        case 2:
          return PaymentMethod.Spark;
        case 3:
          return PaymentMethod.Token;
        case 4:
          return PaymentMethod.Deposit;
        case 5:
          return PaymentMethod.Withdraw;
        case 6:
          return PaymentMethod.Unknown;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentMethod.Lightning:
          return ordinalConverter.write(1, into);
        case PaymentMethod.Spark:
          return ordinalConverter.write(2, into);
        case PaymentMethod.Token:
          return ordinalConverter.write(3, into);
        case PaymentMethod.Deposit:
          return ordinalConverter.write(4, into);
        case PaymentMethod.Withdraw:
          return ordinalConverter.write(5, into);
        case PaymentMethod.Unknown:
          return ordinalConverter.write(6, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: PaymentObserverError

// Enum: PaymentObserverError
export enum PaymentObserverError_Tags {
  ServiceConnectivity = 'ServiceConnectivity',
  Generic = 'Generic',
}
export const PaymentObserverError = (() => {
  type ServiceConnectivity__interface = {
    tag: PaymentObserverError_Tags.ServiceConnectivity;
    inner: Readonly<[string]>;
  };

  class ServiceConnectivity_
    extends UniffiError
    implements ServiceConnectivity__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentObserverError';
    readonly tag = PaymentObserverError_Tags.ServiceConnectivity;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PaymentObserverError', 'ServiceConnectivity');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): ServiceConnectivity_ {
      return new ServiceConnectivity_(v0);
    }

    static instanceOf(obj: any): obj is ServiceConnectivity_ {
      return obj.tag === PaymentObserverError_Tags.ServiceConnectivity;
    }

    static hasInner(obj: any): obj is ServiceConnectivity_ {
      return ServiceConnectivity_.instanceOf(obj);
    }

    static getInner(obj: ServiceConnectivity_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Generic__interface = {
    tag: PaymentObserverError_Tags.Generic;
    inner: Readonly<[string]>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentObserverError';
    readonly tag = PaymentObserverError_Tags.Generic;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PaymentObserverError', 'Generic');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Generic_ {
      return new Generic_(v0);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === PaymentObserverError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is PaymentObserverError {
    return obj[uniffiTypeNameSymbol] === 'PaymentObserverError';
  }

  return Object.freeze({
    instanceOf,
    ServiceConnectivity: ServiceConnectivity_,
    Generic: Generic_,
  });
})();

export type PaymentObserverError = InstanceType<
  (typeof PaymentObserverError)[keyof Omit<
    typeof PaymentObserverError,
    'instanceOf'
  >]
>;

// FfiConverter for enum PaymentObserverError
const FfiConverterTypePaymentObserverError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentObserverError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PaymentObserverError.ServiceConnectivity(
            FfiConverterString.read(from)
          );
        case 2:
          return new PaymentObserverError.Generic(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PaymentObserverError_Tags.ServiceConnectivity: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case PaymentObserverError_Tags.Generic: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that PaymentObserverError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PaymentObserverError_Tags.ServiceConnectivity: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case PaymentObserverError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * The status of a payment
 */
export enum PaymentStatus {
  /**
   * Payment is completed successfully
   */
  Completed,
  /**
   * Payment is in progress
   */
  Pending,
  /**
   * Payment has failed
   */
  Failed,
}

const FfiConverterTypePaymentStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentStatus.Completed;
        case 2:
          return PaymentStatus.Pending;
        case 3:
          return PaymentStatus.Failed;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentStatus.Completed:
          return ordinalConverter.write(1, into);
        case PaymentStatus.Pending:
          return ordinalConverter.write(2, into);
        case PaymentStatus.Failed:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The type of payment
 */
export enum PaymentType {
  /**
   * Payment sent from this wallet
   */
  Send,
  /**
   * Payment received to this wallet
   */
  Receive,
}

const FfiConverterTypePaymentType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentType.Send;
        case 2:
          return PaymentType.Receive;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentType.Send:
          return ordinalConverter.write(1, into);
        case PaymentType.Receive:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ProvisionalPaymentDetails
export enum ProvisionalPaymentDetails_Tags {
  Bitcoin = 'Bitcoin',
  Lightning = 'Lightning',
  Spark = 'Spark',
  Token = 'Token',
}
export const ProvisionalPaymentDetails = (() => {
  type Bitcoin__interface = {
    tag: ProvisionalPaymentDetails_Tags.Bitcoin;
    inner: Readonly<{ withdrawalAddress: string }>;
  };

  class Bitcoin_ extends UniffiEnum implements Bitcoin__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProvisionalPaymentDetails';
    readonly tag = ProvisionalPaymentDetails_Tags.Bitcoin;
    readonly inner: Readonly<{ withdrawalAddress: string }>;
    constructor(inner: {
      /**
       * Onchain Bitcoin address
       */ withdrawalAddress: string;
    }) {
      super('ProvisionalPaymentDetails', 'Bitcoin');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Onchain Bitcoin address
       */ withdrawalAddress: string;
    }): Bitcoin_ {
      return new Bitcoin_(inner);
    }

    static instanceOf(obj: any): obj is Bitcoin_ {
      return obj.tag === ProvisionalPaymentDetails_Tags.Bitcoin;
    }
  }

  type Lightning__interface = {
    tag: ProvisionalPaymentDetails_Tags.Lightning;
    inner: Readonly<{ invoice: string }>;
  };

  class Lightning_ extends UniffiEnum implements Lightning__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProvisionalPaymentDetails';
    readonly tag = ProvisionalPaymentDetails_Tags.Lightning;
    readonly inner: Readonly<{ invoice: string }>;
    constructor(inner: {
      /**
       * BOLT11 invoice
       */ invoice: string;
    }) {
      super('ProvisionalPaymentDetails', 'Lightning');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * BOLT11 invoice
       */ invoice: string;
    }): Lightning_ {
      return new Lightning_(inner);
    }

    static instanceOf(obj: any): obj is Lightning_ {
      return obj.tag === ProvisionalPaymentDetails_Tags.Lightning;
    }
  }

  type Spark__interface = {
    tag: ProvisionalPaymentDetails_Tags.Spark;
    inner: Readonly<{ receiverAddress: string }>;
  };

  class Spark_ extends UniffiEnum implements Spark__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProvisionalPaymentDetails';
    readonly tag = ProvisionalPaymentDetails_Tags.Spark;
    readonly inner: Readonly<{ receiverAddress: string }>;
    constructor(inner: {
      /**
       * Spark receiver address
       */ receiverAddress: string;
    }) {
      super('ProvisionalPaymentDetails', 'Spark');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Spark receiver address
       */ receiverAddress: string;
    }): Spark_ {
      return new Spark_(inner);
    }

    static instanceOf(obj: any): obj is Spark_ {
      return obj.tag === ProvisionalPaymentDetails_Tags.Spark;
    }
  }

  type Token__interface = {
    tag: ProvisionalPaymentDetails_Tags.Token;
    inner: Readonly<{ tokenId: string; receiverAddress: string }>;
  };

  class Token_ extends UniffiEnum implements Token__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProvisionalPaymentDetails';
    readonly tag = ProvisionalPaymentDetails_Tags.Token;
    readonly inner: Readonly<{ tokenId: string; receiverAddress: string }>;
    constructor(inner: {
      /**
       * Token identifier
       */ tokenId: string;
      /**
       * Spark receiver address
       */ receiverAddress: string;
    }) {
      super('ProvisionalPaymentDetails', 'Token');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Token identifier
       */ tokenId: string;
      /**
       * Spark receiver address
       */ receiverAddress: string;
    }): Token_ {
      return new Token_(inner);
    }

    static instanceOf(obj: any): obj is Token_ {
      return obj.tag === ProvisionalPaymentDetails_Tags.Token;
    }
  }

  function instanceOf(obj: any): obj is ProvisionalPaymentDetails {
    return obj[uniffiTypeNameSymbol] === 'ProvisionalPaymentDetails';
  }

  return Object.freeze({
    instanceOf,
    Bitcoin: Bitcoin_,
    Lightning: Lightning_,
    Spark: Spark_,
    Token: Token_,
  });
})();

export type ProvisionalPaymentDetails = InstanceType<
  (typeof ProvisionalPaymentDetails)[keyof Omit<
    typeof ProvisionalPaymentDetails,
    'instanceOf'
  >]
>;

// FfiConverter for enum ProvisionalPaymentDetails
const FfiConverterTypeProvisionalPaymentDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ProvisionalPaymentDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ProvisionalPaymentDetails.Bitcoin({
            withdrawalAddress: FfiConverterString.read(from),
          });
        case 2:
          return new ProvisionalPaymentDetails.Lightning({
            invoice: FfiConverterString.read(from),
          });
        case 3:
          return new ProvisionalPaymentDetails.Spark({
            receiverAddress: FfiConverterString.read(from),
          });
        case 4:
          return new ProvisionalPaymentDetails.Token({
            tokenId: FfiConverterString.read(from),
            receiverAddress: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ProvisionalPaymentDetails_Tags.Bitcoin: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.withdrawalAddress, into);
          return;
        }
        case ProvisionalPaymentDetails_Tags.Lightning: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.invoice, into);
          return;
        }
        case ProvisionalPaymentDetails_Tags.Spark: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.receiverAddress, into);
          return;
        }
        case ProvisionalPaymentDetails_Tags.Token: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tokenId, into);
          FfiConverterString.write(inner.receiverAddress, into);
          return;
        }
        default:
          // Throwing from here means that ProvisionalPaymentDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ProvisionalPaymentDetails_Tags.Bitcoin: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.withdrawalAddress);
          return size;
        }
        case ProvisionalPaymentDetails_Tags.Lightning: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.invoice);
          return size;
        }
        case ProvisionalPaymentDetails_Tags.Spark: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.receiverAddress);
          return size;
        }
        case ProvisionalPaymentDetails_Tags.Token: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.tokenId);
          size += FfiConverterString.allocationSize(inner.receiverAddress);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ReceivePaymentMethod
export enum ReceivePaymentMethod_Tags {
  SparkAddress = 'SparkAddress',
  BitcoinAddress = 'BitcoinAddress',
  Bolt11Invoice = 'Bolt11Invoice',
}
export const ReceivePaymentMethod = (() => {
  type SparkAddress__interface = {
    tag: ReceivePaymentMethod_Tags.SparkAddress;
  };

  class SparkAddress_ extends UniffiEnum implements SparkAddress__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceivePaymentMethod';
    readonly tag = ReceivePaymentMethod_Tags.SparkAddress;
    constructor() {
      super('ReceivePaymentMethod', 'SparkAddress');
    }

    static new(): SparkAddress_ {
      return new SparkAddress_();
    }

    static instanceOf(obj: any): obj is SparkAddress_ {
      return obj.tag === ReceivePaymentMethod_Tags.SparkAddress;
    }
  }

  type BitcoinAddress__interface = {
    tag: ReceivePaymentMethod_Tags.BitcoinAddress;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceivePaymentMethod';
    readonly tag = ReceivePaymentMethod_Tags.BitcoinAddress;
    constructor() {
      super('ReceivePaymentMethod', 'BitcoinAddress');
    }

    static new(): BitcoinAddress_ {
      return new BitcoinAddress_();
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === ReceivePaymentMethod_Tags.BitcoinAddress;
    }
  }

  type Bolt11Invoice__interface = {
    tag: ReceivePaymentMethod_Tags.Bolt11Invoice;
    inner: Readonly<{
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }>;
  };

  class Bolt11Invoice_ extends UniffiEnum implements Bolt11Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceivePaymentMethod';
    readonly tag = ReceivePaymentMethod_Tags.Bolt11Invoice;
    readonly inner: Readonly<{
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }>;
    constructor(inner: {
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }) {
      super('ReceivePaymentMethod', 'Bolt11Invoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }): Bolt11Invoice_ {
      return new Bolt11Invoice_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11Invoice_ {
      return obj.tag === ReceivePaymentMethod_Tags.Bolt11Invoice;
    }
  }

  function instanceOf(obj: any): obj is ReceivePaymentMethod {
    return obj[uniffiTypeNameSymbol] === 'ReceivePaymentMethod';
  }

  return Object.freeze({
    instanceOf,
    SparkAddress: SparkAddress_,
    BitcoinAddress: BitcoinAddress_,
    Bolt11Invoice: Bolt11Invoice_,
  });
})();

export type ReceivePaymentMethod = InstanceType<
  (typeof ReceivePaymentMethod)[keyof Omit<
    typeof ReceivePaymentMethod,
    'instanceOf'
  >]
>;

// FfiConverter for enum ReceivePaymentMethod
const FfiConverterTypeReceivePaymentMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ReceivePaymentMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ReceivePaymentMethod.SparkAddress();
        case 2:
          return new ReceivePaymentMethod.BitcoinAddress();
        case 3:
          return new ReceivePaymentMethod.Bolt11Invoice({
            description: FfiConverterString.read(from),
            amountSats: FfiConverterOptionalUInt64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ReceivePaymentMethod_Tags.SparkAddress: {
          ordinalConverter.write(1, into);
          return;
        }
        case ReceivePaymentMethod_Tags.BitcoinAddress: {
          ordinalConverter.write(2, into);
          return;
        }
        case ReceivePaymentMethod_Tags.Bolt11Invoice: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.description, into);
          FfiConverterOptionalUInt64.write(inner.amountSats, into);
          return;
        }
        default:
          // Throwing from here means that ReceivePaymentMethod_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ReceivePaymentMethod_Tags.SparkAddress: {
          return ordinalConverter.allocationSize(1);
        }
        case ReceivePaymentMethod_Tags.BitcoinAddress: {
          return ordinalConverter.allocationSize(2);
        }
        case ReceivePaymentMethod_Tags.Bolt11Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.description);
          size += FfiConverterOptionalUInt64.allocationSize(inner.amountSats);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: SdkError

// Enum: SdkError
export enum SdkError_Tags {
  SparkError = 'SparkError',
  InvalidUuid = 'InvalidUuid',
  InvalidInput = 'InvalidInput',
  NetworkError = 'NetworkError',
  StorageError = 'StorageError',
  ChainServiceError = 'ChainServiceError',
  DepositClaimFeeExceeded = 'DepositClaimFeeExceeded',
  MissingUtxo = 'MissingUtxo',
  LnurlError = 'LnurlError',
  Generic = 'Generic',
}
/**
 * Error type for the `BreezSdk`
 */
export const SdkError = (() => {
  type SparkError__interface = {
    tag: SdkError_Tags.SparkError;
    inner: Readonly<[string]>;
  };

  class SparkError_ extends UniffiError implements SparkError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.SparkError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'SparkError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): SparkError_ {
      return new SparkError_(v0);
    }

    static instanceOf(obj: any): obj is SparkError_ {
      return obj.tag === SdkError_Tags.SparkError;
    }

    static hasInner(obj: any): obj is SparkError_ {
      return SparkError_.instanceOf(obj);
    }

    static getInner(obj: SparkError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidUuid__interface = {
    tag: SdkError_Tags.InvalidUuid;
    inner: Readonly<[string]>;
  };

  class InvalidUuid_ extends UniffiError implements InvalidUuid__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.InvalidUuid;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'InvalidUuid');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidUuid_ {
      return new InvalidUuid_(v0);
    }

    static instanceOf(obj: any): obj is InvalidUuid_ {
      return obj.tag === SdkError_Tags.InvalidUuid;
    }

    static hasInner(obj: any): obj is InvalidUuid_ {
      return InvalidUuid_.instanceOf(obj);
    }

    static getInner(obj: InvalidUuid_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidInput__interface = {
    tag: SdkError_Tags.InvalidInput;
    inner: Readonly<[string]>;
  };

  /**
   * Invalid input error
   */
  class InvalidInput_ extends UniffiError implements InvalidInput__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.InvalidInput;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'InvalidInput');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidInput_ {
      return new InvalidInput_(v0);
    }

    static instanceOf(obj: any): obj is InvalidInput_ {
      return obj.tag === SdkError_Tags.InvalidInput;
    }

    static hasInner(obj: any): obj is InvalidInput_ {
      return InvalidInput_.instanceOf(obj);
    }

    static getInner(obj: InvalidInput_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type NetworkError__interface = {
    tag: SdkError_Tags.NetworkError;
    inner: Readonly<[string]>;
  };

  /**
   * Network error
   */
  class NetworkError_ extends UniffiError implements NetworkError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.NetworkError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'NetworkError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): NetworkError_ {
      return new NetworkError_(v0);
    }

    static instanceOf(obj: any): obj is NetworkError_ {
      return obj.tag === SdkError_Tags.NetworkError;
    }

    static hasInner(obj: any): obj is NetworkError_ {
      return NetworkError_.instanceOf(obj);
    }

    static getInner(obj: NetworkError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type StorageError__interface = {
    tag: SdkError_Tags.StorageError;
    inner: Readonly<[string]>;
  };

  /**
   * Storage error
   */
  class StorageError_ extends UniffiError implements StorageError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.StorageError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'StorageError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): StorageError_ {
      return new StorageError_(v0);
    }

    static instanceOf(obj: any): obj is StorageError_ {
      return obj.tag === SdkError_Tags.StorageError;
    }

    static hasInner(obj: any): obj is StorageError_ {
      return StorageError_.instanceOf(obj);
    }

    static getInner(obj: StorageError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type ChainServiceError__interface = {
    tag: SdkError_Tags.ChainServiceError;
    inner: Readonly<[string]>;
  };

  class ChainServiceError_
    extends UniffiError
    implements ChainServiceError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.ChainServiceError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'ChainServiceError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): ChainServiceError_ {
      return new ChainServiceError_(v0);
    }

    static instanceOf(obj: any): obj is ChainServiceError_ {
      return obj.tag === SdkError_Tags.ChainServiceError;
    }

    static hasInner(obj: any): obj is ChainServiceError_ {
      return ChainServiceError_.instanceOf(obj);
    }

    static getInner(obj: ChainServiceError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type DepositClaimFeeExceeded__interface = {
    tag: SdkError_Tags.DepositClaimFeeExceeded;
    inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }>;
  };

  class DepositClaimFeeExceeded_
    extends UniffiError
    implements DepositClaimFeeExceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.DepositClaimFeeExceeded;
    readonly inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }>;
    constructor(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }) {
      super('SdkError', 'DepositClaimFeeExceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }): DepositClaimFeeExceeded_ {
      return new DepositClaimFeeExceeded_(inner);
    }

    static instanceOf(obj: any): obj is DepositClaimFeeExceeded_ {
      return obj.tag === SdkError_Tags.DepositClaimFeeExceeded;
    }

    static hasInner(obj: any): obj is DepositClaimFeeExceeded_ {
      return DepositClaimFeeExceeded_.instanceOf(obj);
    }

    static getInner(
      obj: DepositClaimFeeExceeded_
    ): Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }> {
      return obj.inner;
    }
  }

  type MissingUtxo__interface = {
    tag: SdkError_Tags.MissingUtxo;
    inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
  };

  class MissingUtxo_ extends UniffiError implements MissingUtxo__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.MissingUtxo;
    readonly inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
    constructor(inner: { tx: string; vout: /*u32*/ number }) {
      super('SdkError', 'MissingUtxo');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { tx: string; vout: /*u32*/ number }): MissingUtxo_ {
      return new MissingUtxo_(inner);
    }

    static instanceOf(obj: any): obj is MissingUtxo_ {
      return obj.tag === SdkError_Tags.MissingUtxo;
    }

    static hasInner(obj: any): obj is MissingUtxo_ {
      return MissingUtxo_.instanceOf(obj);
    }

    static getInner(
      obj: MissingUtxo_
    ): Readonly<{ tx: string; vout: /*u32*/ number }> {
      return obj.inner;
    }
  }

  type LnurlError__interface = {
    tag: SdkError_Tags.LnurlError;
    inner: Readonly<[string]>;
  };

  class LnurlError_ extends UniffiError implements LnurlError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.LnurlError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'LnurlError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): LnurlError_ {
      return new LnurlError_(v0);
    }

    static instanceOf(obj: any): obj is LnurlError_ {
      return obj.tag === SdkError_Tags.LnurlError;
    }

    static hasInner(obj: any): obj is LnurlError_ {
      return LnurlError_.instanceOf(obj);
    }

    static getInner(obj: LnurlError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Generic__interface = {
    tag: SdkError_Tags.Generic;
    inner: Readonly<[string]>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.Generic;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'Generic');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Generic_ {
      return new Generic_(v0);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === SdkError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is SdkError {
    return obj[uniffiTypeNameSymbol] === 'SdkError';
  }

  return Object.freeze({
    instanceOf,
    SparkError: SparkError_,
    InvalidUuid: InvalidUuid_,
    InvalidInput: InvalidInput_,
    NetworkError: NetworkError_,
    StorageError: StorageError_,
    ChainServiceError: ChainServiceError_,
    DepositClaimFeeExceeded: DepositClaimFeeExceeded_,
    MissingUtxo: MissingUtxo_,
    LnurlError: LnurlError_,
    Generic: Generic_,
  });
})();

/**
 * Error type for the `BreezSdk`
 */

export type SdkError = InstanceType<
  (typeof SdkError)[keyof Omit<typeof SdkError, 'instanceOf'>]
>;

// FfiConverter for enum SdkError
const FfiConverterTypeSdkError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SdkError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SdkError.SparkError(FfiConverterString.read(from));
        case 2:
          return new SdkError.InvalidUuid(FfiConverterString.read(from));
        case 3:
          return new SdkError.InvalidInput(FfiConverterString.read(from));
        case 4:
          return new SdkError.NetworkError(FfiConverterString.read(from));
        case 5:
          return new SdkError.StorageError(FfiConverterString.read(from));
        case 6:
          return new SdkError.ChainServiceError(FfiConverterString.read(from));
        case 7:
          return new SdkError.DepositClaimFeeExceeded({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
            maxFee: FfiConverterTypeFee.read(from),
            actualFee: FfiConverterUInt64.read(from),
          });
        case 8:
          return new SdkError.MissingUtxo({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
          });
        case 9:
          return new SdkError.LnurlError(FfiConverterString.read(from));
        case 10:
          return new SdkError.Generic(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SdkError_Tags.SparkError: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.InvalidUuid: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.InvalidInput: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.NetworkError: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.StorageError: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.ChainServiceError: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.DepositClaimFeeExceeded: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          FfiConverterTypeFee.write(inner.maxFee, into);
          FfiConverterUInt64.write(inner.actualFee, into);
          return;
        }
        case SdkError_Tags.MissingUtxo: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          return;
        }
        case SdkError_Tags.LnurlError: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.Generic: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that SdkError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SdkError_Tags.SparkError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.InvalidUuid: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.InvalidInput: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.NetworkError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.StorageError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.ChainServiceError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.DepositClaimFeeExceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          size += FfiConverterTypeFee.allocationSize(inner.maxFee);
          size += FfiConverterUInt64.allocationSize(inner.actualFee);
          return size;
        }
        case SdkError_Tags.MissingUtxo: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          return size;
        }
        case SdkError_Tags.LnurlError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SdkEvent
export enum SdkEvent_Tags {
  Synced = 'Synced',
  ClaimDepositsFailed = 'ClaimDepositsFailed',
  ClaimDepositsSucceeded = 'ClaimDepositsSucceeded',
  PaymentSucceeded = 'PaymentSucceeded',
  PaymentFailed = 'PaymentFailed',
}
/**
 * Events emitted by the SDK
 */
export const SdkEvent = (() => {
  type Synced__interface = {
    tag: SdkEvent_Tags.Synced;
  };

  /**
   * Emitted when the wallet has been synchronized with the network
   */
  class Synced_ extends UniffiEnum implements Synced__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.Synced;
    constructor() {
      super('SdkEvent', 'Synced');
    }

    static new(): Synced_ {
      return new Synced_();
    }

    static instanceOf(obj: any): obj is Synced_ {
      return obj.tag === SdkEvent_Tags.Synced;
    }
  }

  type ClaimDepositsFailed__interface = {
    tag: SdkEvent_Tags.ClaimDepositsFailed;
    inner: Readonly<{ unclaimedDeposits: Array<DepositInfo> }>;
  };

  /**
   * Emitted when the wallet failed to claim some deposits
   */
  class ClaimDepositsFailed_
    extends UniffiEnum
    implements ClaimDepositsFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.ClaimDepositsFailed;
    readonly inner: Readonly<{ unclaimedDeposits: Array<DepositInfo> }>;
    constructor(inner: { unclaimedDeposits: Array<DepositInfo> }) {
      super('SdkEvent', 'ClaimDepositsFailed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      unclaimedDeposits: Array<DepositInfo>;
    }): ClaimDepositsFailed_ {
      return new ClaimDepositsFailed_(inner);
    }

    static instanceOf(obj: any): obj is ClaimDepositsFailed_ {
      return obj.tag === SdkEvent_Tags.ClaimDepositsFailed;
    }
  }

  type ClaimDepositsSucceeded__interface = {
    tag: SdkEvent_Tags.ClaimDepositsSucceeded;
    inner: Readonly<{ claimedDeposits: Array<DepositInfo> }>;
  };

  class ClaimDepositsSucceeded_
    extends UniffiEnum
    implements ClaimDepositsSucceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.ClaimDepositsSucceeded;
    readonly inner: Readonly<{ claimedDeposits: Array<DepositInfo> }>;
    constructor(inner: { claimedDeposits: Array<DepositInfo> }) {
      super('SdkEvent', 'ClaimDepositsSucceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      claimedDeposits: Array<DepositInfo>;
    }): ClaimDepositsSucceeded_ {
      return new ClaimDepositsSucceeded_(inner);
    }

    static instanceOf(obj: any): obj is ClaimDepositsSucceeded_ {
      return obj.tag === SdkEvent_Tags.ClaimDepositsSucceeded;
    }
  }

  type PaymentSucceeded__interface = {
    tag: SdkEvent_Tags.PaymentSucceeded;
    inner: Readonly<{ payment: Payment }>;
  };

  class PaymentSucceeded_
    extends UniffiEnum
    implements PaymentSucceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentSucceeded;
    readonly inner: Readonly<{ payment: Payment }>;
    constructor(inner: { payment: Payment }) {
      super('SdkEvent', 'PaymentSucceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payment: Payment }): PaymentSucceeded_ {
      return new PaymentSucceeded_(inner);
    }

    static instanceOf(obj: any): obj is PaymentSucceeded_ {
      return obj.tag === SdkEvent_Tags.PaymentSucceeded;
    }
  }

  type PaymentFailed__interface = {
    tag: SdkEvent_Tags.PaymentFailed;
    inner: Readonly<{ payment: Payment }>;
  };

  class PaymentFailed_ extends UniffiEnum implements PaymentFailed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentFailed;
    readonly inner: Readonly<{ payment: Payment }>;
    constructor(inner: { payment: Payment }) {
      super('SdkEvent', 'PaymentFailed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payment: Payment }): PaymentFailed_ {
      return new PaymentFailed_(inner);
    }

    static instanceOf(obj: any): obj is PaymentFailed_ {
      return obj.tag === SdkEvent_Tags.PaymentFailed;
    }
  }

  function instanceOf(obj: any): obj is SdkEvent {
    return obj[uniffiTypeNameSymbol] === 'SdkEvent';
  }

  return Object.freeze({
    instanceOf,
    Synced: Synced_,
    ClaimDepositsFailed: ClaimDepositsFailed_,
    ClaimDepositsSucceeded: ClaimDepositsSucceeded_,
    PaymentSucceeded: PaymentSucceeded_,
    PaymentFailed: PaymentFailed_,
  });
})();

/**
 * Events emitted by the SDK
 */

export type SdkEvent = InstanceType<
  (typeof SdkEvent)[keyof Omit<typeof SdkEvent, 'instanceOf'>]
>;

// FfiConverter for enum SdkEvent
const FfiConverterTypeSdkEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SdkEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SdkEvent.Synced();
        case 2:
          return new SdkEvent.ClaimDepositsFailed({
            unclaimedDeposits: FfiConverterArrayTypeDepositInfo.read(from),
          });
        case 3:
          return new SdkEvent.ClaimDepositsSucceeded({
            claimedDeposits: FfiConverterArrayTypeDepositInfo.read(from),
          });
        case 4:
          return new SdkEvent.PaymentSucceeded({
            payment: FfiConverterTypePayment.read(from),
          });
        case 5:
          return new SdkEvent.PaymentFailed({
            payment: FfiConverterTypePayment.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SdkEvent_Tags.Synced: {
          ordinalConverter.write(1, into);
          return;
        }
        case SdkEvent_Tags.ClaimDepositsFailed: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayTypeDepositInfo.write(inner.unclaimedDeposits, into);
          return;
        }
        case SdkEvent_Tags.ClaimDepositsSucceeded: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterArrayTypeDepositInfo.write(inner.claimedDeposits, into);
          return;
        }
        case SdkEvent_Tags.PaymentSucceeded: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.payment, into);
          return;
        }
        case SdkEvent_Tags.PaymentFailed: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.payment, into);
          return;
        }
        default:
          // Throwing from here means that SdkEvent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SdkEvent_Tags.Synced: {
          return ordinalConverter.allocationSize(1);
        }
        case SdkEvent_Tags.ClaimDepositsFailed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayTypeDepositInfo.allocationSize(
            inner.unclaimedDeposits
          );
          return size;
        }
        case SdkEvent_Tags.ClaimDepositsSucceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterArrayTypeDepositInfo.allocationSize(
            inner.claimedDeposits
          );
          return size;
        }
        case SdkEvent_Tags.PaymentSucceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypePayment.allocationSize(inner.payment);
          return size;
        }
        case SdkEvent_Tags.PaymentFailed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypePayment.allocationSize(inner.payment);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Seed
export enum Seed_Tags {
  Mnemonic = 'Mnemonic',
  Entropy = 'Entropy',
}
/**
 * Represents the seed for wallet generation, either as a mnemonic phrase with an optional
 * passphrase or as raw entropy bytes.
 */
export const Seed = (() => {
  type Mnemonic__interface = {
    tag: Seed_Tags.Mnemonic;
    inner: Readonly<{ mnemonic: string; passphrase: string | undefined }>;
  };

  /**
   * A BIP-39 mnemonic phrase with an optional passphrase.
   */
  class Mnemonic_ extends UniffiEnum implements Mnemonic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Seed';
    readonly tag = Seed_Tags.Mnemonic;
    readonly inner: Readonly<{
      mnemonic: string;
      passphrase: string | undefined;
    }>;
    constructor(inner: {
      /**
       * The mnemonic phrase. 12 or 24 words.
       */ mnemonic: string;
      /**
       * An optional passphrase for the mnemonic.
       */ passphrase: string | undefined;
    }) {
      super('Seed', 'Mnemonic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The mnemonic phrase. 12 or 24 words.
       */ mnemonic: string;
      /**
       * An optional passphrase for the mnemonic.
       */ passphrase: string | undefined;
    }): Mnemonic_ {
      return new Mnemonic_(inner);
    }

    static instanceOf(obj: any): obj is Mnemonic_ {
      return obj.tag === Seed_Tags.Mnemonic;
    }
  }

  type Entropy__interface = {
    tag: Seed_Tags.Entropy;
    inner: Readonly<[ArrayBuffer]>;
  };

  /**
   * Raw entropy bytes.
   */
  class Entropy_ extends UniffiEnum implements Entropy__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Seed';
    readonly tag = Seed_Tags.Entropy;
    readonly inner: Readonly<[ArrayBuffer]>;
    constructor(v0: ArrayBuffer) {
      super('Seed', 'Entropy');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: ArrayBuffer): Entropy_ {
      return new Entropy_(v0);
    }

    static instanceOf(obj: any): obj is Entropy_ {
      return obj.tag === Seed_Tags.Entropy;
    }
  }

  function instanceOf(obj: any): obj is Seed {
    return obj[uniffiTypeNameSymbol] === 'Seed';
  }

  return Object.freeze({
    instanceOf,
    Mnemonic: Mnemonic_,
    Entropy: Entropy_,
  });
})();

/**
 * Represents the seed for wallet generation, either as a mnemonic phrase with an optional
 * passphrase or as raw entropy bytes.
 */

export type Seed = InstanceType<
  (typeof Seed)[keyof Omit<typeof Seed, 'instanceOf'>]
>;

// FfiConverter for enum Seed
const FfiConverterTypeSeed = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Seed;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Seed.Mnemonic({
            mnemonic: FfiConverterString.read(from),
            passphrase: FfiConverterOptionalString.read(from),
          });
        case 2:
          return new Seed.Entropy(FfiConverterArrayBuffer.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Seed_Tags.Mnemonic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.mnemonic, into);
          FfiConverterOptionalString.write(inner.passphrase, into);
          return;
        }
        case Seed_Tags.Entropy: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayBuffer.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that Seed_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Seed_Tags.Mnemonic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.mnemonic);
          size += FfiConverterOptionalString.allocationSize(inner.passphrase);
          return size;
        }
        case Seed_Tags.Entropy: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayBuffer.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SendPaymentMethod
export enum SendPaymentMethod_Tags {
  BitcoinAddress = 'BitcoinAddress',
  Bolt11Invoice = 'Bolt11Invoice',
  SparkAddress = 'SparkAddress',
}
export const SendPaymentMethod = (() => {
  type BitcoinAddress__interface = {
    tag: SendPaymentMethod_Tags.BitcoinAddress;
    inner: Readonly<{
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }>;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentMethod';
    readonly tag = SendPaymentMethod_Tags.BitcoinAddress;
    readonly inner: Readonly<{
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }>;
    constructor(inner: {
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }) {
      super('SendPaymentMethod', 'BitcoinAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }): BitcoinAddress_ {
      return new BitcoinAddress_(inner);
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === SendPaymentMethod_Tags.BitcoinAddress;
    }
  }

  type Bolt11Invoice__interface = {
    tag: SendPaymentMethod_Tags.Bolt11Invoice;
    inner: Readonly<{
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }>;
  };

  class Bolt11Invoice_ extends UniffiEnum implements Bolt11Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentMethod';
    readonly tag = SendPaymentMethod_Tags.Bolt11Invoice;
    readonly inner: Readonly<{
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }>;
    constructor(inner: {
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }) {
      super('SendPaymentMethod', 'Bolt11Invoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }): Bolt11Invoice_ {
      return new Bolt11Invoice_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11Invoice_ {
      return obj.tag === SendPaymentMethod_Tags.Bolt11Invoice;
    }
  }

  type SparkAddress__interface = {
    tag: SendPaymentMethod_Tags.SparkAddress;
    inner: Readonly<{
      address: string;
      fee: U128;
      tokenIdentifier: string | undefined;
    }>;
  };

  class SparkAddress_ extends UniffiEnum implements SparkAddress__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentMethod';
    readonly tag = SendPaymentMethod_Tags.SparkAddress;
    readonly inner: Readonly<{
      address: string;
      fee: U128;
      tokenIdentifier: string | undefined;
    }>;
    constructor(inner: {
      address: string;
      /**
       * Fee to pay for the transaction
       * Denominated in sats if token identifier is empty, otherwise in the token base units
       */ fee: U128;
      /**
       * The presence of this field indicates that the payment is for a token
       * If empty, it is a Bitcoin payment
       */ tokenIdentifier: string | undefined;
    }) {
      super('SendPaymentMethod', 'SparkAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      address: string;
      /**
       * Fee to pay for the transaction
       * Denominated in sats if token identifier is empty, otherwise in the token base units
       */ fee: U128;
      /**
       * The presence of this field indicates that the payment is for a token
       * If empty, it is a Bitcoin payment
       */ tokenIdentifier: string | undefined;
    }): SparkAddress_ {
      return new SparkAddress_(inner);
    }

    static instanceOf(obj: any): obj is SparkAddress_ {
      return obj.tag === SendPaymentMethod_Tags.SparkAddress;
    }
  }

  function instanceOf(obj: any): obj is SendPaymentMethod {
    return obj[uniffiTypeNameSymbol] === 'SendPaymentMethod';
  }

  return Object.freeze({
    instanceOf,
    BitcoinAddress: BitcoinAddress_,
    Bolt11Invoice: Bolt11Invoice_,
    SparkAddress: SparkAddress_,
  });
})();

export type SendPaymentMethod = InstanceType<
  (typeof SendPaymentMethod)[keyof Omit<typeof SendPaymentMethod, 'instanceOf'>]
>;

// FfiConverter for enum SendPaymentMethod
const FfiConverterTypeSendPaymentMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SendPaymentMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SendPaymentMethod.BitcoinAddress({
            address: FfiConverterTypeBitcoinAddressDetails.read(from),
            feeQuote: FfiConverterTypeSendOnchainFeeQuote.read(from),
          });
        case 2:
          return new SendPaymentMethod.Bolt11Invoice({
            invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.read(from),
            sparkTransferFeeSats: FfiConverterOptionalUInt64.read(from),
            lightningFeeSats: FfiConverterUInt64.read(from),
          });
        case 3:
          return new SendPaymentMethod.SparkAddress({
            address: FfiConverterString.read(from),
            fee: FfiConverterTypeu128.read(from),
            tokenIdentifier: FfiConverterOptionalString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SendPaymentMethod_Tags.BitcoinAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeBitcoinAddressDetails.write(inner.address, into);
          FfiConverterTypeSendOnchainFeeQuote.write(inner.feeQuote, into);
          return;
        }
        case SendPaymentMethod_Tags.Bolt11Invoice: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeBolt11InvoiceDetails.write(
            inner.invoiceDetails,
            into
          );
          FfiConverterOptionalUInt64.write(inner.sparkTransferFeeSats, into);
          FfiConverterUInt64.write(inner.lightningFeeSats, into);
          return;
        }
        case SendPaymentMethod_Tags.SparkAddress: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.address, into);
          FfiConverterTypeu128.write(inner.fee, into);
          FfiConverterOptionalString.write(inner.tokenIdentifier, into);
          return;
        }
        default:
          // Throwing from here means that SendPaymentMethod_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SendPaymentMethod_Tags.BitcoinAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeBitcoinAddressDetails.allocationSize(
            inner.address
          );
          size += FfiConverterTypeSendOnchainFeeQuote.allocationSize(
            inner.feeQuote
          );
          return size;
        }
        case SendPaymentMethod_Tags.Bolt11Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeBolt11InvoiceDetails.allocationSize(
            inner.invoiceDetails
          );
          size += FfiConverterOptionalUInt64.allocationSize(
            inner.sparkTransferFeeSats
          );
          size += FfiConverterUInt64.allocationSize(inner.lightningFeeSats);
          return size;
        }
        case SendPaymentMethod_Tags.SparkAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.address);
          size += FfiConverterTypeu128.allocationSize(inner.fee);
          size += FfiConverterOptionalString.allocationSize(
            inner.tokenIdentifier
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SendPaymentOptions
export enum SendPaymentOptions_Tags {
  BitcoinAddress = 'BitcoinAddress',
  Bolt11Invoice = 'Bolt11Invoice',
}
export const SendPaymentOptions = (() => {
  type BitcoinAddress__interface = {
    tag: SendPaymentOptions_Tags.BitcoinAddress;
    inner: Readonly<{ confirmationSpeed: OnchainConfirmationSpeed }>;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentOptions';
    readonly tag = SendPaymentOptions_Tags.BitcoinAddress;
    readonly inner: Readonly<{ confirmationSpeed: OnchainConfirmationSpeed }>;
    constructor(inner: { confirmationSpeed: OnchainConfirmationSpeed }) {
      super('SendPaymentOptions', 'BitcoinAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      confirmationSpeed: OnchainConfirmationSpeed;
    }): BitcoinAddress_ {
      return new BitcoinAddress_(inner);
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === SendPaymentOptions_Tags.BitcoinAddress;
    }
  }

  type Bolt11Invoice__interface = {
    tag: SendPaymentOptions_Tags.Bolt11Invoice;
    inner: Readonly<{
      preferSpark: boolean;
      completionTimeoutSecs: /*u32*/ number | undefined;
    }>;
  };

  class Bolt11Invoice_ extends UniffiEnum implements Bolt11Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentOptions';
    readonly tag = SendPaymentOptions_Tags.Bolt11Invoice;
    readonly inner: Readonly<{
      preferSpark: boolean;
      completionTimeoutSecs: /*u32*/ number | undefined;
    }>;
    constructor(inner: {
      preferSpark: boolean;
      /**
       * If set, the function will return the payment if it is still pending after this
       * number of seconds. If unset, the function will return immediately after initiating the payment.
       */ completionTimeoutSecs: /*u32*/ number | undefined;
    }) {
      super('SendPaymentOptions', 'Bolt11Invoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      preferSpark: boolean;
      /**
       * If set, the function will return the payment if it is still pending after this
       * number of seconds. If unset, the function will return immediately after initiating the payment.
       */ completionTimeoutSecs: /*u32*/ number | undefined;
    }): Bolt11Invoice_ {
      return new Bolt11Invoice_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11Invoice_ {
      return obj.tag === SendPaymentOptions_Tags.Bolt11Invoice;
    }
  }

  function instanceOf(obj: any): obj is SendPaymentOptions {
    return obj[uniffiTypeNameSymbol] === 'SendPaymentOptions';
  }

  return Object.freeze({
    instanceOf,
    BitcoinAddress: BitcoinAddress_,
    Bolt11Invoice: Bolt11Invoice_,
  });
})();

export type SendPaymentOptions = InstanceType<
  (typeof SendPaymentOptions)[keyof Omit<
    typeof SendPaymentOptions,
    'instanceOf'
  >]
>;

// FfiConverter for enum SendPaymentOptions
const FfiConverterTypeSendPaymentOptions = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SendPaymentOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SendPaymentOptions.BitcoinAddress({
            confirmationSpeed:
              FfiConverterTypeOnchainConfirmationSpeed.read(from),
          });
        case 2:
          return new SendPaymentOptions.Bolt11Invoice({
            preferSpark: FfiConverterBool.read(from),
            completionTimeoutSecs: FfiConverterOptionalUInt32.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SendPaymentOptions_Tags.BitcoinAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeOnchainConfirmationSpeed.write(
            inner.confirmationSpeed,
            into
          );
          return;
        }
        case SendPaymentOptions_Tags.Bolt11Invoice: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.preferSpark, into);
          FfiConverterOptionalUInt32.write(inner.completionTimeoutSecs, into);
          return;
        }
        default:
          // Throwing from here means that SendPaymentOptions_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SendPaymentOptions_Tags.BitcoinAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeOnchainConfirmationSpeed.allocationSize(
            inner.confirmationSpeed
          );
          return size;
        }
        case SendPaymentOptions_Tags.Bolt11Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterBool.allocationSize(inner.preferSpark);
          size += FfiConverterOptionalUInt32.allocationSize(
            inner.completionTimeoutSecs
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: StorageError

// Enum: StorageError
export enum StorageError_Tags {
  Implementation = 'Implementation',
  InitializationError = 'InitializationError',
  Serialization = 'Serialization',
}
/**
 * Errors that can occur during storage operations
 */
export const StorageError = (() => {
  type Implementation__interface = {
    tag: StorageError_Tags.Implementation;
    inner: Readonly<[string]>;
  };

  class Implementation_
    extends UniffiError
    implements Implementation__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StorageError';
    readonly tag = StorageError_Tags.Implementation;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('StorageError', 'Implementation');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Implementation_ {
      return new Implementation_(v0);
    }

    static instanceOf(obj: any): obj is Implementation_ {
      return obj.tag === StorageError_Tags.Implementation;
    }

    static hasInner(obj: any): obj is Implementation_ {
      return Implementation_.instanceOf(obj);
    }

    static getInner(obj: Implementation_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InitializationError__interface = {
    tag: StorageError_Tags.InitializationError;
    inner: Readonly<[string]>;
  };

  /**
   * Database initialization error
   */
  class InitializationError_
    extends UniffiError
    implements InitializationError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StorageError';
    readonly tag = StorageError_Tags.InitializationError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('StorageError', 'InitializationError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InitializationError_ {
      return new InitializationError_(v0);
    }

    static instanceOf(obj: any): obj is InitializationError_ {
      return obj.tag === StorageError_Tags.InitializationError;
    }

    static hasInner(obj: any): obj is InitializationError_ {
      return InitializationError_.instanceOf(obj);
    }

    static getInner(obj: InitializationError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Serialization__interface = {
    tag: StorageError_Tags.Serialization;
    inner: Readonly<[string]>;
  };

  class Serialization_ extends UniffiError implements Serialization__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StorageError';
    readonly tag = StorageError_Tags.Serialization;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('StorageError', 'Serialization');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Serialization_ {
      return new Serialization_(v0);
    }

    static instanceOf(obj: any): obj is Serialization_ {
      return obj.tag === StorageError_Tags.Serialization;
    }

    static hasInner(obj: any): obj is Serialization_ {
      return Serialization_.instanceOf(obj);
    }

    static getInner(obj: Serialization_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is StorageError {
    return obj[uniffiTypeNameSymbol] === 'StorageError';
  }

  return Object.freeze({
    instanceOf,
    Implementation: Implementation_,
    InitializationError: InitializationError_,
    Serialization: Serialization_,
  });
})();

/**
 * Errors that can occur during storage operations
 */

export type StorageError = InstanceType<
  (typeof StorageError)[keyof Omit<typeof StorageError, 'instanceOf'>]
>;

// FfiConverter for enum StorageError
const FfiConverterTypeStorageError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = StorageError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new StorageError.Implementation(FfiConverterString.read(from));
        case 2:
          return new StorageError.InitializationError(
            FfiConverterString.read(from)
          );
        case 3:
          return new StorageError.Serialization(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case StorageError_Tags.Implementation: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case StorageError_Tags.InitializationError: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case StorageError_Tags.Serialization: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that StorageError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case StorageError_Tags.Implementation: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case StorageError_Tags.InitializationError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case StorageError_Tags.Serialization: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: UpdateDepositPayload
export enum UpdateDepositPayload_Tags {
  ClaimError = 'ClaimError',
  Refund = 'Refund',
}
export const UpdateDepositPayload = (() => {
  type ClaimError__interface = {
    tag: UpdateDepositPayload_Tags.ClaimError;
    inner: Readonly<{ error: DepositClaimError }>;
  };

  class ClaimError_ extends UniffiEnum implements ClaimError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'UpdateDepositPayload';
    readonly tag = UpdateDepositPayload_Tags.ClaimError;
    readonly inner: Readonly<{ error: DepositClaimError }>;
    constructor(inner: { error: DepositClaimError }) {
      super('UpdateDepositPayload', 'ClaimError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: DepositClaimError }): ClaimError_ {
      return new ClaimError_(inner);
    }

    static instanceOf(obj: any): obj is ClaimError_ {
      return obj.tag === UpdateDepositPayload_Tags.ClaimError;
    }
  }

  type Refund__interface = {
    tag: UpdateDepositPayload_Tags.Refund;
    inner: Readonly<{ refundTxid: string; refundTx: string }>;
  };

  class Refund_ extends UniffiEnum implements Refund__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'UpdateDepositPayload';
    readonly tag = UpdateDepositPayload_Tags.Refund;
    readonly inner: Readonly<{ refundTxid: string; refundTx: string }>;
    constructor(inner: { refundTxid: string; refundTx: string }) {
      super('UpdateDepositPayload', 'Refund');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { refundTxid: string; refundTx: string }): Refund_ {
      return new Refund_(inner);
    }

    static instanceOf(obj: any): obj is Refund_ {
      return obj.tag === UpdateDepositPayload_Tags.Refund;
    }
  }

  function instanceOf(obj: any): obj is UpdateDepositPayload {
    return obj[uniffiTypeNameSymbol] === 'UpdateDepositPayload';
  }

  return Object.freeze({
    instanceOf,
    ClaimError: ClaimError_,
    Refund: Refund_,
  });
})();

export type UpdateDepositPayload = InstanceType<
  (typeof UpdateDepositPayload)[keyof Omit<
    typeof UpdateDepositPayload,
    'instanceOf'
  >]
>;

// FfiConverter for enum UpdateDepositPayload
const FfiConverterTypeUpdateDepositPayload = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = UpdateDepositPayload;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new UpdateDepositPayload.ClaimError({
            error: FfiConverterTypeDepositClaimError.read(from),
          });
        case 2:
          return new UpdateDepositPayload.Refund({
            refundTxid: FfiConverterString.read(from),
            refundTx: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case UpdateDepositPayload_Tags.ClaimError: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeDepositClaimError.write(inner.error, into);
          return;
        }
        case UpdateDepositPayload_Tags.Refund: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.refundTxid, into);
          FfiConverterString.write(inner.refundTx, into);
          return;
        }
        default:
          // Throwing from here means that UpdateDepositPayload_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case UpdateDepositPayload_Tags.ClaimError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeDepositClaimError.allocationSize(inner.error);
          return size;
        }
        case UpdateDepositPayload_Tags.Refund: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.refundTxid);
          size += FfiConverterString.allocationSize(inner.refundTx);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: WaitForPaymentIdentifier
export enum WaitForPaymentIdentifier_Tags {
  PaymentId = 'PaymentId',
  PaymentRequest = 'PaymentRequest',
}
export const WaitForPaymentIdentifier = (() => {
  type PaymentId__interface = {
    tag: WaitForPaymentIdentifier_Tags.PaymentId;
    inner: Readonly<[string]>;
  };

  class PaymentId_ extends UniffiEnum implements PaymentId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WaitForPaymentIdentifier';
    readonly tag = WaitForPaymentIdentifier_Tags.PaymentId;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('WaitForPaymentIdentifier', 'PaymentId');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): PaymentId_ {
      return new PaymentId_(v0);
    }

    static instanceOf(obj: any): obj is PaymentId_ {
      return obj.tag === WaitForPaymentIdentifier_Tags.PaymentId;
    }
  }

  type PaymentRequest__interface = {
    tag: WaitForPaymentIdentifier_Tags.PaymentRequest;
    inner: Readonly<[string]>;
  };

  class PaymentRequest_
    extends UniffiEnum
    implements PaymentRequest__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WaitForPaymentIdentifier';
    readonly tag = WaitForPaymentIdentifier_Tags.PaymentRequest;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('WaitForPaymentIdentifier', 'PaymentRequest');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): PaymentRequest_ {
      return new PaymentRequest_(v0);
    }

    static instanceOf(obj: any): obj is PaymentRequest_ {
      return obj.tag === WaitForPaymentIdentifier_Tags.PaymentRequest;
    }
  }

  function instanceOf(obj: any): obj is WaitForPaymentIdentifier {
    return obj[uniffiTypeNameSymbol] === 'WaitForPaymentIdentifier';
  }

  return Object.freeze({
    instanceOf,
    PaymentId: PaymentId_,
    PaymentRequest: PaymentRequest_,
  });
})();

export type WaitForPaymentIdentifier = InstanceType<
  (typeof WaitForPaymentIdentifier)[keyof Omit<
    typeof WaitForPaymentIdentifier,
    'instanceOf'
  >]
>;

// FfiConverter for enum WaitForPaymentIdentifier
const FfiConverterTypeWaitForPaymentIdentifier = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = WaitForPaymentIdentifier;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new WaitForPaymentIdentifier.PaymentId(
            FfiConverterString.read(from)
          );
        case 2:
          return new WaitForPaymentIdentifier.PaymentRequest(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case WaitForPaymentIdentifier_Tags.PaymentId: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case WaitForPaymentIdentifier_Tags.PaymentRequest: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that WaitForPaymentIdentifier_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case WaitForPaymentIdentifier_Tags.PaymentId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case WaitForPaymentIdentifier_Tags.PaymentRequest: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<string, TokenBalance>
const FfiConverterMapStringTypeTokenBalance = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeTokenBalance
);

export interface BitcoinChainService {
  getAddressUtxos(
    address: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Array<Utxo>>;
  getTransactionStatus(
    txid: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TxStatus>;
  getTransactionHex(
    txid: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  broadcastTransaction(
    tx: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

export class BitcoinChainServiceImpl
  extends UniffiAbstractObject
  implements BitcoinChainService
{
  readonly [uniffiTypeNameSymbol] = 'BitcoinChainServiceImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeBitcoinChainServiceImplObjectFactory.bless(pointer);
  }

  public async getAddressUtxos(
    address: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<Utxo>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(address)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeUtxo.lift.bind(
          FfiConverterArrayTypeUtxo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getTransactionStatus(
    txid: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TxStatus> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeTxStatus.lift.bind(
          FfiConverterTypeTxStatus
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getTransactionHex(
    txid: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async broadcastTransaction(
    tx: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(tx)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeBitcoinChainServiceImplObjectFactory.pointer(this);
      uniffiTypeBitcoinChainServiceImplObjectFactory.freePointer(pointer);
      uniffiTypeBitcoinChainServiceImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is BitcoinChainServiceImpl {
    return uniffiTypeBitcoinChainServiceImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeBitcoinChainServiceImplObjectFactory: UniffiObjectFactory<BitcoinChainService> =
  {
    create(pointer: UnsafeMutableRawPointer): BitcoinChainService {
      const instance = Object.create(BitcoinChainServiceImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'BitcoinChainServiceImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_bitcoinchainservice_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: BitcoinChainService): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: BitcoinChainService): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is BitcoinChainService {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'BitcoinChainServiceImpl'
      );
    },
  };
// FfiConverter for BitcoinChainService
const FfiConverterTypeBitcoinChainService = new FfiConverterObjectWithCallbacks(
  uniffiTypeBitcoinChainServiceImplObjectFactory
);

// Add a vtavble for the callbacks that go in BitcoinChainService.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceBitcoinChainService: {
  vtable: UniffiVTableCallbackInterfaceBitcoinChainService;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    getAddressUtxos: (
      uniffiHandle: bigint,
      address: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<Utxo>> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.getAddressUtxos(
          FfiConverterString.lift(address),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: Array<Utxo>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypeUtxo.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getTransactionStatus: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<TxStatus> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.getTransactionStatus(
          FfiConverterString.lift(txid),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: TxStatus) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterTypeTxStatus.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getTransactionHex: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<string> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.getTransactionHex(
          FfiConverterString.lift(txid),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: string) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterString.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    broadcastTransaction: (
      uniffiHandle: bigint,
      tx: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.broadcastTransaction(
          FfiConverterString.lift(tx),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // BitcoinChainService: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeBitcoinChainService.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(
      uniffiCallbackInterfaceBitcoinChainService.vtable
    );
  },
};

/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
export interface BreezSdkInterface {
  /**
   * Registers a listener to receive SDK events
   *
   * # Arguments
   *
   * * `listener` - An implementation of the `EventListener` trait
   *
   * # Returns
   *
   * A unique identifier for the listener, which can be used to remove it later
   */
  addEventListener(
    listener: EventListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string>;
  checkLightningAddressAvailable(
    req: CheckLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  claimDeposit(
    request: ClaimDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ClaimDepositResponse>;
  deleteLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Stops the SDK's background tasks
   *
   * This method stops the background tasks started by the `start()` method.
   * It should be called before your application terminates to ensure proper cleanup.
   *
   * # Returns
   *
   * Result containing either success or an `SdkError` if the background task couldn't be stopped
   */
  disconnect(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Returns the balance of the wallet in satoshis
   */
  getInfo(
    request: GetInfoRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<GetInfoResponse>;
  getLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<LightningAddressInfo | undefined>;
  getPayment(
    request: GetPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<GetPaymentResponse>;
  /**
   * Returns the metadata for the given token identifiers.
   *
   * Results are not guaranteed to be in the same order as the input token identifiers.
   *
   * If the metadata is not found locally in cache, it will be queried from
   * the Spark network and then cached.
   */
  getTokensMetadata(
    request: GetTokensMetadataRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<GetTokensMetadataResponse>;
  /**
   * List fiat currencies for which there is a known exchange rate,
   * sorted by the canonical name of the currency.
   */
  listFiatCurrencies(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<ListFiatCurrenciesResponse>;
  /**
   * List the latest rates of fiat currencies, sorted by name.
   */
  listFiatRates(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<ListFiatRatesResponse>;
  /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
  listPayments(
    request: ListPaymentsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ListPaymentsResponse>;
  listUnclaimedDeposits(
    request: ListUnclaimedDepositsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ListUnclaimedDepositsResponse>;
  lnurlPay(
    request: LnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<LnurlPayResponse>;
  parse(
    input: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<InputType>;
  prepareLnurlPay(
    request: PrepareLnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<PrepareLnurlPayResponse>;
  prepareSendPayment(
    request: PrepareSendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<PrepareSendPaymentResponse>;
  receivePayment(
    request: ReceivePaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ReceivePaymentResponse>;
  refundDeposit(
    request: RefundDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RefundDepositResponse>;
  registerLightningAddress(
    request: RegisterLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<LightningAddressInfo>;
  /**
   * Removes a previously registered event listener
   *
   * # Arguments
   *
   * * `id` - The listener ID returned from `add_event_listener`
   *
   * # Returns
   *
   * `true` if the listener was found and removed, `false` otherwise
   */
  removeEventListener(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean>;
  sendPayment(
    request: SendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendPaymentResponse>;
  /**
   * Synchronizes the wallet with the Spark network
   */
  syncWallet(
    request: SyncWalletRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SyncWalletResponse>;
  waitForPayment(
    request: WaitForPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<WaitForPaymentResponse>;
}

/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
export class BreezSdk
  extends UniffiAbstractObject
  implements BreezSdkInterface
{
  readonly [uniffiTypeNameSymbol] = 'BreezSdk';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeBreezSdkObjectFactory.bless(pointer);
  }

  /**
   * Registers a listener to receive SDK events
   *
   * # Arguments
   *
   * * `listener` - An implementation of the `EventListener` trait
   *
   * # Returns
   *
   * A unique identifier for the listener, which can be used to remove it later
   */
  public async addEventListener(
    listener: EventListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeEventListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async checkLightningAddressAvailable(
    req: CheckLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeCheckLightningAddressRequest.lower(req)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async claimDeposit(
    request: ClaimDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ClaimDepositResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeClaimDepositRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeClaimDepositResponse.lift.bind(
          FfiConverterTypeClaimDepositResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async deleteLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Stops the SDK's background tasks
   *
   * This method stops the background tasks started by the `start()` method.
   * It should be called before your application terminates to ensure proper cleanup.
   *
   * # Returns
   *
   * Result containing either success or an `SdkError` if the background task couldn't be stopped
   */
  public async disconnect(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the balance of the wallet in satoshis
   */
  public async getInfo(
    request: GetInfoRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<GetInfoResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeGetInfoRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeGetInfoResponse.lift.bind(
          FfiConverterTypeGetInfoResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<LightningAddressInfo | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeLightningAddressInfo.lift.bind(
          FfiConverterOptionalTypeLightningAddressInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getPayment(
    request: GetPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<GetPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeGetPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeGetPaymentResponse.lift.bind(
          FfiConverterTypeGetPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the metadata for the given token identifiers.
   *
   * Results are not guaranteed to be in the same order as the input token identifiers.
   *
   * If the metadata is not found locally in cache, it will be queried from
   * the Spark network and then cached.
   */
  public async getTokensMetadata(
    request: GetTokensMetadataRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<GetTokensMetadataResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeGetTokensMetadataRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeGetTokensMetadataResponse.lift.bind(
          FfiConverterTypeGetTokensMetadataResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * List fiat currencies for which there is a known exchange rate,
   * sorted by the canonical name of the currency.
   */
  public async listFiatCurrencies(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<ListFiatCurrenciesResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeListFiatCurrenciesResponse.lift.bind(
          FfiConverterTypeListFiatCurrenciesResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * List the latest rates of fiat currencies, sorted by name.
   */
  public async listFiatRates(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<ListFiatRatesResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeListFiatRatesResponse.lift.bind(
          FfiConverterTypeListFiatRatesResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
  public async listPayments(
    request: ListPaymentsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ListPaymentsResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeListPaymentsRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeListPaymentsResponse.lift.bind(
          FfiConverterTypeListPaymentsResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async listUnclaimedDeposits(
    request: ListUnclaimedDepositsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ListUnclaimedDepositsResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeListUnclaimedDepositsRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeListUnclaimedDepositsResponse.lift.bind(
          FfiConverterTypeListUnclaimedDepositsResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async lnurlPay(
    request: LnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<LnurlPayResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeLnurlPayRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeLnurlPayResponse.lift.bind(
          FfiConverterTypeLnurlPayResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async parse(
    input: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<InputType> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_parse(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterString.lower(input)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeInputType.lift.bind(
          FfiConverterTypeInputType
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async prepareLnurlPay(
    request: PrepareLnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<PrepareLnurlPayResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareLnurlPayRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePrepareLnurlPayResponse.lift.bind(
          FfiConverterTypePrepareLnurlPayResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async prepareSendPayment(
    request: PrepareSendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<PrepareSendPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareSendPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePrepareSendPaymentResponse.lift.bind(
          FfiConverterTypePrepareSendPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async receivePayment(
    request: ReceivePaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ReceivePaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeReceivePaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeReceivePaymentResponse.lift.bind(
          FfiConverterTypeReceivePaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async refundDeposit(
    request: RefundDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RefundDepositResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeRefundDepositRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRefundDepositResponse.lift.bind(
          FfiConverterTypeRefundDepositResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async registerLightningAddress(
    request: RegisterLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<LightningAddressInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeRegisterLightningAddressRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeLightningAddressInfo.lift.bind(
          FfiConverterTypeLightningAddressInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Removes a previously registered event listener
   *
   * # Arguments
   *
   * * `id` - The listener ID returned from `add_event_listener`
   *
   * # Returns
   *
   * `true` if the listener was found and removed, `false` otherwise
   */
  public async removeEventListener(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterString.lower(id)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async sendPayment(
    request: SendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeSendPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendPaymentResponse.lift.bind(
          FfiConverterTypeSendPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Synchronizes the wallet with the Spark network
   */
  public async syncWallet(
    request: SyncWalletRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SyncWalletResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeSyncWalletRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSyncWalletResponse.lift.bind(
          FfiConverterTypeSyncWalletResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async waitForPayment(
    request: WaitForPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<WaitForPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_wait_for_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeWaitForPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeWaitForPaymentResponse.lift.bind(
          FfiConverterTypeWaitForPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeBreezSdkObjectFactory.pointer(this);
      uniffiTypeBreezSdkObjectFactory.freePointer(pointer);
      uniffiTypeBreezSdkObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is BreezSdk {
    return uniffiTypeBreezSdkObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeBreezSdkObjectFactory: UniffiObjectFactory<BreezSdkInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): BreezSdkInterface {
      const instance = Object.create(BreezSdk.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'BreezSdk';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_breezsdk_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: BreezSdkInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: BreezSdkInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_breezsdk(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_breezsdk(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is BreezSdkInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'BreezSdk'
      );
    },
  };
// FfiConverter for BreezSdkInterface
const FfiConverterTypeBreezSdk = new FfiConverterObject(
  uniffiTypeBreezSdkObjectFactory
);

/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */
export interface PaymentObserver {
  /**
   * Called before Lightning, Spark or onchain Bitcoin payments are made
   */
  beforeSend(
    payments: Array<ProvisionalPayment>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */
export class PaymentObserverImpl
  extends UniffiAbstractObject
  implements PaymentObserver
{
  readonly [uniffiTypeNameSymbol] = 'PaymentObserverImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypePaymentObserverImplObjectFactory.bless(pointer);
  }

  /**
   * Called before Lightning, Spark or onchain Bitcoin payments are made
   */
  public async beforeSend(
    payments: Array<ProvisionalPayment>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(
            uniffiTypePaymentObserverImplObjectFactory.clonePointer(this),
            FfiConverterArrayTypeProvisionalPayment.lower(payments)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypePaymentObserverError.lift.bind(
          FfiConverterTypePaymentObserverError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypePaymentObserverImplObjectFactory.pointer(this);
      uniffiTypePaymentObserverImplObjectFactory.freePointer(pointer);
      uniffiTypePaymentObserverImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is PaymentObserverImpl {
    return uniffiTypePaymentObserverImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypePaymentObserverImplObjectFactory: UniffiObjectFactory<PaymentObserver> =
  {
    create(pointer: UnsafeMutableRawPointer): PaymentObserver {
      const instance = Object.create(PaymentObserverImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'PaymentObserverImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_paymentobserver_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: PaymentObserver): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: PaymentObserver): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_paymentobserver(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_paymentobserver(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is PaymentObserver {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'PaymentObserverImpl'
      );
    },
  };
// FfiConverter for PaymentObserver
const FfiConverterTypePaymentObserver = new FfiConverterObjectWithCallbacks(
  uniffiTypePaymentObserverImplObjectFactory
);

// Add a vtavble for the callbacks that go in PaymentObserver.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePaymentObserver: {
  vtable: UniffiVTableCallbackInterfacePaymentObserver;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    beforeSend: (
      uniffiHandle: bigint,
      payments: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypePaymentObserver.lift(uniffiHandle);
        return await jsCallback.beforeSend(
          FfiConverterArrayTypeProvisionalPayment.lift(payments),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ PaymentObserverError.instanceOf,
        /*lowerError:*/ FfiConverterTypePaymentObserverError.lower.bind(
          FfiConverterTypePaymentObserverError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // PaymentObserver: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypePaymentObserver.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(
      uniffiCallbackInterfacePaymentObserver.vtable
    );
  },
};

/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
export interface SdkBuilderInterface {
  /**
   * Builds the `BreezSdk` instance with the configured components.
   */
  build(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<BreezSdkInterface>;
  /**
   * Sets the chain service to be used by the SDK.
   * Arguments:
   * - `chain_service`: The chain service to be used.
   */
  withChainService(
    chainService: BitcoinChainService,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the fiat service to be used by the SDK.
   * Arguments:
   * - `fiat_service`: The fiat service to be used.
   */
  withFiatService(
    fiatService: FiatService,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the key set type to be used by the SDK.
   * Arguments:
   * - `key_set_type`: The key set type which determines the derivation path.
   * - `use_address_index`: Controls the structure of the BIP derivation path.
   */
  withKeySet(
    keySetType: KeySetType,
    useAddressIndex: boolean,
    accountNumber: /*u32*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  withLnurlClient(
    lnurlClient: RestClient,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the payment observer to be used by the SDK.
   * Arguments:
   * - `payment_observer`: The payment observer to be used.
   */
  withPaymentObserver(
    paymentObserver: PaymentObserver,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the REST chain service to be used by the SDK.
   * Arguments:
   * - `url`: The base URL of the REST API.
   * - `credentials`: Optional credentials for basic authentication.
   */
  withRestChainService(
    url: string,
    credentials: Credentials | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
}

/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
export class SdkBuilder
  extends UniffiAbstractObject
  implements SdkBuilderInterface
{
  readonly [uniffiTypeNameSymbol] = 'SdkBuilder';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Creates a new `SdkBuilder` with the provided configuration.
   * Arguments:
   * - `config`: The configuration to be used.
   * - `seed`: The seed for wallet generation.
   * - `storage`: The storage backend to be used.
   */
  constructor(config: Config, seed: Seed, storage: Storage) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
          FfiConverterTypeConfig.lower(config),
          FfiConverterTypeSeed.lower(seed),
          FfiConverterTypeStorage.lower(storage),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSdkBuilderObjectFactory.bless(pointer);
  }

  /**
   * Builds the `BreezSdk` instance with the configured components.
   */
  public async build(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<BreezSdkInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeBreezSdk.lift.bind(
          FfiConverterTypeBreezSdk
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the chain service to be used by the SDK.
   * Arguments:
   * - `chain_service`: The chain service to be used.
   */
  public async withChainService(
    chainService: BitcoinChainService,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeBitcoinChainService.lower(chainService)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the fiat service to be used by the SDK.
   * Arguments:
   * - `fiat_service`: The fiat service to be used.
   */
  public async withFiatService(
    fiatService: FiatService,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeFiatService.lower(fiatService)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the key set type to be used by the SDK.
   * Arguments:
   * - `key_set_type`: The key set type which determines the derivation path.
   * - `use_address_index`: Controls the structure of the BIP derivation path.
   */
  public async withKeySet(
    keySetType: KeySetType,
    useAddressIndex: boolean,
    accountNumber: /*u32*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeKeySetType.lower(keySetType),
            FfiConverterBool.lower(useAddressIndex),
            FfiConverterOptionalUInt32.lower(accountNumber)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async withLnurlClient(
    lnurlClient: RestClient,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeRestClient.lower(lnurlClient)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the payment observer to be used by the SDK.
   * Arguments:
   * - `payment_observer`: The payment observer to be used.
   */
  public async withPaymentObserver(
    paymentObserver: PaymentObserver,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypePaymentObserver.lower(paymentObserver)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the REST chain service to be used by the SDK.
   * Arguments:
   * - `url`: The base URL of the REST API.
   * - `credentials`: Optional credentials for basic authentication.
   */
  public async withRestChainService(
    url: string,
    credentials: Credentials | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterOptionalTypeCredentials.lower(credentials)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSdkBuilderObjectFactory.pointer(this);
      uniffiTypeSdkBuilderObjectFactory.freePointer(pointer);
      uniffiTypeSdkBuilderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SdkBuilder {
    return uniffiTypeSdkBuilderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSdkBuilderObjectFactory: UniffiObjectFactory<SdkBuilderInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SdkBuilderInterface {
      const instance = Object.create(SdkBuilder.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SdkBuilder';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sdkbuilder_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SdkBuilderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SdkBuilderInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_sdkbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_sdkbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SdkBuilderInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'SdkBuilder'
      );
    },
  };
// FfiConverter for SdkBuilderInterface
const FfiConverterTypeSdkBuilder = new FfiConverterObject(
  uniffiTypeSdkBuilderObjectFactory
);

/**
 * Trait for persistent storage
 */
export interface Storage {
  deleteCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  getCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  setCachedItem(
    key: string,
    value: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Lists payments with optional filters and pagination
   *
   * # Arguments
   *
   * * `list_payments_request` - The request to list payments
   *
   * # Returns
   *
   * A vector of payments or a `StorageError`
   */
  listPayments(
    request: ListPaymentsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Array<Payment>>;
  /**
   * Inserts a payment into storage
   *
   * # Arguments
   *
   * * `payment` - The payment to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  insertPayment(
    payment: Payment,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Inserts payment metadata into storage
   *
   * # Arguments
   *
   * * `payment_id` - The ID of the payment
   * * `metadata` - The metadata to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  setPaymentMetadata(
    paymentId: string,
    metadata: PaymentMetadata,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Gets a payment by its ID
   * # Arguments
   *
   * * `id` - The ID of the payment to retrieve
   *
   * # Returns
   *
   * The payment if found or None if not found
   */
  getPaymentById(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Payment>;
  /**
   * Gets a payment by its invoice
   * # Arguments
   *
   * * `invoice` - The invoice of the payment to retrieve
   * # Returns
   *
   * The payment if found or None if not found
   */
  getPaymentByInvoice(
    invoice: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Payment | undefined>;
  /**
   * Add a deposit to storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `amount_sats` - The amount of the deposit in sats
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  addDeposit(
    txid: string,
    vout: /*u32*/ number,
    amountSats: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Removes an unclaimed deposit from storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  deleteDeposit(
    txid: string,
    vout: /*u32*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Lists all unclaimed deposits from storage
   * # Returns
   *
   * A vector of `DepositInfo` or a `StorageError`
   */
  listDeposits(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<DepositInfo>>;
  /**
   * Updates or inserts unclaimed deposit details
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `payload` - The payload for the update
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  updateDeposit(
    txid: string,
    vout: /*u32*/ number,
    payload: UpdateDepositPayload,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

/**
 * Trait for persistent storage
 */
export class StorageImpl extends UniffiAbstractObject implements Storage {
  readonly [uniffiTypeNameSymbol] = 'StorageImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeStorageImplObjectFactory.bless(pointer);
  }

  public async deleteCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async setCachedItem(
    key: string,
    value: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterString.lower(value)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Lists payments with optional filters and pagination
   *
   * # Arguments
   *
   * * `list_payments_request` - The request to list payments
   *
   * # Returns
   *
   * A vector of payments or a `StorageError`
   */
  public async listPayments(
    request: ListPaymentsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<Payment>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_payments(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterTypeListPaymentsRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypePayment.lift.bind(
          FfiConverterArrayTypePayment
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Inserts a payment into storage
   *
   * # Arguments
   *
   * * `payment` - The payment to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async insertPayment(
    payment: Payment,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterTypePayment.lower(payment)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Inserts payment metadata into storage
   *
   * # Arguments
   *
   * * `payment_id` - The ID of the payment
   * * `metadata` - The metadata to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async setPaymentMetadata(
    paymentId: string,
    metadata: PaymentMetadata,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(paymentId),
            FfiConverterTypePaymentMetadata.lower(metadata)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Gets a payment by its ID
   * # Arguments
   *
   * * `id` - The ID of the payment to retrieve
   *
   * # Returns
   *
   * The payment if found or None if not found
   */
  public async getPaymentById(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Payment> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(id)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePayment.lift.bind(
          FfiConverterTypePayment
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Gets a payment by its invoice
   * # Arguments
   *
   * * `invoice` - The invoice of the payment to retrieve
   * # Returns
   *
   * The payment if found or None if not found
   */
  public async getPaymentByInvoice(
    invoice: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Payment | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(invoice)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypePayment.lift.bind(
          FfiConverterOptionalTypePayment
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Add a deposit to storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `amount_sats` - The amount of the deposit in sats
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async addDeposit(
    txid: string,
    vout: /*u32*/ number,
    amountSats: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid),
            FfiConverterUInt32.lower(vout),
            FfiConverterUInt64.lower(amountSats)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Removes an unclaimed deposit from storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async deleteDeposit(
    txid: string,
    vout: /*u32*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid),
            FfiConverterUInt32.lower(vout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Lists all unclaimed deposits from storage
   * # Returns
   *
   * A vector of `DepositInfo` or a `StorageError`
   */
  public async listDeposits(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<DepositInfo>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
            uniffiTypeStorageImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeDepositInfo.lift.bind(
          FfiConverterArrayTypeDepositInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Updates or inserts unclaimed deposit details
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `payload` - The payload for the update
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async updateDeposit(
    txid: string,
    vout: /*u32*/ number,
    payload: UpdateDepositPayload,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid),
            FfiConverterUInt32.lower(vout),
            FfiConverterTypeUpdateDepositPayload.lower(payload)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeStorageImplObjectFactory.pointer(this);
      uniffiTypeStorageImplObjectFactory.freePointer(pointer);
      uniffiTypeStorageImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is StorageImpl {
    return uniffiTypeStorageImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeStorageImplObjectFactory: UniffiObjectFactory<Storage> = {
  create(pointer: UnsafeMutableRawPointer): Storage {
    const instance = Object.create(StorageImpl.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'StorageImpl';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_storage_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: Storage): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: Storage): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_storage(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_storage(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is Storage {
    return (
      obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'StorageImpl'
    );
  },
};
// FfiConverter for Storage
const FfiConverterTypeStorage = new FfiConverterObjectWithCallbacks(
  uniffiTypeStorageImplObjectFactory
);

// Add a vtavble for the callbacks that go in Storage.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceStorage: {
  vtable: UniffiVTableCallbackInterfaceStorage;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    deleteCachedItem: (
      uniffiHandle: bigint,
      key: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.deleteCachedItem(FfiConverterString.lift(key), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getCachedItem: (
      uniffiHandle: bigint,
      key: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<string | undefined> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.getCachedItem(FfiConverterString.lift(key), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: string | undefined) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterOptionalString.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    setCachedItem: (
      uniffiHandle: bigint,
      key: Uint8Array,
      value: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.setCachedItem(
          FfiConverterString.lift(key),
          FfiConverterString.lift(value),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    listPayments: (
      uniffiHandle: bigint,
      request: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<Payment>> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.listPayments(
          FfiConverterTypeListPaymentsRequest.lift(request),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: Array<Payment>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypePayment.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    insertPayment: (
      uniffiHandle: bigint,
      payment: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.insertPayment(
          FfiConverterTypePayment.lift(payment),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    setPaymentMetadata: (
      uniffiHandle: bigint,
      paymentId: Uint8Array,
      metadata: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.setPaymentMetadata(
          FfiConverterString.lift(paymentId),
          FfiConverterTypePaymentMetadata.lift(metadata),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getPaymentById: (
      uniffiHandle: bigint,
      id: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<Payment> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.getPaymentById(FfiConverterString.lift(id), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: Payment) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterTypePayment.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getPaymentByInvoice: (
      uniffiHandle: bigint,
      invoice: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Payment | undefined> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.getPaymentByInvoice(
          FfiConverterString.lift(invoice),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: Payment | undefined) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterOptionalTypePayment.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    addDeposit: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      vout: number,
      amountSats: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.addDeposit(
          FfiConverterString.lift(txid),
          FfiConverterUInt32.lift(vout),
          FfiConverterUInt64.lift(amountSats),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    deleteDeposit: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      vout: number,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.deleteDeposit(
          FfiConverterString.lift(txid),
          FfiConverterUInt32.lift(vout),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    listDeposits: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<DepositInfo>> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.listDeposits({ signal });
      };
      const uniffiHandleSuccess = (returnValue: Array<DepositInfo>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypeDepositInfo.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    updateDeposit: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      vout: number,
      payload: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.updateDeposit(
          FfiConverterString.lift(txid),
          FfiConverterUInt32.lift(vout),
          FfiConverterTypeUpdateDepositPayload.lift(payload),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Storage: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeStorage.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(
      uniffiCallbackInterfaceStorage.vtable
    );
  },
};

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for Logger | undefined
const FfiConverterOptionalTypeLogger = new FfiConverterOptional(
  FfiConverterTypeLogger
);

// FfiConverter for SuccessAction | undefined
const FfiConverterOptionalTypeSuccessAction = new FfiConverterOptional(
  FfiConverterTypeSuccessAction
);

// FfiConverter for SuccessActionProcessed | undefined
const FfiConverterOptionalTypeSuccessActionProcessed = new FfiConverterOptional(
  FfiConverterTypeSuccessActionProcessed
);

// FfiConverter for Credentials | undefined
const FfiConverterOptionalTypeCredentials = new FfiConverterOptional(
  FfiConverterTypeCredentials
);

// FfiConverter for LightningAddressInfo | undefined
const FfiConverterOptionalTypeLightningAddressInfo = new FfiConverterOptional(
  FfiConverterTypeLightningAddressInfo
);

// FfiConverter for LnurlPayInfo | undefined
const FfiConverterOptionalTypeLnurlPayInfo = new FfiConverterOptional(
  FfiConverterTypeLnurlPayInfo
);

// FfiConverter for Payment | undefined
const FfiConverterOptionalTypePayment = new FfiConverterOptional(
  FfiConverterTypePayment
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for Array<ExternalInputParser>
const FfiConverterArrayTypeExternalInputParser = new FfiConverterArray(
  FfiConverterTypeExternalInputParser
);

// FfiConverter for Array<FiatCurrency>
const FfiConverterArrayTypeFiatCurrency = new FfiConverterArray(
  FfiConverterTypeFiatCurrency
);

// FfiConverter for Array<Rate>
const FfiConverterArrayTypeRate = new FfiConverterArray(FfiConverterTypeRate);

// FfiConverter for Array<DepositInfo>
const FfiConverterArrayTypeDepositInfo = new FfiConverterArray(
  FfiConverterTypeDepositInfo
);

// FfiConverter for Array<Payment>
const FfiConverterArrayTypePayment = new FfiConverterArray(
  FfiConverterTypePayment
);

// FfiConverter for Array<ProvisionalPayment>
const FfiConverterArrayTypeProvisionalPayment = new FfiConverterArray(
  FfiConverterTypeProvisionalPayment
);

// FfiConverter for Array<TokenMetadata>
const FfiConverterArrayTypeTokenMetadata = new FfiConverterArray(
  FfiConverterTypeTokenMetadata
);

// FfiConverter for Array<Utxo>
const FfiConverterArrayTypeUtxo = new FfiConverterArray(FfiConverterTypeUtxo);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for U128 | undefined
const FfiConverterOptionalTypeu128 = new FfiConverterOptional(
  FfiConverterTypeu128
);

// FfiConverter for AssetFilter | undefined
const FfiConverterOptionalTypeAssetFilter = new FfiConverterOptional(
  FfiConverterTypeAssetFilter
);

// FfiConverter for DepositClaimError | undefined
const FfiConverterOptionalTypeDepositClaimError = new FfiConverterOptional(
  FfiConverterTypeDepositClaimError
);

// FfiConverter for Fee | undefined
const FfiConverterOptionalTypeFee = new FfiConverterOptional(
  FfiConverterTypeFee
);

// FfiConverter for PaymentDetails | undefined
const FfiConverterOptionalTypePaymentDetails = new FfiConverterOptional(
  FfiConverterTypePaymentDetails
);

// FfiConverter for SendPaymentOptions | undefined
const FfiConverterOptionalTypeSendPaymentOptions = new FfiConverterOptional(
  FfiConverterTypeSendPaymentOptions
);

// FfiConverter for Array<ExternalInputParser> | undefined
const FfiConverterOptionalArrayTypeExternalInputParser =
  new FfiConverterOptional(FfiConverterArrayTypeExternalInputParser);

// FfiConverter for Array<PaymentStatus>
const FfiConverterArrayTypePaymentStatus = new FfiConverterArray(
  FfiConverterTypePaymentStatus
);

// FfiConverter for Array<PaymentType>
const FfiConverterArrayTypePaymentType = new FfiConverterArray(
  FfiConverterTypePaymentType
);

// FfiConverter for Array<PaymentStatus> | undefined
const FfiConverterOptionalArrayTypePaymentStatus = new FfiConverterOptional(
  FfiConverterArrayTypePaymentStatus
);

// FfiConverter for Array<PaymentType> | undefined
const FfiConverterOptionalArrayTypePaymentType = new FfiConverterOptional(
  FfiConverterArrayTypePaymentType
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 26;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_breez_sdk_spark_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_connect() !== 40345
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_default_config() !==
    62194
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_default_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_default_storage() !==
    46285
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_default_storage'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_init_logging() !==
    8518
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_init_logging'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos() !==
    20959
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status() !==
    23018
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex() !==
    59376
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction() !==
    65179
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener() !==
    37737
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available() !==
    31624
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit() !==
    43529
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address() !==
    44132
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect() !==
    330
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info() !==
    6771
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address() !==
    36552
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment() !==
    11540
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata() !==
    40125
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies() !==
    63366
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates() !==
    5904
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments() !==
    16156
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits() !==
    22486
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay() !==
    10147
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_parse() !==
    195
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay() !==
    37691
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment() !==
    34185
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment() !==
    36984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit() !==
    33646
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address() !==
    530
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener() !==
    41066
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment() !==
    54349
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet() !==
    30368
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_wait_for_payment() !==
    64922
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_wait_for_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send() !==
    30686
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build() !==
    8126
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service() !==
    2848
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service() !==
    41113
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set() !==
    42926
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client() !==
    61720
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer() !==
    21617
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service() !==
    56288
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item() !==
    6883
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item() !==
    30248
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item() !==
    7970
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_list_payments() !==
    19728
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_list_payments'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_insert_payment() !==
    28075
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_insert_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata() !==
    45500
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id() !==
    35394
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice() !==
    57075
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_add_deposit() !==
    60240
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_add_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit() !==
    60586
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_list_deposits() !==
    54118
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_list_deposits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_update_deposit() !==
    39803
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_update_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new() !==
    53882
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event() !==
    24807
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_logger_log() !==
    11839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_logger_log'
    );
  }

  uniffiCallbackInterfaceEventListener.register();
  uniffiCallbackInterfaceLogger.register();
  uniffiCallbackInterfaceBitcoinChainService.register();
  uniffiCallbackInterfacePaymentObserver.register();
  uniffiCallbackInterfaceStorage.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAssetFilter,
    FfiConverterTypeBitcoinChainService,
    FfiConverterTypeBreezSdk,
    FfiConverterTypeCheckLightningAddressRequest,
    FfiConverterTypeClaimDepositRequest,
    FfiConverterTypeClaimDepositResponse,
    FfiConverterTypeConfig,
    FfiConverterTypeConnectRequest,
    FfiConverterTypeCredentials,
    FfiConverterTypeDepositClaimError,
    FfiConverterTypeDepositInfo,
    FfiConverterTypeFee,
    FfiConverterTypeGetInfoRequest,
    FfiConverterTypeGetInfoResponse,
    FfiConverterTypeGetPaymentRequest,
    FfiConverterTypeGetPaymentResponse,
    FfiConverterTypeGetTokensMetadataRequest,
    FfiConverterTypeGetTokensMetadataResponse,
    FfiConverterTypeKeySetType,
    FfiConverterTypeLightningAddressInfo,
    FfiConverterTypeListFiatCurrenciesResponse,
    FfiConverterTypeListFiatRatesResponse,
    FfiConverterTypeListPaymentsRequest,
    FfiConverterTypeListPaymentsResponse,
    FfiConverterTypeListUnclaimedDepositsRequest,
    FfiConverterTypeListUnclaimedDepositsResponse,
    FfiConverterTypeLnurlPayInfo,
    FfiConverterTypeLnurlPayRequest,
    FfiConverterTypeLnurlPayResponse,
    FfiConverterTypeLogEntry,
    FfiConverterTypeNetwork,
    FfiConverterTypeOnchainConfirmationSpeed,
    FfiConverterTypePayment,
    FfiConverterTypePaymentDetails,
    FfiConverterTypePaymentMetadata,
    FfiConverterTypePaymentMethod,
    FfiConverterTypePaymentObserver,
    FfiConverterTypePaymentStatus,
    FfiConverterTypePaymentType,
    FfiConverterTypePrepareLnurlPayRequest,
    FfiConverterTypePrepareLnurlPayResponse,
    FfiConverterTypePrepareSendPaymentRequest,
    FfiConverterTypePrepareSendPaymentResponse,
    FfiConverterTypeProvisionalPayment,
    FfiConverterTypeProvisionalPaymentDetails,
    FfiConverterTypeReceivePaymentMethod,
    FfiConverterTypeReceivePaymentRequest,
    FfiConverterTypeReceivePaymentResponse,
    FfiConverterTypeRefundDepositRequest,
    FfiConverterTypeRefundDepositResponse,
    FfiConverterTypeRegisterLightningAddressRequest,
    FfiConverterTypeSdkBuilder,
    FfiConverterTypeSdkEvent,
    FfiConverterTypeSeed,
    FfiConverterTypeSendOnchainFeeQuote,
    FfiConverterTypeSendOnchainSpeedFeeQuote,
    FfiConverterTypeSendPaymentMethod,
    FfiConverterTypeSendPaymentOptions,
    FfiConverterTypeSendPaymentRequest,
    FfiConverterTypeSendPaymentResponse,
    FfiConverterTypeStorage,
    FfiConverterTypeSyncWalletRequest,
    FfiConverterTypeSyncWalletResponse,
    FfiConverterTypeTokenBalance,
    FfiConverterTypeTokenMetadata,
    FfiConverterTypeTxStatus,
    FfiConverterTypeUpdateDepositPayload,
    FfiConverterTypeUtxo,
    FfiConverterTypeWaitForPaymentIdentifier,
    FfiConverterTypeWaitForPaymentRequest,
    FfiConverterTypeWaitForPaymentResponse,
    FfiConverterTypeu128,
  },
});
