// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceEventListener,
  type UniffiVTableCallbackInterfaceLogger,
  type UniffiVTableCallbackInterfaceBitcoinChainService,
  type UniffiVTableCallbackInterfaceStorage,
} from './breez_sdk_spark-ffi';
import {
  type BitcoinAddressDetails,
  type Bolt11InvoiceDetails,
  type LnurlPayRequestDetails,
  type RestClient,
  InputType,
  SuccessAction,
  SuccessActionProcessed,
} from './breez_sdk_common';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterBool,
  FfiConverterCallback,
  FfiConverterInt32,
  FfiConverterObject,
  FfiConverterObjectWithCallbacks,
  FfiConverterOptional,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiRustCallAsync,
  uniffiTraitInterfaceCall,
  uniffiTraitInterfaceCallAsyncWithError,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
import uniffiBreezSdkCommonModule from './breez_sdk_common';
const {
  FfiConverterTypeBitcoinAddressDetails,
  FfiConverterTypeBolt11InvoiceDetails,
  FfiConverterTypeInputType,
  FfiConverterTypeLnurlPayRequestDetails,
  FfiConverterTypeRestClient,
  FfiConverterTypeSuccessAction,
  FfiConverterTypeSuccessActionProcessed,
} = uniffiBreezSdkCommonModule.converters;
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Connects to the Spark network using the provided configuration and mnemonic.
 *
 * # Arguments
 *
 * * `request` - The connection request object
 *
 * # Returns
 *
 * Result containing either the initialized `BreezSdk` or an `SdkError`
 */
export async function connect(
  request: ConnectRequest,
  asyncOpts_?: { signal: AbortSignal }
): Promise<BreezSdkInterface> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_connect(
          FfiConverterTypeConnectRequest.lower(request)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_free_pointer,
      /*liftFunc:*/ FfiConverterTypeBreezSdk.lift.bind(
        FfiConverterTypeBreezSdk
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export function defaultConfig(network: Network): Config {
  return FfiConverterTypeConfig.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_default_config(
          FfiConverterTypeNetwork.lower(network),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function defaultStorage(dataDir: string): Storage /*throws*/ {
  return FfiConverterTypeStorage.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_default_storage(
          FfiConverterString.lower(dataDir),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function initLogging(
  logDir: string | undefined,
  appLogger: Logger | undefined,
  logFilter: string | undefined
): void /*throws*/ {
  uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError),
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_init_logging(
        FfiConverterOptionalString.lower(logDir),
        FfiConverterOptionalTypeLogger.lower(appLogger),
        FfiConverterOptionalString.lower(logFilter),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
export async function parse(
  input: string,
  asyncOpts_?: { signal: AbortSignal }
): Promise<InputType> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_parse(
          FfiConverterString.lower(input)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterTypeInputType.lift.bind(
        FfiConverterTypeInputType
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}

/**
 * Trait for event listeners
 */
export interface EventListener {
  /**
   * Called when an event occurs
   */
  onEvent(event: SdkEvent): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEventListener: {
  vtable: UniffiVTableCallbackInterfaceEventListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onEvent: (uniffiHandle: bigint, event: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeEventListener.lift(uniffiHandle);
        return jsCallback.onEvent(FfiConverterTypeSdkEvent.lift(event));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // EventListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeEventListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(
      uniffiCallbackInterfaceEventListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeEventListener = new FfiConverterCallback<EventListener>();

export interface Logger {
  log(l: LogEntry): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLogger: {
  vtable: UniffiVTableCallbackInterfaceLogger;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    log: (uniffiHandle: bigint, l: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeLogger.lift(uniffiHandle);
        return jsCallback.log(FfiConverterTypeLogEntry.lift(l));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Logger: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeLogger.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(
      uniffiCallbackInterfaceLogger.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeLogger = new FfiConverterCallback<Logger>();

export type CheckLightningAddressRequest = {
  username: string;
};

/**
 * Generated factory for {@link CheckLightningAddressRequest} record objects.
 */
export const CheckLightningAddressRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      CheckLightningAddressRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CheckLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CheckLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<CheckLightningAddressRequest>,
  });
})();

const FfiConverterTypeCheckLightningAddressRequest = (() => {
  type TypeName = CheckLightningAddressRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        username: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.username, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.username);
    }
  }
  return new FFIConverter();
})();

export type ClaimDepositRequest = {
  txid: string;
  vout: /*u32*/ number;
  maxFee: Fee | undefined;
};

/**
 * Generated factory for {@link ClaimDepositRequest} record objects.
 */
export const ClaimDepositRequest = (() => {
  const defaults = () => ({ maxFee: undefined });
  const create = (() => {
    return uniffiCreateRecord<ClaimDepositRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ClaimDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ClaimDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ClaimDepositRequest>,
  });
})();

const FfiConverterTypeClaimDepositRequest = (() => {
  type TypeName = ClaimDepositRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        maxFee: FfiConverterOptionalTypeFee.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterOptionalTypeFee.write(value.maxFee, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterOptionalTypeFee.allocationSize(value.maxFee)
      );
    }
  }
  return new FFIConverter();
})();

export type ClaimDepositResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link ClaimDepositResponse} record objects.
 */
export const ClaimDepositResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ClaimDepositResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ClaimDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ClaimDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ClaimDepositResponse>,
  });
})();

const FfiConverterTypeClaimDepositResponse = (() => {
  type TypeName = ClaimDepositResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

export type Config = {
  apiKey: string | undefined;
  network: Network;
  syncIntervalSecs: /*u32*/ number;
  maxDepositClaimFee: Fee | undefined;
  /**
   * The domain used for receiving through lnurl-pay and lightning address.
   */
  lnurlDomain: string | undefined;
};

/**
 * Generated factory for {@link Config} record objects.
 */
export const Config = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Config, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Config>,
  });
})();

const FfiConverterTypeConfig = (() => {
  type TypeName = Config;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        apiKey: FfiConverterOptionalString.read(from),
        network: FfiConverterTypeNetwork.read(from),
        syncIntervalSecs: FfiConverterUInt32.read(from),
        maxDepositClaimFee: FfiConverterOptionalTypeFee.read(from),
        lnurlDomain: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.apiKey, into);
      FfiConverterTypeNetwork.write(value.network, into);
      FfiConverterUInt32.write(value.syncIntervalSecs, into);
      FfiConverterOptionalTypeFee.write(value.maxDepositClaimFee, into);
      FfiConverterOptionalString.write(value.lnurlDomain, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.apiKey) +
        FfiConverterTypeNetwork.allocationSize(value.network) +
        FfiConverterUInt32.allocationSize(value.syncIntervalSecs) +
        FfiConverterOptionalTypeFee.allocationSize(value.maxDepositClaimFee) +
        FfiConverterOptionalString.allocationSize(value.lnurlDomain)
      );
    }
  }
  return new FFIConverter();
})();

export type ConnectRequest = {
  config: Config;
  mnemonic: string;
  storageDir: string;
};

/**
 * Generated factory for {@link ConnectRequest} record objects.
 */
export const ConnectRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ConnectRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ConnectRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ConnectRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ConnectRequest>,
  });
})();

const FfiConverterTypeConnectRequest = (() => {
  type TypeName = ConnectRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        config: FfiConverterTypeConfig.read(from),
        mnemonic: FfiConverterString.read(from),
        storageDir: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeConfig.write(value.config, into);
      FfiConverterString.write(value.mnemonic, into);
      FfiConverterString.write(value.storageDir, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeConfig.allocationSize(value.config) +
        FfiConverterString.allocationSize(value.mnemonic) +
        FfiConverterString.allocationSize(value.storageDir)
      );
    }
  }
  return new FFIConverter();
})();

export type Credentials = {
  username: string;
  password: string;
};

/**
 * Generated factory for {@link Credentials} record objects.
 */
export const Credentials = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Credentials, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Credentials}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Credentials}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Credentials>,
  });
})();

const FfiConverterTypeCredentials = (() => {
  type TypeName = Credentials;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        username: FfiConverterString.read(from),
        password: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.username, into);
      FfiConverterString.write(value.password, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.username) +
        FfiConverterString.allocationSize(value.password)
      );
    }
  }
  return new FFIConverter();
})();

export type DepositInfo = {
  txid: string;
  vout: /*u32*/ number;
  amountSats: /*u64*/ bigint;
  refundTx: string | undefined;
  refundTxId: string | undefined;
  claimError: DepositClaimError | undefined;
};

/**
 * Generated factory for {@link DepositInfo} record objects.
 */
export const DepositInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<DepositInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link DepositInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link DepositInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<DepositInfo>,
  });
})();

const FfiConverterTypeDepositInfo = (() => {
  type TypeName = DepositInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        amountSats: FfiConverterUInt64.read(from),
        refundTx: FfiConverterOptionalString.read(from),
        refundTxId: FfiConverterOptionalString.read(from),
        claimError: FfiConverterOptionalTypeDepositClaimError.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterUInt64.write(value.amountSats, into);
      FfiConverterOptionalString.write(value.refundTx, into);
      FfiConverterOptionalString.write(value.refundTxId, into);
      FfiConverterOptionalTypeDepositClaimError.write(value.claimError, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterUInt64.allocationSize(value.amountSats) +
        FfiConverterOptionalString.allocationSize(value.refundTx) +
        FfiConverterOptionalString.allocationSize(value.refundTxId) +
        FfiConverterOptionalTypeDepositClaimError.allocationSize(
          value.claimError
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Request to get the balance of the wallet
 */
export type GetInfoRequest = {};

/**
 * Generated factory for {@link GetInfoRequest} record objects.
 */
export const GetInfoRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetInfoRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetInfoRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetInfoRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetInfoRequest>,
  });
})();

const FfiConverterTypeGetInfoRequest = (() => {
  type TypeName = GetInfoRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

/**
 * Response containing the balance of the wallet
 */
export type GetInfoResponse = {
  /**
   * The balance in satoshis
   */
  balanceSats: /*u64*/ bigint;
};

/**
 * Generated factory for {@link GetInfoResponse} record objects.
 */
export const GetInfoResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetInfoResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetInfoResponse>,
  });
})();

const FfiConverterTypeGetInfoResponse = (() => {
  type TypeName = GetInfoResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        balanceSats: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.balanceSats, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterUInt64.allocationSize(value.balanceSats);
    }
  }
  return new FFIConverter();
})();

export type GetPaymentRequest = {
  paymentId: string;
};

/**
 * Generated factory for {@link GetPaymentRequest} record objects.
 */
export const GetPaymentRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetPaymentRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetPaymentRequest>,
  });
})();

const FfiConverterTypeGetPaymentRequest = (() => {
  type TypeName = GetPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentId, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.paymentId);
    }
  }
  return new FFIConverter();
})();

export type GetPaymentResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link GetPaymentResponse} record objects.
 */
export const GetPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetPaymentResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetPaymentResponse>,
  });
})();

const FfiConverterTypeGetPaymentResponse = (() => {
  type TypeName = GetPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

export type LightningAddressInfo = {
  description: string;
  lightningAddress: string;
  lnurl: string;
  username: string;
};

/**
 * Generated factory for {@link LightningAddressInfo} record objects.
 */
export const LightningAddressInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LightningAddressInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LightningAddressInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LightningAddressInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LightningAddressInfo>,
  });
})();

const FfiConverterTypeLightningAddressInfo = (() => {
  type TypeName = LightningAddressInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterString.read(from),
        lightningAddress: FfiConverterString.read(from),
        lnurl: FfiConverterString.read(from),
        username: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.description, into);
      FfiConverterString.write(value.lightningAddress, into);
      FfiConverterString.write(value.lnurl, into);
      FfiConverterString.write(value.username, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.lightningAddress) +
        FfiConverterString.allocationSize(value.lnurl) +
        FfiConverterString.allocationSize(value.username)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Request to list payments with pagination
 */
export type ListPaymentsRequest = {
  /**
   * Number of records to skip
   */
  offset: /*u32*/ number | undefined;
  /**
   * Maximum number of records to return
   */
  limit: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link ListPaymentsRequest} record objects.
 */
export const ListPaymentsRequest = (() => {
  const defaults = () => ({ offset: undefined, limit: undefined });
  const create = (() => {
    return uniffiCreateRecord<ListPaymentsRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListPaymentsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListPaymentsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ListPaymentsRequest>,
  });
})();

const FfiConverterTypeListPaymentsRequest = (() => {
  type TypeName = ListPaymentsRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        offset: FfiConverterOptionalUInt32.read(from),
        limit: FfiConverterOptionalUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt32.write(value.offset, into);
      FfiConverterOptionalUInt32.write(value.limit, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt32.allocationSize(value.offset) +
        FfiConverterOptionalUInt32.allocationSize(value.limit)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Response from listing payments
 */
export type ListPaymentsResponse = {
  /**
   * The list of payments
   */
  payments: Array<Payment>;
};

/**
 * Generated factory for {@link ListPaymentsResponse} record objects.
 */
export const ListPaymentsResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListPaymentsResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListPaymentsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListPaymentsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ListPaymentsResponse>,
  });
})();

const FfiConverterTypeListPaymentsResponse = (() => {
  type TypeName = ListPaymentsResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payments: FfiConverterArrayTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypePayment.write(value.payments, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypePayment.allocationSize(value.payments);
    }
  }
  return new FFIConverter();
})();

export type ListUnclaimedDepositsRequest = {};

/**
 * Generated factory for {@link ListUnclaimedDepositsRequest} record objects.
 */
export const ListUnclaimedDepositsRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListUnclaimedDepositsRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ListUnclaimedDepositsRequest>,
  });
})();

const FfiConverterTypeListUnclaimedDepositsRequest = (() => {
  type TypeName = ListUnclaimedDepositsRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export type ListUnclaimedDepositsResponse = {
  deposits: Array<DepositInfo>;
};

/**
 * Generated factory for {@link ListUnclaimedDepositsResponse} record objects.
 */
export const ListUnclaimedDepositsResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListUnclaimedDepositsResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ListUnclaimedDepositsResponse>,
  });
})();

const FfiConverterTypeListUnclaimedDepositsResponse = (() => {
  type TypeName = ListUnclaimedDepositsResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        deposits: FfiConverterArrayTypeDepositInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeDepositInfo.write(value.deposits, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeDepositInfo.allocationSize(value.deposits);
    }
  }
  return new FFIConverter();
})();

/**
 * Represents the payment LNURL info
 */
export type LnurlPayInfo = {
  lnAddress: string | undefined;
  comment: string | undefined;
  domain: string | undefined;
  metadata: string | undefined;
  processedSuccessAction: SuccessActionProcessed | undefined;
  rawSuccessAction: SuccessAction | undefined;
};

/**
 * Generated factory for {@link LnurlPayInfo} record objects.
 */
export const LnurlPayInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnurlPayInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlPayInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlPayInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlPayInfo>,
  });
})();

const FfiConverterTypeLnurlPayInfo = (() => {
  type TypeName = LnurlPayInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lnAddress: FfiConverterOptionalString.read(from),
        comment: FfiConverterOptionalString.read(from),
        domain: FfiConverterOptionalString.read(from),
        metadata: FfiConverterOptionalString.read(from),
        processedSuccessAction:
          FfiConverterOptionalTypeSuccessActionProcessed.read(from),
        rawSuccessAction: FfiConverterOptionalTypeSuccessAction.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.lnAddress, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterOptionalString.write(value.domain, into);
      FfiConverterOptionalString.write(value.metadata, into);
      FfiConverterOptionalTypeSuccessActionProcessed.write(
        value.processedSuccessAction,
        into
      );
      FfiConverterOptionalTypeSuccessAction.write(value.rawSuccessAction, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.lnAddress) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterOptionalString.allocationSize(value.domain) +
        FfiConverterOptionalString.allocationSize(value.metadata) +
        FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(
          value.processedSuccessAction
        ) +
        FfiConverterOptionalTypeSuccessAction.allocationSize(
          value.rawSuccessAction
        )
      );
    }
  }
  return new FFIConverter();
})();

export type LnurlPayRequest = {
  prepareResponse: PrepareLnurlPayResponse;
};

/**
 * Generated factory for {@link LnurlPayRequest} record objects.
 */
export const LnurlPayRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnurlPayRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlPayRequest>,
  });
})();

const FfiConverterTypeLnurlPayRequest = (() => {
  type TypeName = LnurlPayRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prepareResponse: FfiConverterTypePrepareLnurlPayResponse.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePrepareLnurlPayResponse.write(
        value.prepareResponse,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePrepareLnurlPayResponse.allocationSize(
        value.prepareResponse
      );
    }
  }
  return new FFIConverter();
})();

export type LnurlPayResponse = {
  payment: Payment;
  successAction: SuccessActionProcessed | undefined;
};

/**
 * Generated factory for {@link LnurlPayResponse} record objects.
 */
export const LnurlPayResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnurlPayResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlPayResponse>,
  });
})();

const FfiConverterTypeLnurlPayResponse = (() => {
  type TypeName = LnurlPayResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
        successAction:
          FfiConverterOptionalTypeSuccessActionProcessed.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
      FfiConverterOptionalTypeSuccessActionProcessed.write(
        value.successAction,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePayment.allocationSize(value.payment) +
        FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(
          value.successAction
        )
      );
    }
  }
  return new FFIConverter();
})();

export type LogEntry = {
  line: string;
  level: string;
};

/**
 * Generated factory for {@link LogEntry} record objects.
 */
export const LogEntry = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LogEntry, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LogEntry}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LogEntry}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LogEntry>,
  });
})();

const FfiConverterTypeLogEntry = (() => {
  type TypeName = LogEntry;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        line: FfiConverterString.read(from),
        level: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.line, into);
      FfiConverterString.write(value.level, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.line) +
        FfiConverterString.allocationSize(value.level)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Represents a payment (sent or received)
 */
export type Payment = {
  /**
   * Unique identifier for the payment
   */
  id: string;
  /**
   * Type of payment (send or receive)
   */
  paymentType: PaymentType;
  /**
   * Status of the payment
   */
  status: PaymentStatus;
  /**
   * Amount in satoshis
   */
  amount: /*u64*/ bigint;
  /**
   * Fee paid in satoshis
   */
  fees: /*u64*/ bigint;
  /**
   * Timestamp of when the payment was created
   */
  timestamp: /*u64*/ bigint;
  /**
   * Method of payment. Sometimes the payment details is empty so this field
   * is used to determine the payment method.
   */
  method: PaymentMethod;
  /**
   * Details of the payment
   */
  details: PaymentDetails | undefined;
};

/**
 * Generated factory for {@link Payment} record objects.
 */
export const Payment = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Payment, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Payment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Payment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Payment>,
  });
})();

const FfiConverterTypePayment = (() => {
  type TypeName = Payment;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        paymentType: FfiConverterTypePaymentType.read(from),
        status: FfiConverterTypePaymentStatus.read(from),
        amount: FfiConverterUInt64.read(from),
        fees: FfiConverterUInt64.read(from),
        timestamp: FfiConverterUInt64.read(from),
        method: FfiConverterTypePaymentMethod.read(from),
        details: FfiConverterOptionalTypePaymentDetails.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterTypePaymentType.write(value.paymentType, into);
      FfiConverterTypePaymentStatus.write(value.status, into);
      FfiConverterUInt64.write(value.amount, into);
      FfiConverterUInt64.write(value.fees, into);
      FfiConverterUInt64.write(value.timestamp, into);
      FfiConverterTypePaymentMethod.write(value.method, into);
      FfiConverterOptionalTypePaymentDetails.write(value.details, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterTypePaymentType.allocationSize(value.paymentType) +
        FfiConverterTypePaymentStatus.allocationSize(value.status) +
        FfiConverterUInt64.allocationSize(value.amount) +
        FfiConverterUInt64.allocationSize(value.fees) +
        FfiConverterUInt64.allocationSize(value.timestamp) +
        FfiConverterTypePaymentMethod.allocationSize(value.method) +
        FfiConverterOptionalTypePaymentDetails.allocationSize(value.details)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Metadata associated with a payment that cannot be extracted from the Spark operator.
 */
export type PaymentMetadata = {
  lnurlPayInfo: LnurlPayInfo | undefined;
};

/**
 * Generated factory for {@link PaymentMetadata} record objects.
 */
export const PaymentMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PaymentMetadata, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PaymentMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PaymentMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PaymentMetadata>,
  });
})();

const FfiConverterTypePaymentMetadata = (() => {
  type TypeName = PaymentMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lnurlPayInfo: FfiConverterOptionalTypeLnurlPayInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeLnurlPayInfo.write(value.lnurlPayInfo, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalTypeLnurlPayInfo.allocationSize(
        value.lnurlPayInfo
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareLnurlPayRequest = {
  amountSats: /*u64*/ bigint;
  payRequest: LnurlPayRequestDetails;
  comment: string | undefined;
  validateSuccessActionUrl: boolean | undefined;
};

/**
 * Generated factory for {@link PrepareLnurlPayRequest} record objects.
 */
export const PrepareLnurlPayRequest = (() => {
  const defaults = () => ({
    comment: undefined,
    validateSuccessActionUrl: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<
      PrepareLnurlPayRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareLnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareLnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareLnurlPayRequest>,
  });
})();

const FfiConverterTypePrepareLnurlPayRequest = (() => {
  type TypeName = PrepareLnurlPayRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amountSats: FfiConverterUInt64.read(from),
        payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from),
        comment: FfiConverterOptionalString.read(from),
        validateSuccessActionUrl: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.amountSats, into);
      FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterOptionalBool.write(value.validateSuccessActionUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.amountSats) +
        FfiConverterTypeLnurlPayRequestDetails.allocationSize(
          value.payRequest
        ) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterOptionalBool.allocationSize(value.validateSuccessActionUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareLnurlPayResponse = {
  amountSats: /*u64*/ bigint;
  comment: string | undefined;
  payRequest: LnurlPayRequestDetails;
  feeSats: /*u64*/ bigint;
  invoiceDetails: Bolt11InvoiceDetails;
  successAction: SuccessAction | undefined;
};

/**
 * Generated factory for {@link PrepareLnurlPayResponse} record objects.
 */
export const PrepareLnurlPayResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PrepareLnurlPayResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareLnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareLnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareLnurlPayResponse>,
  });
})();

const FfiConverterTypePrepareLnurlPayResponse = (() => {
  type TypeName = PrepareLnurlPayResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amountSats: FfiConverterUInt64.read(from),
        comment: FfiConverterOptionalString.read(from),
        payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from),
        feeSats: FfiConverterUInt64.read(from),
        invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.read(from),
        successAction: FfiConverterOptionalTypeSuccessAction.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.amountSats, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into);
      FfiConverterUInt64.write(value.feeSats, into);
      FfiConverterTypeBolt11InvoiceDetails.write(value.invoiceDetails, into);
      FfiConverterOptionalTypeSuccessAction.write(value.successAction, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.amountSats) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterTypeLnurlPayRequestDetails.allocationSize(
          value.payRequest
        ) +
        FfiConverterUInt64.allocationSize(value.feeSats) +
        FfiConverterTypeBolt11InvoiceDetails.allocationSize(
          value.invoiceDetails
        ) +
        FfiConverterOptionalTypeSuccessAction.allocationSize(
          value.successAction
        )
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareSendPaymentRequest = {
  paymentRequest: string;
  amountSats: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link PrepareSendPaymentRequest} record objects.
 */
export const PrepareSendPaymentRequest = (() => {
  const defaults = () => ({ amountSats: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      PrepareSendPaymentRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareSendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareSendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareSendPaymentRequest>,
  });
})();

const FfiConverterTypePrepareSendPaymentRequest = (() => {
  type TypeName = PrepareSendPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentRequest: FfiConverterString.read(from),
        amountSats: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentRequest, into);
      FfiConverterOptionalUInt64.write(value.amountSats, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.paymentRequest) +
        FfiConverterOptionalUInt64.allocationSize(value.amountSats)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareSendPaymentResponse = {
  paymentMethod: SendPaymentMethod;
  amountSats: /*u64*/ bigint;
};

/**
 * Generated factory for {@link PrepareSendPaymentResponse} record objects.
 */
export const PrepareSendPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PrepareSendPaymentResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareSendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareSendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareSendPaymentResponse>,
  });
})();

const FfiConverterTypePrepareSendPaymentResponse = (() => {
  type TypeName = PrepareSendPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentMethod: FfiConverterTypeSendPaymentMethod.read(from),
        amountSats: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeSendPaymentMethod.write(value.paymentMethod, into);
      FfiConverterUInt64.write(value.amountSats, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeSendPaymentMethod.allocationSize(value.paymentMethod) +
        FfiConverterUInt64.allocationSize(value.amountSats)
      );
    }
  }
  return new FFIConverter();
})();

export type ReceivePaymentRequest = {
  paymentMethod: ReceivePaymentMethod;
};

/**
 * Generated factory for {@link ReceivePaymentRequest} record objects.
 */
export const ReceivePaymentRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ReceivePaymentRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReceivePaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReceivePaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ReceivePaymentRequest>,
  });
})();

const FfiConverterTypeReceivePaymentRequest = (() => {
  type TypeName = ReceivePaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentMethod: FfiConverterTypeReceivePaymentMethod.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeReceivePaymentMethod.write(value.paymentMethod, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeReceivePaymentMethod.allocationSize(
        value.paymentMethod
      );
    }
  }
  return new FFIConverter();
})();

export type ReceivePaymentResponse = {
  paymentRequest: string;
  feeSats: /*u64*/ bigint;
};

/**
 * Generated factory for {@link ReceivePaymentResponse} record objects.
 */
export const ReceivePaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ReceivePaymentResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReceivePaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReceivePaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ReceivePaymentResponse>,
  });
})();

const FfiConverterTypeReceivePaymentResponse = (() => {
  type TypeName = ReceivePaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentRequest: FfiConverterString.read(from),
        feeSats: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentRequest, into);
      FfiConverterUInt64.write(value.feeSats, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.paymentRequest) +
        FfiConverterUInt64.allocationSize(value.feeSats)
      );
    }
  }
  return new FFIConverter();
})();

export type RefundDepositRequest = {
  txid: string;
  vout: /*u32*/ number;
  destinationAddress: string;
  fee: Fee;
};

/**
 * Generated factory for {@link RefundDepositRequest} record objects.
 */
export const RefundDepositRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RefundDepositRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RefundDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RefundDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RefundDepositRequest>,
  });
})();

const FfiConverterTypeRefundDepositRequest = (() => {
  type TypeName = RefundDepositRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        destinationAddress: FfiConverterString.read(from),
        fee: FfiConverterTypeFee.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterString.write(value.destinationAddress, into);
      FfiConverterTypeFee.write(value.fee, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterString.allocationSize(value.destinationAddress) +
        FfiConverterTypeFee.allocationSize(value.fee)
      );
    }
  }
  return new FFIConverter();
})();

export type RefundDepositResponse = {
  txId: string;
  txHex: string;
};

/**
 * Generated factory for {@link RefundDepositResponse} record objects.
 */
export const RefundDepositResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RefundDepositResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RefundDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RefundDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RefundDepositResponse>,
  });
})();

const FfiConverterTypeRefundDepositResponse = (() => {
  type TypeName = RefundDepositResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txId: FfiConverterString.read(from),
        txHex: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txId, into);
      FfiConverterString.write(value.txHex, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txId) +
        FfiConverterString.allocationSize(value.txHex)
      );
    }
  }
  return new FFIConverter();
})();

export type RegisterLightningAddressRequest = {
  username: string;
  description: string;
};

/**
 * Generated factory for {@link RegisterLightningAddressRequest} record objects.
 */
export const RegisterLightningAddressRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RegisterLightningAddressRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RegisterLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RegisterLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RegisterLightningAddressRequest>,
  });
})();

const FfiConverterTypeRegisterLightningAddressRequest = (() => {
  type TypeName = RegisterLightningAddressRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        username: FfiConverterString.read(from),
        description: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.username, into);
      FfiConverterString.write(value.description, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.username) +
        FfiConverterString.allocationSize(value.description)
      );
    }
  }
  return new FFIConverter();
})();

export type SendOnchainFeeQuote = {
  id: string;
  expiresAt: /*u64*/ bigint;
  speedFast: SendOnchainSpeedFeeQuote;
  speedMedium: SendOnchainSpeedFeeQuote;
  speedSlow: SendOnchainSpeedFeeQuote;
};

/**
 * Generated factory for {@link SendOnchainFeeQuote} record objects.
 */
export const SendOnchainFeeQuote = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SendOnchainFeeQuote, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendOnchainFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendOnchainFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendOnchainFeeQuote>,
  });
})();

const FfiConverterTypeSendOnchainFeeQuote = (() => {
  type TypeName = SendOnchainFeeQuote;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        expiresAt: FfiConverterUInt64.read(from),
        speedFast: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),
        speedMedium: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),
        speedSlow: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterUInt64.write(value.expiresAt, into);
      FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedFast, into);
      FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedMedium, into);
      FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedSlow, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterUInt64.allocationSize(value.expiresAt) +
        FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(
          value.speedFast
        ) +
        FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(
          value.speedMedium
        ) +
        FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(value.speedSlow)
      );
    }
  }
  return new FFIConverter();
})();

export type SendOnchainSpeedFeeQuote = {
  userFeeSat: /*u64*/ bigint;
  l1BroadcastFeeSat: /*u64*/ bigint;
};

/**
 * Generated factory for {@link SendOnchainSpeedFeeQuote} record objects.
 */
export const SendOnchainSpeedFeeQuote = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SendOnchainSpeedFeeQuote,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendOnchainSpeedFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendOnchainSpeedFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<SendOnchainSpeedFeeQuote>,
  });
})();

const FfiConverterTypeSendOnchainSpeedFeeQuote = (() => {
  type TypeName = SendOnchainSpeedFeeQuote;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userFeeSat: FfiConverterUInt64.read(from),
        l1BroadcastFeeSat: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.userFeeSat, into);
      FfiConverterUInt64.write(value.l1BroadcastFeeSat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.userFeeSat) +
        FfiConverterUInt64.allocationSize(value.l1BroadcastFeeSat)
      );
    }
  }
  return new FFIConverter();
})();

export type SendPaymentRequest = {
  prepareResponse: PrepareSendPaymentResponse;
  options: SendPaymentOptions | undefined;
};

/**
 * Generated factory for {@link SendPaymentRequest} record objects.
 */
export const SendPaymentRequest = (() => {
  const defaults = () => ({ options: undefined });
  const create = (() => {
    return uniffiCreateRecord<SendPaymentRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendPaymentRequest>,
  });
})();

const FfiConverterTypeSendPaymentRequest = (() => {
  type TypeName = SendPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prepareResponse: FfiConverterTypePrepareSendPaymentResponse.read(from),
        options: FfiConverterOptionalTypeSendPaymentOptions.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePrepareSendPaymentResponse.write(
        value.prepareResponse,
        into
      );
      FfiConverterOptionalTypeSendPaymentOptions.write(value.options, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePrepareSendPaymentResponse.allocationSize(
          value.prepareResponse
        ) +
        FfiConverterOptionalTypeSendPaymentOptions.allocationSize(value.options)
      );
    }
  }
  return new FFIConverter();
})();

export type SendPaymentResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link SendPaymentResponse} record objects.
 */
export const SendPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SendPaymentResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendPaymentResponse>,
  });
})();

const FfiConverterTypeSendPaymentResponse = (() => {
  type TypeName = SendPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

/**
 * Request to sync the wallet with the Spark network
 */
export type SyncWalletRequest = {};

/**
 * Generated factory for {@link SyncWalletRequest} record objects.
 */
export const SyncWalletRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SyncWalletRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SyncWalletRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SyncWalletRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SyncWalletRequest>,
  });
})();

const FfiConverterTypeSyncWalletRequest = (() => {
  type TypeName = SyncWalletRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

/**
 * Response from synchronizing the wallet
 */
export type SyncWalletResponse = {};

/**
 * Generated factory for {@link SyncWalletResponse} record objects.
 */
export const SyncWalletResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SyncWalletResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SyncWalletResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SyncWalletResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SyncWalletResponse>,
  });
})();

const FfiConverterTypeSyncWalletResponse = (() => {
  type TypeName = SyncWalletResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export type TxStatus = {
  confirmed: boolean;
  blockHeight: /*u32*/ number | undefined;
  blockTime: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link TxStatus} record objects.
 */
export const TxStatus = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TxStatus, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TxStatus}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TxStatus}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TxStatus>,
  });
})();

const FfiConverterTypeTxStatus = (() => {
  type TypeName = TxStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        confirmed: FfiConverterBool.read(from),
        blockHeight: FfiConverterOptionalUInt32.read(from),
        blockTime: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.confirmed, into);
      FfiConverterOptionalUInt32.write(value.blockHeight, into);
      FfiConverterOptionalUInt64.write(value.blockTime, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterBool.allocationSize(value.confirmed) +
        FfiConverterOptionalUInt32.allocationSize(value.blockHeight) +
        FfiConverterOptionalUInt64.allocationSize(value.blockTime)
      );
    }
  }
  return new FFIConverter();
})();

export type Utxo = {
  txid: string;
  vout: /*u32*/ number;
  value: /*u64*/ bigint;
  status: TxStatus;
};

/**
 * Generated factory for {@link Utxo} record objects.
 */
export const Utxo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Utxo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Utxo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Utxo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Utxo>,
  });
})();

const FfiConverterTypeUtxo = (() => {
  type TypeName = Utxo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        value: FfiConverterUInt64.read(from),
        status: FfiConverterTypeTxStatus.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterUInt64.write(value.value, into);
      FfiConverterTypeTxStatus.write(value.status, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterUInt64.allocationSize(value.value) +
        FfiConverterTypeTxStatus.allocationSize(value.status)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: ChainServiceError

// Enum: ChainServiceError
export enum ChainServiceError_Tags {
  InvalidAddress = 'InvalidAddress',
  ServiceConnectivity = 'ServiceConnectivity',
  Generic = 'Generic',
}
export const ChainServiceError = (() => {
  type InvalidAddress__interface = {
    tag: ChainServiceError_Tags.InvalidAddress;
    inner: Readonly<[string]>;
  };

  class InvalidAddress_
    extends UniffiError
    implements InvalidAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ChainServiceError';
    readonly tag = ChainServiceError_Tags.InvalidAddress;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ChainServiceError', 'InvalidAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidAddress_ {
      return new InvalidAddress_(v0);
    }

    static instanceOf(obj: any): obj is InvalidAddress_ {
      return obj.tag === ChainServiceError_Tags.InvalidAddress;
    }

    static hasInner(obj: any): obj is InvalidAddress_ {
      return InvalidAddress_.instanceOf(obj);
    }

    static getInner(obj: InvalidAddress_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type ServiceConnectivity__interface = {
    tag: ChainServiceError_Tags.ServiceConnectivity;
    inner: Readonly<[string]>;
  };

  class ServiceConnectivity_
    extends UniffiError
    implements ServiceConnectivity__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ChainServiceError';
    readonly tag = ChainServiceError_Tags.ServiceConnectivity;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ChainServiceError', 'ServiceConnectivity');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): ServiceConnectivity_ {
      return new ServiceConnectivity_(v0);
    }

    static instanceOf(obj: any): obj is ServiceConnectivity_ {
      return obj.tag === ChainServiceError_Tags.ServiceConnectivity;
    }

    static hasInner(obj: any): obj is ServiceConnectivity_ {
      return ServiceConnectivity_.instanceOf(obj);
    }

    static getInner(obj: ServiceConnectivity_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Generic__interface = {
    tag: ChainServiceError_Tags.Generic;
    inner: Readonly<[string]>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ChainServiceError';
    readonly tag = ChainServiceError_Tags.Generic;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ChainServiceError', 'Generic');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Generic_ {
      return new Generic_(v0);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === ChainServiceError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is ChainServiceError {
    return obj[uniffiTypeNameSymbol] === 'ChainServiceError';
  }

  return Object.freeze({
    instanceOf,
    InvalidAddress: InvalidAddress_,
    ServiceConnectivity: ServiceConnectivity_,
    Generic: Generic_,
  });
})();

export type ChainServiceError = InstanceType<
  (typeof ChainServiceError)[keyof Omit<typeof ChainServiceError, 'instanceOf'>]
>;

// FfiConverter for enum ChainServiceError
const FfiConverterTypeChainServiceError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ChainServiceError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ChainServiceError.InvalidAddress(
            FfiConverterString.read(from)
          );
        case 2:
          return new ChainServiceError.ServiceConnectivity(
            FfiConverterString.read(from)
          );
        case 3:
          return new ChainServiceError.Generic(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ChainServiceError_Tags.InvalidAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ChainServiceError_Tags.ServiceConnectivity: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ChainServiceError_Tags.Generic: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that ChainServiceError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ChainServiceError_Tags.InvalidAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ChainServiceError_Tags.ServiceConnectivity: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ChainServiceError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: DepositClaimError
export enum DepositClaimError_Tags {
  DepositClaimFeeExceeded = 'DepositClaimFeeExceeded',
  MissingUtxo = 'MissingUtxo',
  Generic = 'Generic',
}
export const DepositClaimError = (() => {
  type DepositClaimFeeExceeded__interface = {
    tag: DepositClaimError_Tags.DepositClaimFeeExceeded;
    inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }>;
  };

  class DepositClaimFeeExceeded_
    extends UniffiEnum
    implements DepositClaimFeeExceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DepositClaimError';
    readonly tag = DepositClaimError_Tags.DepositClaimFeeExceeded;
    readonly inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }>;
    constructor(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }) {
      super('DepositClaimError', 'DepositClaimFeeExceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }): DepositClaimFeeExceeded_ {
      return new DepositClaimFeeExceeded_(inner);
    }

    static instanceOf(obj: any): obj is DepositClaimFeeExceeded_ {
      return obj.tag === DepositClaimError_Tags.DepositClaimFeeExceeded;
    }
  }

  type MissingUtxo__interface = {
    tag: DepositClaimError_Tags.MissingUtxo;
    inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
  };

  class MissingUtxo_ extends UniffiEnum implements MissingUtxo__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DepositClaimError';
    readonly tag = DepositClaimError_Tags.MissingUtxo;
    readonly inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
    constructor(inner: { tx: string; vout: /*u32*/ number }) {
      super('DepositClaimError', 'MissingUtxo');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { tx: string; vout: /*u32*/ number }): MissingUtxo_ {
      return new MissingUtxo_(inner);
    }

    static instanceOf(obj: any): obj is MissingUtxo_ {
      return obj.tag === DepositClaimError_Tags.MissingUtxo;
    }
  }

  type Generic__interface = {
    tag: DepositClaimError_Tags.Generic;
    inner: Readonly<{ message: string }>;
  };

  class Generic_ extends UniffiEnum implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DepositClaimError';
    readonly tag = DepositClaimError_Tags.Generic;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('DepositClaimError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === DepositClaimError_Tags.Generic;
    }
  }

  function instanceOf(obj: any): obj is DepositClaimError {
    return obj[uniffiTypeNameSymbol] === 'DepositClaimError';
  }

  return Object.freeze({
    instanceOf,
    DepositClaimFeeExceeded: DepositClaimFeeExceeded_,
    MissingUtxo: MissingUtxo_,
    Generic: Generic_,
  });
})();

export type DepositClaimError = InstanceType<
  (typeof DepositClaimError)[keyof Omit<typeof DepositClaimError, 'instanceOf'>]
>;

// FfiConverter for enum DepositClaimError
const FfiConverterTypeDepositClaimError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = DepositClaimError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new DepositClaimError.DepositClaimFeeExceeded({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
            maxFee: FfiConverterTypeFee.read(from),
            actualFee: FfiConverterUInt64.read(from),
          });
        case 2:
          return new DepositClaimError.MissingUtxo({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
          });
        case 3:
          return new DepositClaimError.Generic({
            message: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case DepositClaimError_Tags.DepositClaimFeeExceeded: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          FfiConverterTypeFee.write(inner.maxFee, into);
          FfiConverterUInt64.write(inner.actualFee, into);
          return;
        }
        case DepositClaimError_Tags.MissingUtxo: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          return;
        }
        case DepositClaimError_Tags.Generic: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that DepositClaimError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case DepositClaimError_Tags.DepositClaimFeeExceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          size += FfiConverterTypeFee.allocationSize(inner.maxFee);
          size += FfiConverterUInt64.allocationSize(inner.actualFee);
          return size;
        }
        case DepositClaimError_Tags.MissingUtxo: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          return size;
        }
        case DepositClaimError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Fee
export enum Fee_Tags {
  Fixed = 'Fixed',
  Rate = 'Rate',
}
export const Fee = (() => {
  type Fixed__interface = {
    tag: Fee_Tags.Fixed;
    inner: Readonly<{ amount: /*u64*/ bigint }>;
  };

  class Fixed_ extends UniffiEnum implements Fixed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Fee';
    readonly tag = Fee_Tags.Fixed;
    readonly inner: Readonly<{ amount: /*u64*/ bigint }>;
    constructor(inner: { amount: /*u64*/ bigint }) {
      super('Fee', 'Fixed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { amount: /*u64*/ bigint }): Fixed_ {
      return new Fixed_(inner);
    }

    static instanceOf(obj: any): obj is Fixed_ {
      return obj.tag === Fee_Tags.Fixed;
    }
  }

  type Rate__interface = {
    tag: Fee_Tags.Rate;
    inner: Readonly<{ satPerVbyte: /*u64*/ bigint }>;
  };

  class Rate_ extends UniffiEnum implements Rate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Fee';
    readonly tag = Fee_Tags.Rate;
    readonly inner: Readonly<{ satPerVbyte: /*u64*/ bigint }>;
    constructor(inner: { satPerVbyte: /*u64*/ bigint }) {
      super('Fee', 'Rate');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { satPerVbyte: /*u64*/ bigint }): Rate_ {
      return new Rate_(inner);
    }

    static instanceOf(obj: any): obj is Rate_ {
      return obj.tag === Fee_Tags.Rate;
    }
  }

  function instanceOf(obj: any): obj is Fee {
    return obj[uniffiTypeNameSymbol] === 'Fee';
  }

  return Object.freeze({
    instanceOf,
    Fixed: Fixed_,
    Rate: Rate_,
  });
})();

export type Fee = InstanceType<
  (typeof Fee)[keyof Omit<typeof Fee, 'instanceOf'>]
>;

// FfiConverter for enum Fee
const FfiConverterTypeFee = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Fee;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Fee.Fixed({ amount: FfiConverterUInt64.read(from) });
        case 2:
          return new Fee.Rate({ satPerVbyte: FfiConverterUInt64.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Fee_Tags.Fixed: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.amount, into);
          return;
        }
        case Fee_Tags.Rate: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.satPerVbyte, into);
          return;
        }
        default:
          // Throwing from here means that Fee_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Fee_Tags.Fixed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner.amount);
          return size;
        }
        case Fee_Tags.Rate: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt64.allocationSize(inner.satPerVbyte);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum Network {
  Mainnet,
  Regtest,
}

const FfiConverterTypeNetwork = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Network;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Network.Mainnet;
        case 2:
          return Network.Regtest;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Network.Mainnet:
          return ordinalConverter.write(1, into);
        case Network.Regtest:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum OnchainConfirmationSpeed {
  Fast,
  Medium,
  Slow,
}

const FfiConverterTypeOnchainConfirmationSpeed = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = OnchainConfirmationSpeed;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return OnchainConfirmationSpeed.Fast;
        case 2:
          return OnchainConfirmationSpeed.Medium;
        case 3:
          return OnchainConfirmationSpeed.Slow;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case OnchainConfirmationSpeed.Fast:
          return ordinalConverter.write(1, into);
        case OnchainConfirmationSpeed.Medium:
          return ordinalConverter.write(2, into);
        case OnchainConfirmationSpeed.Slow:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: PaymentDetails
export enum PaymentDetails_Tags {
  Spark = 'Spark',
  Lightning = 'Lightning',
  Withdraw = 'Withdraw',
  Deposit = 'Deposit',
}
export const PaymentDetails = (() => {
  type Spark__interface = {
    tag: PaymentDetails_Tags.Spark;
  };

  class Spark_ extends UniffiEnum implements Spark__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Spark;
    constructor() {
      super('PaymentDetails', 'Spark');
    }

    static new(): Spark_ {
      return new Spark_();
    }

    static instanceOf(obj: any): obj is Spark_ {
      return obj.tag === PaymentDetails_Tags.Spark;
    }
  }

  type Lightning__interface = {
    tag: PaymentDetails_Tags.Lightning;
    inner: Readonly<{
      description: string | undefined;
      preimage: string | undefined;
      invoice: string;
      paymentHash: string;
      destinationPubkey: string;
      lnurlPayInfo: LnurlPayInfo | undefined;
    }>;
  };

  class Lightning_ extends UniffiEnum implements Lightning__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Lightning;
    readonly inner: Readonly<{
      description: string | undefined;
      preimage: string | undefined;
      invoice: string;
      paymentHash: string;
      destinationPubkey: string;
      lnurlPayInfo: LnurlPayInfo | undefined;
    }>;
    constructor(inner: {
      /**
       * Represents the invoice description
       */ description: string | undefined;
      /**
       * The preimage of the paid invoice (proof of payment).
       */ preimage: string | undefined;
      /**
       * Represents the Bolt11/Bolt12 invoice associated with a payment
       * In the case of a Send payment, this is the invoice paid by the user
       * In the case of a Receive payment, this is the invoice paid to the user
       */ invoice: string;
      /**
       * The payment hash of the invoice
       */ paymentHash: string;
      /**
       * The invoice destination/payee pubkey
       */ destinationPubkey: string;
      /**
       * Lnurl payment information if this was an lnurl payment.
       */ lnurlPayInfo: LnurlPayInfo | undefined;
    }) {
      super('PaymentDetails', 'Lightning');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Represents the invoice description
       */ description: string | undefined;
      /**
       * The preimage of the paid invoice (proof of payment).
       */ preimage: string | undefined;
      /**
       * Represents the Bolt11/Bolt12 invoice associated with a payment
       * In the case of a Send payment, this is the invoice paid by the user
       * In the case of a Receive payment, this is the invoice paid to the user
       */ invoice: string;
      /**
       * The payment hash of the invoice
       */ paymentHash: string;
      /**
       * The invoice destination/payee pubkey
       */ destinationPubkey: string;
      /**
       * Lnurl payment information if this was an lnurl payment.
       */ lnurlPayInfo: LnurlPayInfo | undefined;
    }): Lightning_ {
      return new Lightning_(inner);
    }

    static instanceOf(obj: any): obj is Lightning_ {
      return obj.tag === PaymentDetails_Tags.Lightning;
    }
  }

  type Withdraw__interface = {
    tag: PaymentDetails_Tags.Withdraw;
    inner: Readonly<{ txId: string }>;
  };

  class Withdraw_ extends UniffiEnum implements Withdraw__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Withdraw;
    readonly inner: Readonly<{ txId: string }>;
    constructor(inner: { txId: string }) {
      super('PaymentDetails', 'Withdraw');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { txId: string }): Withdraw_ {
      return new Withdraw_(inner);
    }

    static instanceOf(obj: any): obj is Withdraw_ {
      return obj.tag === PaymentDetails_Tags.Withdraw;
    }
  }

  type Deposit__interface = {
    tag: PaymentDetails_Tags.Deposit;
    inner: Readonly<{ txId: string }>;
  };

  class Deposit_ extends UniffiEnum implements Deposit__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Deposit;
    readonly inner: Readonly<{ txId: string }>;
    constructor(inner: { txId: string }) {
      super('PaymentDetails', 'Deposit');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { txId: string }): Deposit_ {
      return new Deposit_(inner);
    }

    static instanceOf(obj: any): obj is Deposit_ {
      return obj.tag === PaymentDetails_Tags.Deposit;
    }
  }

  function instanceOf(obj: any): obj is PaymentDetails {
    return obj[uniffiTypeNameSymbol] === 'PaymentDetails';
  }

  return Object.freeze({
    instanceOf,
    Spark: Spark_,
    Lightning: Lightning_,
    Withdraw: Withdraw_,
    Deposit: Deposit_,
  });
})();

export type PaymentDetails = InstanceType<
  (typeof PaymentDetails)[keyof Omit<typeof PaymentDetails, 'instanceOf'>]
>;

// FfiConverter for enum PaymentDetails
const FfiConverterTypePaymentDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PaymentDetails.Spark();
        case 2:
          return new PaymentDetails.Lightning({
            description: FfiConverterOptionalString.read(from),
            preimage: FfiConverterOptionalString.read(from),
            invoice: FfiConverterString.read(from),
            paymentHash: FfiConverterString.read(from),
            destinationPubkey: FfiConverterString.read(from),
            lnurlPayInfo: FfiConverterOptionalTypeLnurlPayInfo.read(from),
          });
        case 3:
          return new PaymentDetails.Withdraw({
            txId: FfiConverterString.read(from),
          });
        case 4:
          return new PaymentDetails.Deposit({
            txId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PaymentDetails_Tags.Spark: {
          ordinalConverter.write(1, into);
          return;
        }
        case PaymentDetails_Tags.Lightning: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.description, into);
          FfiConverterOptionalString.write(inner.preimage, into);
          FfiConverterString.write(inner.invoice, into);
          FfiConverterString.write(inner.paymentHash, into);
          FfiConverterString.write(inner.destinationPubkey, into);
          FfiConverterOptionalTypeLnurlPayInfo.write(inner.lnurlPayInfo, into);
          return;
        }
        case PaymentDetails_Tags.Withdraw: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.txId, into);
          return;
        }
        case PaymentDetails_Tags.Deposit: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.txId, into);
          return;
        }
        default:
          // Throwing from here means that PaymentDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PaymentDetails_Tags.Spark: {
          return ordinalConverter.allocationSize(1);
        }
        case PaymentDetails_Tags.Lightning: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalString.allocationSize(inner.description);
          size += FfiConverterOptionalString.allocationSize(inner.preimage);
          size += FfiConverterString.allocationSize(inner.invoice);
          size += FfiConverterString.allocationSize(inner.paymentHash);
          size += FfiConverterString.allocationSize(inner.destinationPubkey);
          size += FfiConverterOptionalTypeLnurlPayInfo.allocationSize(
            inner.lnurlPayInfo
          );
          return size;
        }
        case PaymentDetails_Tags.Withdraw: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.txId);
          return size;
        }
        case PaymentDetails_Tags.Deposit: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.txId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum PaymentMethod {
  Lightning,
  Spark,
  Deposit,
  Withdraw,
  Unknown,
}

const FfiConverterTypePaymentMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentMethod.Lightning;
        case 2:
          return PaymentMethod.Spark;
        case 3:
          return PaymentMethod.Deposit;
        case 4:
          return PaymentMethod.Withdraw;
        case 5:
          return PaymentMethod.Unknown;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentMethod.Lightning:
          return ordinalConverter.write(1, into);
        case PaymentMethod.Spark:
          return ordinalConverter.write(2, into);
        case PaymentMethod.Deposit:
          return ordinalConverter.write(3, into);
        case PaymentMethod.Withdraw:
          return ordinalConverter.write(4, into);
        case PaymentMethod.Unknown:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The status of a payment
 */
export enum PaymentStatus {
  /**
   * Payment is completed successfully
   */
  Completed,
  /**
   * Payment is in progress
   */
  Pending,
  /**
   * Payment has failed
   */
  Failed,
}

const FfiConverterTypePaymentStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentStatus.Completed;
        case 2:
          return PaymentStatus.Pending;
        case 3:
          return PaymentStatus.Failed;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentStatus.Completed:
          return ordinalConverter.write(1, into);
        case PaymentStatus.Pending:
          return ordinalConverter.write(2, into);
        case PaymentStatus.Failed:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The type of payment
 */
export enum PaymentType {
  /**
   * Payment sent from this wallet
   */
  Send,
  /**
   * Payment received to this wallet
   */
  Receive,
}

const FfiConverterTypePaymentType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentType.Send;
        case 2:
          return PaymentType.Receive;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentType.Send:
          return ordinalConverter.write(1, into);
        case PaymentType.Receive:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ReceivePaymentMethod
export enum ReceivePaymentMethod_Tags {
  SparkAddress = 'SparkAddress',
  BitcoinAddress = 'BitcoinAddress',
  Bolt11Invoice = 'Bolt11Invoice',
}
export const ReceivePaymentMethod = (() => {
  type SparkAddress__interface = {
    tag: ReceivePaymentMethod_Tags.SparkAddress;
  };

  class SparkAddress_ extends UniffiEnum implements SparkAddress__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceivePaymentMethod';
    readonly tag = ReceivePaymentMethod_Tags.SparkAddress;
    constructor() {
      super('ReceivePaymentMethod', 'SparkAddress');
    }

    static new(): SparkAddress_ {
      return new SparkAddress_();
    }

    static instanceOf(obj: any): obj is SparkAddress_ {
      return obj.tag === ReceivePaymentMethod_Tags.SparkAddress;
    }
  }

  type BitcoinAddress__interface = {
    tag: ReceivePaymentMethod_Tags.BitcoinAddress;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceivePaymentMethod';
    readonly tag = ReceivePaymentMethod_Tags.BitcoinAddress;
    constructor() {
      super('ReceivePaymentMethod', 'BitcoinAddress');
    }

    static new(): BitcoinAddress_ {
      return new BitcoinAddress_();
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === ReceivePaymentMethod_Tags.BitcoinAddress;
    }
  }

  type Bolt11Invoice__interface = {
    tag: ReceivePaymentMethod_Tags.Bolt11Invoice;
    inner: Readonly<{
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }>;
  };

  class Bolt11Invoice_ extends UniffiEnum implements Bolt11Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceivePaymentMethod';
    readonly tag = ReceivePaymentMethod_Tags.Bolt11Invoice;
    readonly inner: Readonly<{
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }>;
    constructor(inner: {
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }) {
      super('ReceivePaymentMethod', 'Bolt11Invoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }): Bolt11Invoice_ {
      return new Bolt11Invoice_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11Invoice_ {
      return obj.tag === ReceivePaymentMethod_Tags.Bolt11Invoice;
    }
  }

  function instanceOf(obj: any): obj is ReceivePaymentMethod {
    return obj[uniffiTypeNameSymbol] === 'ReceivePaymentMethod';
  }

  return Object.freeze({
    instanceOf,
    SparkAddress: SparkAddress_,
    BitcoinAddress: BitcoinAddress_,
    Bolt11Invoice: Bolt11Invoice_,
  });
})();

export type ReceivePaymentMethod = InstanceType<
  (typeof ReceivePaymentMethod)[keyof Omit<
    typeof ReceivePaymentMethod,
    'instanceOf'
  >]
>;

// FfiConverter for enum ReceivePaymentMethod
const FfiConverterTypeReceivePaymentMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ReceivePaymentMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ReceivePaymentMethod.SparkAddress();
        case 2:
          return new ReceivePaymentMethod.BitcoinAddress();
        case 3:
          return new ReceivePaymentMethod.Bolt11Invoice({
            description: FfiConverterString.read(from),
            amountSats: FfiConverterOptionalUInt64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ReceivePaymentMethod_Tags.SparkAddress: {
          ordinalConverter.write(1, into);
          return;
        }
        case ReceivePaymentMethod_Tags.BitcoinAddress: {
          ordinalConverter.write(2, into);
          return;
        }
        case ReceivePaymentMethod_Tags.Bolt11Invoice: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.description, into);
          FfiConverterOptionalUInt64.write(inner.amountSats, into);
          return;
        }
        default:
          // Throwing from here means that ReceivePaymentMethod_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ReceivePaymentMethod_Tags.SparkAddress: {
          return ordinalConverter.allocationSize(1);
        }
        case ReceivePaymentMethod_Tags.BitcoinAddress: {
          return ordinalConverter.allocationSize(2);
        }
        case ReceivePaymentMethod_Tags.Bolt11Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.description);
          size += FfiConverterOptionalUInt64.allocationSize(inner.amountSats);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: SdkError

// Enum: SdkError
export enum SdkError_Tags {
  SparkError = 'SparkError',
  InvalidUuid = 'InvalidUuid',
  InvalidInput = 'InvalidInput',
  NetworkError = 'NetworkError',
  StorageError = 'StorageError',
  ChainServiceError = 'ChainServiceError',
  DepositClaimFeeExceeded = 'DepositClaimFeeExceeded',
  MissingUtxo = 'MissingUtxo',
  LnurlError = 'LnurlError',
  Generic = 'Generic',
}
/**
 * Error type for the `BreezSdk`
 */
export const SdkError = (() => {
  type SparkError__interface = {
    tag: SdkError_Tags.SparkError;
    inner: Readonly<[string]>;
  };

  class SparkError_ extends UniffiError implements SparkError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.SparkError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'SparkError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): SparkError_ {
      return new SparkError_(v0);
    }

    static instanceOf(obj: any): obj is SparkError_ {
      return obj.tag === SdkError_Tags.SparkError;
    }

    static hasInner(obj: any): obj is SparkError_ {
      return SparkError_.instanceOf(obj);
    }

    static getInner(obj: SparkError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidUuid__interface = {
    tag: SdkError_Tags.InvalidUuid;
    inner: Readonly<[string]>;
  };

  class InvalidUuid_ extends UniffiError implements InvalidUuid__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.InvalidUuid;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'InvalidUuid');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidUuid_ {
      return new InvalidUuid_(v0);
    }

    static instanceOf(obj: any): obj is InvalidUuid_ {
      return obj.tag === SdkError_Tags.InvalidUuid;
    }

    static hasInner(obj: any): obj is InvalidUuid_ {
      return InvalidUuid_.instanceOf(obj);
    }

    static getInner(obj: InvalidUuid_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidInput__interface = {
    tag: SdkError_Tags.InvalidInput;
    inner: Readonly<[string]>;
  };

  /**
   * Invalid input error
   */
  class InvalidInput_ extends UniffiError implements InvalidInput__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.InvalidInput;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'InvalidInput');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidInput_ {
      return new InvalidInput_(v0);
    }

    static instanceOf(obj: any): obj is InvalidInput_ {
      return obj.tag === SdkError_Tags.InvalidInput;
    }

    static hasInner(obj: any): obj is InvalidInput_ {
      return InvalidInput_.instanceOf(obj);
    }

    static getInner(obj: InvalidInput_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type NetworkError__interface = {
    tag: SdkError_Tags.NetworkError;
    inner: Readonly<[string]>;
  };

  /**
   * Network error
   */
  class NetworkError_ extends UniffiError implements NetworkError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.NetworkError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'NetworkError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): NetworkError_ {
      return new NetworkError_(v0);
    }

    static instanceOf(obj: any): obj is NetworkError_ {
      return obj.tag === SdkError_Tags.NetworkError;
    }

    static hasInner(obj: any): obj is NetworkError_ {
      return NetworkError_.instanceOf(obj);
    }

    static getInner(obj: NetworkError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type StorageError__interface = {
    tag: SdkError_Tags.StorageError;
    inner: Readonly<[string]>;
  };

  /**
   * Storage error
   */
  class StorageError_ extends UniffiError implements StorageError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.StorageError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'StorageError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): StorageError_ {
      return new StorageError_(v0);
    }

    static instanceOf(obj: any): obj is StorageError_ {
      return obj.tag === SdkError_Tags.StorageError;
    }

    static hasInner(obj: any): obj is StorageError_ {
      return StorageError_.instanceOf(obj);
    }

    static getInner(obj: StorageError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type ChainServiceError__interface = {
    tag: SdkError_Tags.ChainServiceError;
    inner: Readonly<[string]>;
  };

  class ChainServiceError_
    extends UniffiError
    implements ChainServiceError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.ChainServiceError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'ChainServiceError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): ChainServiceError_ {
      return new ChainServiceError_(v0);
    }

    static instanceOf(obj: any): obj is ChainServiceError_ {
      return obj.tag === SdkError_Tags.ChainServiceError;
    }

    static hasInner(obj: any): obj is ChainServiceError_ {
      return ChainServiceError_.instanceOf(obj);
    }

    static getInner(obj: ChainServiceError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type DepositClaimFeeExceeded__interface = {
    tag: SdkError_Tags.DepositClaimFeeExceeded;
    inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }>;
  };

  class DepositClaimFeeExceeded_
    extends UniffiError
    implements DepositClaimFeeExceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.DepositClaimFeeExceeded;
    readonly inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }>;
    constructor(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }) {
      super('SdkError', 'DepositClaimFeeExceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }): DepositClaimFeeExceeded_ {
      return new DepositClaimFeeExceeded_(inner);
    }

    static instanceOf(obj: any): obj is DepositClaimFeeExceeded_ {
      return obj.tag === SdkError_Tags.DepositClaimFeeExceeded;
    }

    static hasInner(obj: any): obj is DepositClaimFeeExceeded_ {
      return DepositClaimFeeExceeded_.instanceOf(obj);
    }

    static getInner(
      obj: DepositClaimFeeExceeded_
    ): Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee;
      actualFee: /*u64*/ bigint;
    }> {
      return obj.inner;
    }
  }

  type MissingUtxo__interface = {
    tag: SdkError_Tags.MissingUtxo;
    inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
  };

  class MissingUtxo_ extends UniffiError implements MissingUtxo__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.MissingUtxo;
    readonly inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
    constructor(inner: { tx: string; vout: /*u32*/ number }) {
      super('SdkError', 'MissingUtxo');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { tx: string; vout: /*u32*/ number }): MissingUtxo_ {
      return new MissingUtxo_(inner);
    }

    static instanceOf(obj: any): obj is MissingUtxo_ {
      return obj.tag === SdkError_Tags.MissingUtxo;
    }

    static hasInner(obj: any): obj is MissingUtxo_ {
      return MissingUtxo_.instanceOf(obj);
    }

    static getInner(
      obj: MissingUtxo_
    ): Readonly<{ tx: string; vout: /*u32*/ number }> {
      return obj.inner;
    }
  }

  type LnurlError__interface = {
    tag: SdkError_Tags.LnurlError;
    inner: Readonly<[string]>;
  };

  class LnurlError_ extends UniffiError implements LnurlError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.LnurlError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'LnurlError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): LnurlError_ {
      return new LnurlError_(v0);
    }

    static instanceOf(obj: any): obj is LnurlError_ {
      return obj.tag === SdkError_Tags.LnurlError;
    }

    static hasInner(obj: any): obj is LnurlError_ {
      return LnurlError_.instanceOf(obj);
    }

    static getInner(obj: LnurlError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Generic__interface = {
    tag: SdkError_Tags.Generic;
    inner: Readonly<[string]>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.Generic;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'Generic');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Generic_ {
      return new Generic_(v0);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === SdkError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is SdkError {
    return obj[uniffiTypeNameSymbol] === 'SdkError';
  }

  return Object.freeze({
    instanceOf,
    SparkError: SparkError_,
    InvalidUuid: InvalidUuid_,
    InvalidInput: InvalidInput_,
    NetworkError: NetworkError_,
    StorageError: StorageError_,
    ChainServiceError: ChainServiceError_,
    DepositClaimFeeExceeded: DepositClaimFeeExceeded_,
    MissingUtxo: MissingUtxo_,
    LnurlError: LnurlError_,
    Generic: Generic_,
  });
})();

/**
 * Error type for the `BreezSdk`
 */

export type SdkError = InstanceType<
  (typeof SdkError)[keyof Omit<typeof SdkError, 'instanceOf'>]
>;

// FfiConverter for enum SdkError
const FfiConverterTypeSdkError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SdkError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SdkError.SparkError(FfiConverterString.read(from));
        case 2:
          return new SdkError.InvalidUuid(FfiConverterString.read(from));
        case 3:
          return new SdkError.InvalidInput(FfiConverterString.read(from));
        case 4:
          return new SdkError.NetworkError(FfiConverterString.read(from));
        case 5:
          return new SdkError.StorageError(FfiConverterString.read(from));
        case 6:
          return new SdkError.ChainServiceError(FfiConverterString.read(from));
        case 7:
          return new SdkError.DepositClaimFeeExceeded({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
            maxFee: FfiConverterTypeFee.read(from),
            actualFee: FfiConverterUInt64.read(from),
          });
        case 8:
          return new SdkError.MissingUtxo({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
          });
        case 9:
          return new SdkError.LnurlError(FfiConverterString.read(from));
        case 10:
          return new SdkError.Generic(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SdkError_Tags.SparkError: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.InvalidUuid: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.InvalidInput: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.NetworkError: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.StorageError: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.ChainServiceError: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.DepositClaimFeeExceeded: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          FfiConverterTypeFee.write(inner.maxFee, into);
          FfiConverterUInt64.write(inner.actualFee, into);
          return;
        }
        case SdkError_Tags.MissingUtxo: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          return;
        }
        case SdkError_Tags.LnurlError: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.Generic: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that SdkError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SdkError_Tags.SparkError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.InvalidUuid: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.InvalidInput: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.NetworkError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.StorageError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.ChainServiceError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.DepositClaimFeeExceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          size += FfiConverterTypeFee.allocationSize(inner.maxFee);
          size += FfiConverterUInt64.allocationSize(inner.actualFee);
          return size;
        }
        case SdkError_Tags.MissingUtxo: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          return size;
        }
        case SdkError_Tags.LnurlError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SdkEvent
export enum SdkEvent_Tags {
  Synced = 'Synced',
  ClaimDepositsFailed = 'ClaimDepositsFailed',
  ClaimDepositsSucceeded = 'ClaimDepositsSucceeded',
  PaymentSucceeded = 'PaymentSucceeded',
}
/**
 * Events emitted by the SDK
 */
export const SdkEvent = (() => {
  type Synced__interface = {
    tag: SdkEvent_Tags.Synced;
  };

  /**
   * Emitted when the wallet has been synchronized with the network
   */
  class Synced_ extends UniffiEnum implements Synced__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.Synced;
    constructor() {
      super('SdkEvent', 'Synced');
    }

    static new(): Synced_ {
      return new Synced_();
    }

    static instanceOf(obj: any): obj is Synced_ {
      return obj.tag === SdkEvent_Tags.Synced;
    }
  }

  type ClaimDepositsFailed__interface = {
    tag: SdkEvent_Tags.ClaimDepositsFailed;
    inner: Readonly<{ unclaimedDeposits: Array<DepositInfo> }>;
  };

  /**
   * Emitted when the wallet failed to claim some deposits
   */
  class ClaimDepositsFailed_
    extends UniffiEnum
    implements ClaimDepositsFailed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.ClaimDepositsFailed;
    readonly inner: Readonly<{ unclaimedDeposits: Array<DepositInfo> }>;
    constructor(inner: { unclaimedDeposits: Array<DepositInfo> }) {
      super('SdkEvent', 'ClaimDepositsFailed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      unclaimedDeposits: Array<DepositInfo>;
    }): ClaimDepositsFailed_ {
      return new ClaimDepositsFailed_(inner);
    }

    static instanceOf(obj: any): obj is ClaimDepositsFailed_ {
      return obj.tag === SdkEvent_Tags.ClaimDepositsFailed;
    }
  }

  type ClaimDepositsSucceeded__interface = {
    tag: SdkEvent_Tags.ClaimDepositsSucceeded;
    inner: Readonly<{ claimedDeposits: Array<DepositInfo> }>;
  };

  class ClaimDepositsSucceeded_
    extends UniffiEnum
    implements ClaimDepositsSucceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.ClaimDepositsSucceeded;
    readonly inner: Readonly<{ claimedDeposits: Array<DepositInfo> }>;
    constructor(inner: { claimedDeposits: Array<DepositInfo> }) {
      super('SdkEvent', 'ClaimDepositsSucceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      claimedDeposits: Array<DepositInfo>;
    }): ClaimDepositsSucceeded_ {
      return new ClaimDepositsSucceeded_(inner);
    }

    static instanceOf(obj: any): obj is ClaimDepositsSucceeded_ {
      return obj.tag === SdkEvent_Tags.ClaimDepositsSucceeded;
    }
  }

  type PaymentSucceeded__interface = {
    tag: SdkEvent_Tags.PaymentSucceeded;
    inner: Readonly<{ payment: Payment }>;
  };

  class PaymentSucceeded_
    extends UniffiEnum
    implements PaymentSucceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentSucceeded;
    readonly inner: Readonly<{ payment: Payment }>;
    constructor(inner: { payment: Payment }) {
      super('SdkEvent', 'PaymentSucceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payment: Payment }): PaymentSucceeded_ {
      return new PaymentSucceeded_(inner);
    }

    static instanceOf(obj: any): obj is PaymentSucceeded_ {
      return obj.tag === SdkEvent_Tags.PaymentSucceeded;
    }
  }

  function instanceOf(obj: any): obj is SdkEvent {
    return obj[uniffiTypeNameSymbol] === 'SdkEvent';
  }

  return Object.freeze({
    instanceOf,
    Synced: Synced_,
    ClaimDepositsFailed: ClaimDepositsFailed_,
    ClaimDepositsSucceeded: ClaimDepositsSucceeded_,
    PaymentSucceeded: PaymentSucceeded_,
  });
})();

/**
 * Events emitted by the SDK
 */

export type SdkEvent = InstanceType<
  (typeof SdkEvent)[keyof Omit<typeof SdkEvent, 'instanceOf'>]
>;

// FfiConverter for enum SdkEvent
const FfiConverterTypeSdkEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SdkEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SdkEvent.Synced();
        case 2:
          return new SdkEvent.ClaimDepositsFailed({
            unclaimedDeposits: FfiConverterArrayTypeDepositInfo.read(from),
          });
        case 3:
          return new SdkEvent.ClaimDepositsSucceeded({
            claimedDeposits: FfiConverterArrayTypeDepositInfo.read(from),
          });
        case 4:
          return new SdkEvent.PaymentSucceeded({
            payment: FfiConverterTypePayment.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SdkEvent_Tags.Synced: {
          ordinalConverter.write(1, into);
          return;
        }
        case SdkEvent_Tags.ClaimDepositsFailed: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayTypeDepositInfo.write(inner.unclaimedDeposits, into);
          return;
        }
        case SdkEvent_Tags.ClaimDepositsSucceeded: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterArrayTypeDepositInfo.write(inner.claimedDeposits, into);
          return;
        }
        case SdkEvent_Tags.PaymentSucceeded: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.payment, into);
          return;
        }
        default:
          // Throwing from here means that SdkEvent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SdkEvent_Tags.Synced: {
          return ordinalConverter.allocationSize(1);
        }
        case SdkEvent_Tags.ClaimDepositsFailed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayTypeDepositInfo.allocationSize(
            inner.unclaimedDeposits
          );
          return size;
        }
        case SdkEvent_Tags.ClaimDepositsSucceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterArrayTypeDepositInfo.allocationSize(
            inner.claimedDeposits
          );
          return size;
        }
        case SdkEvent_Tags.PaymentSucceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypePayment.allocationSize(inner.payment);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SendPaymentMethod
export enum SendPaymentMethod_Tags {
  BitcoinAddress = 'BitcoinAddress',
  Bolt11Invoice = 'Bolt11Invoice',
  SparkAddress = 'SparkAddress',
}
export const SendPaymentMethod = (() => {
  type BitcoinAddress__interface = {
    tag: SendPaymentMethod_Tags.BitcoinAddress;
    inner: Readonly<{
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }>;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentMethod';
    readonly tag = SendPaymentMethod_Tags.BitcoinAddress;
    readonly inner: Readonly<{
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }>;
    constructor(inner: {
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }) {
      super('SendPaymentMethod', 'BitcoinAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }): BitcoinAddress_ {
      return new BitcoinAddress_(inner);
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === SendPaymentMethod_Tags.BitcoinAddress;
    }
  }

  type Bolt11Invoice__interface = {
    tag: SendPaymentMethod_Tags.Bolt11Invoice;
    inner: Readonly<{
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }>;
  };

  class Bolt11Invoice_ extends UniffiEnum implements Bolt11Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentMethod';
    readonly tag = SendPaymentMethod_Tags.Bolt11Invoice;
    readonly inner: Readonly<{
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }>;
    constructor(inner: {
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }) {
      super('SendPaymentMethod', 'Bolt11Invoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }): Bolt11Invoice_ {
      return new Bolt11Invoice_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11Invoice_ {
      return obj.tag === SendPaymentMethod_Tags.Bolt11Invoice;
    }
  }

  type SparkAddress__interface = {
    tag: SendPaymentMethod_Tags.SparkAddress;
    inner: Readonly<{ address: string; feeSats: /*u64*/ bigint }>;
  };

  class SparkAddress_ extends UniffiEnum implements SparkAddress__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentMethod';
    readonly tag = SendPaymentMethod_Tags.SparkAddress;
    readonly inner: Readonly<{ address: string; feeSats: /*u64*/ bigint }>;
    constructor(inner: { address: string; feeSats: /*u64*/ bigint }) {
      super('SendPaymentMethod', 'SparkAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      address: string;
      feeSats: /*u64*/ bigint;
    }): SparkAddress_ {
      return new SparkAddress_(inner);
    }

    static instanceOf(obj: any): obj is SparkAddress_ {
      return obj.tag === SendPaymentMethod_Tags.SparkAddress;
    }
  }

  function instanceOf(obj: any): obj is SendPaymentMethod {
    return obj[uniffiTypeNameSymbol] === 'SendPaymentMethod';
  }

  return Object.freeze({
    instanceOf,
    BitcoinAddress: BitcoinAddress_,
    Bolt11Invoice: Bolt11Invoice_,
    SparkAddress: SparkAddress_,
  });
})();

export type SendPaymentMethod = InstanceType<
  (typeof SendPaymentMethod)[keyof Omit<typeof SendPaymentMethod, 'instanceOf'>]
>;

// FfiConverter for enum SendPaymentMethod
const FfiConverterTypeSendPaymentMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SendPaymentMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SendPaymentMethod.BitcoinAddress({
            address: FfiConverterTypeBitcoinAddressDetails.read(from),
            feeQuote: FfiConverterTypeSendOnchainFeeQuote.read(from),
          });
        case 2:
          return new SendPaymentMethod.Bolt11Invoice({
            invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.read(from),
            sparkTransferFeeSats: FfiConverterOptionalUInt64.read(from),
            lightningFeeSats: FfiConverterUInt64.read(from),
          });
        case 3:
          return new SendPaymentMethod.SparkAddress({
            address: FfiConverterString.read(from),
            feeSats: FfiConverterUInt64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SendPaymentMethod_Tags.BitcoinAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeBitcoinAddressDetails.write(inner.address, into);
          FfiConverterTypeSendOnchainFeeQuote.write(inner.feeQuote, into);
          return;
        }
        case SendPaymentMethod_Tags.Bolt11Invoice: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeBolt11InvoiceDetails.write(
            inner.invoiceDetails,
            into
          );
          FfiConverterOptionalUInt64.write(inner.sparkTransferFeeSats, into);
          FfiConverterUInt64.write(inner.lightningFeeSats, into);
          return;
        }
        case SendPaymentMethod_Tags.SparkAddress: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.address, into);
          FfiConverterUInt64.write(inner.feeSats, into);
          return;
        }
        default:
          // Throwing from here means that SendPaymentMethod_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SendPaymentMethod_Tags.BitcoinAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeBitcoinAddressDetails.allocationSize(
            inner.address
          );
          size += FfiConverterTypeSendOnchainFeeQuote.allocationSize(
            inner.feeQuote
          );
          return size;
        }
        case SendPaymentMethod_Tags.Bolt11Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeBolt11InvoiceDetails.allocationSize(
            inner.invoiceDetails
          );
          size += FfiConverterOptionalUInt64.allocationSize(
            inner.sparkTransferFeeSats
          );
          size += FfiConverterUInt64.allocationSize(inner.lightningFeeSats);
          return size;
        }
        case SendPaymentMethod_Tags.SparkAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.address);
          size += FfiConverterUInt64.allocationSize(inner.feeSats);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SendPaymentOptions
export enum SendPaymentOptions_Tags {
  BitcoinAddress = 'BitcoinAddress',
  Bolt11Invoice = 'Bolt11Invoice',
}
export const SendPaymentOptions = (() => {
  type BitcoinAddress__interface = {
    tag: SendPaymentOptions_Tags.BitcoinAddress;
    inner: Readonly<{ confirmationSpeed: OnchainConfirmationSpeed }>;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentOptions';
    readonly tag = SendPaymentOptions_Tags.BitcoinAddress;
    readonly inner: Readonly<{ confirmationSpeed: OnchainConfirmationSpeed }>;
    constructor(inner: { confirmationSpeed: OnchainConfirmationSpeed }) {
      super('SendPaymentOptions', 'BitcoinAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      confirmationSpeed: OnchainConfirmationSpeed;
    }): BitcoinAddress_ {
      return new BitcoinAddress_(inner);
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === SendPaymentOptions_Tags.BitcoinAddress;
    }
  }

  type Bolt11Invoice__interface = {
    tag: SendPaymentOptions_Tags.Bolt11Invoice;
    inner: Readonly<{ useSpark: boolean }>;
  };

  class Bolt11Invoice_ extends UniffiEnum implements Bolt11Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentOptions';
    readonly tag = SendPaymentOptions_Tags.Bolt11Invoice;
    readonly inner: Readonly<{ useSpark: boolean }>;
    constructor(inner: { useSpark: boolean }) {
      super('SendPaymentOptions', 'Bolt11Invoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { useSpark: boolean }): Bolt11Invoice_ {
      return new Bolt11Invoice_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11Invoice_ {
      return obj.tag === SendPaymentOptions_Tags.Bolt11Invoice;
    }
  }

  function instanceOf(obj: any): obj is SendPaymentOptions {
    return obj[uniffiTypeNameSymbol] === 'SendPaymentOptions';
  }

  return Object.freeze({
    instanceOf,
    BitcoinAddress: BitcoinAddress_,
    Bolt11Invoice: Bolt11Invoice_,
  });
})();

export type SendPaymentOptions = InstanceType<
  (typeof SendPaymentOptions)[keyof Omit<
    typeof SendPaymentOptions,
    'instanceOf'
  >]
>;

// FfiConverter for enum SendPaymentOptions
const FfiConverterTypeSendPaymentOptions = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SendPaymentOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SendPaymentOptions.BitcoinAddress({
            confirmationSpeed:
              FfiConverterTypeOnchainConfirmationSpeed.read(from),
          });
        case 2:
          return new SendPaymentOptions.Bolt11Invoice({
            useSpark: FfiConverterBool.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SendPaymentOptions_Tags.BitcoinAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeOnchainConfirmationSpeed.write(
            inner.confirmationSpeed,
            into
          );
          return;
        }
        case SendPaymentOptions_Tags.Bolt11Invoice: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.useSpark, into);
          return;
        }
        default:
          // Throwing from here means that SendPaymentOptions_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SendPaymentOptions_Tags.BitcoinAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeOnchainConfirmationSpeed.allocationSize(
            inner.confirmationSpeed
          );
          return size;
        }
        case SendPaymentOptions_Tags.Bolt11Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterBool.allocationSize(inner.useSpark);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: StorageError

// Enum: StorageError
export enum StorageError_Tags {
  Implementation = 'Implementation',
  InitializationError = 'InitializationError',
  Serialization = 'Serialization',
}
/**
 * Errors that can occur during storage operations
 */
export const StorageError = (() => {
  type Implementation__interface = {
    tag: StorageError_Tags.Implementation;
    inner: Readonly<[string]>;
  };

  class Implementation_
    extends UniffiError
    implements Implementation__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StorageError';
    readonly tag = StorageError_Tags.Implementation;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('StorageError', 'Implementation');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Implementation_ {
      return new Implementation_(v0);
    }

    static instanceOf(obj: any): obj is Implementation_ {
      return obj.tag === StorageError_Tags.Implementation;
    }

    static hasInner(obj: any): obj is Implementation_ {
      return Implementation_.instanceOf(obj);
    }

    static getInner(obj: Implementation_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InitializationError__interface = {
    tag: StorageError_Tags.InitializationError;
    inner: Readonly<[string]>;
  };

  /**
   * Database initialization error
   */
  class InitializationError_
    extends UniffiError
    implements InitializationError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StorageError';
    readonly tag = StorageError_Tags.InitializationError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('StorageError', 'InitializationError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InitializationError_ {
      return new InitializationError_(v0);
    }

    static instanceOf(obj: any): obj is InitializationError_ {
      return obj.tag === StorageError_Tags.InitializationError;
    }

    static hasInner(obj: any): obj is InitializationError_ {
      return InitializationError_.instanceOf(obj);
    }

    static getInner(obj: InitializationError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Serialization__interface = {
    tag: StorageError_Tags.Serialization;
    inner: Readonly<[string]>;
  };

  class Serialization_ extends UniffiError implements Serialization__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StorageError';
    readonly tag = StorageError_Tags.Serialization;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('StorageError', 'Serialization');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Serialization_ {
      return new Serialization_(v0);
    }

    static instanceOf(obj: any): obj is Serialization_ {
      return obj.tag === StorageError_Tags.Serialization;
    }

    static hasInner(obj: any): obj is Serialization_ {
      return Serialization_.instanceOf(obj);
    }

    static getInner(obj: Serialization_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is StorageError {
    return obj[uniffiTypeNameSymbol] === 'StorageError';
  }

  return Object.freeze({
    instanceOf,
    Implementation: Implementation_,
    InitializationError: InitializationError_,
    Serialization: Serialization_,
  });
})();

/**
 * Errors that can occur during storage operations
 */

export type StorageError = InstanceType<
  (typeof StorageError)[keyof Omit<typeof StorageError, 'instanceOf'>]
>;

// FfiConverter for enum StorageError
const FfiConverterTypeStorageError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = StorageError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new StorageError.Implementation(FfiConverterString.read(from));
        case 2:
          return new StorageError.InitializationError(
            FfiConverterString.read(from)
          );
        case 3:
          return new StorageError.Serialization(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case StorageError_Tags.Implementation: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case StorageError_Tags.InitializationError: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case StorageError_Tags.Serialization: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that StorageError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case StorageError_Tags.Implementation: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case StorageError_Tags.InitializationError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case StorageError_Tags.Serialization: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: UpdateDepositPayload
export enum UpdateDepositPayload_Tags {
  ClaimError = 'ClaimError',
  Refund = 'Refund',
}
export const UpdateDepositPayload = (() => {
  type ClaimError__interface = {
    tag: UpdateDepositPayload_Tags.ClaimError;
    inner: Readonly<{ error: DepositClaimError }>;
  };

  class ClaimError_ extends UniffiEnum implements ClaimError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'UpdateDepositPayload';
    readonly tag = UpdateDepositPayload_Tags.ClaimError;
    readonly inner: Readonly<{ error: DepositClaimError }>;
    constructor(inner: { error: DepositClaimError }) {
      super('UpdateDepositPayload', 'ClaimError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: DepositClaimError }): ClaimError_ {
      return new ClaimError_(inner);
    }

    static instanceOf(obj: any): obj is ClaimError_ {
      return obj.tag === UpdateDepositPayload_Tags.ClaimError;
    }
  }

  type Refund__interface = {
    tag: UpdateDepositPayload_Tags.Refund;
    inner: Readonly<{ refundTxid: string; refundTx: string }>;
  };

  class Refund_ extends UniffiEnum implements Refund__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'UpdateDepositPayload';
    readonly tag = UpdateDepositPayload_Tags.Refund;
    readonly inner: Readonly<{ refundTxid: string; refundTx: string }>;
    constructor(inner: { refundTxid: string; refundTx: string }) {
      super('UpdateDepositPayload', 'Refund');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { refundTxid: string; refundTx: string }): Refund_ {
      return new Refund_(inner);
    }

    static instanceOf(obj: any): obj is Refund_ {
      return obj.tag === UpdateDepositPayload_Tags.Refund;
    }
  }

  function instanceOf(obj: any): obj is UpdateDepositPayload {
    return obj[uniffiTypeNameSymbol] === 'UpdateDepositPayload';
  }

  return Object.freeze({
    instanceOf,
    ClaimError: ClaimError_,
    Refund: Refund_,
  });
})();

export type UpdateDepositPayload = InstanceType<
  (typeof UpdateDepositPayload)[keyof Omit<
    typeof UpdateDepositPayload,
    'instanceOf'
  >]
>;

// FfiConverter for enum UpdateDepositPayload
const FfiConverterTypeUpdateDepositPayload = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = UpdateDepositPayload;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new UpdateDepositPayload.ClaimError({
            error: FfiConverterTypeDepositClaimError.read(from),
          });
        case 2:
          return new UpdateDepositPayload.Refund({
            refundTxid: FfiConverterString.read(from),
            refundTx: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case UpdateDepositPayload_Tags.ClaimError: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeDepositClaimError.write(inner.error, into);
          return;
        }
        case UpdateDepositPayload_Tags.Refund: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.refundTxid, into);
          FfiConverterString.write(inner.refundTx, into);
          return;
        }
        default:
          // Throwing from here means that UpdateDepositPayload_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case UpdateDepositPayload_Tags.ClaimError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeDepositClaimError.allocationSize(inner.error);
          return size;
        }
        case UpdateDepositPayload_Tags.Refund: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.refundTxid);
          size += FfiConverterString.allocationSize(inner.refundTx);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface BitcoinChainService {
  getAddressUtxos(
    address: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Array<Utxo>>;
  getTransactionHex(
    txid: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  broadcastTransaction(
    tx: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

export class BitcoinChainServiceImpl
  extends UniffiAbstractObject
  implements BitcoinChainService
{
  readonly [uniffiTypeNameSymbol] = 'BitcoinChainServiceImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeBitcoinChainServiceImplObjectFactory.bless(pointer);
  }

  public async getAddressUtxos(
    address: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<Utxo>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(address)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeUtxo.lift.bind(
          FfiConverterArrayTypeUtxo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getTransactionHex(
    txid: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async broadcastTransaction(
    tx: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(tx)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeBitcoinChainServiceImplObjectFactory.pointer(this);
      uniffiTypeBitcoinChainServiceImplObjectFactory.freePointer(pointer);
      uniffiTypeBitcoinChainServiceImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is BitcoinChainServiceImpl {
    return uniffiTypeBitcoinChainServiceImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeBitcoinChainServiceImplObjectFactory: UniffiObjectFactory<BitcoinChainService> =
  {
    create(pointer: UnsafeMutableRawPointer): BitcoinChainService {
      const instance = Object.create(BitcoinChainServiceImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'BitcoinChainServiceImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_bitcoinchainservice_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: BitcoinChainService): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: BitcoinChainService): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is BitcoinChainService {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'BitcoinChainServiceImpl'
      );
    },
  };
// FfiConverter for BitcoinChainService
const FfiConverterTypeBitcoinChainService = new FfiConverterObjectWithCallbacks(
  uniffiTypeBitcoinChainServiceImplObjectFactory
);

// Add a vtavble for the callbacks that go in BitcoinChainService.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceBitcoinChainService: {
  vtable: UniffiVTableCallbackInterfaceBitcoinChainService;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    getAddressUtxos: (
      uniffiHandle: bigint,
      address: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<Utxo>> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.getAddressUtxos(
          FfiConverterString.lift(address),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: Array<Utxo>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypeUtxo.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getTransactionHex: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<string> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.getTransactionHex(
          FfiConverterString.lift(txid),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: string) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterString.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    broadcastTransaction: (
      uniffiHandle: bigint,
      tx: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.broadcastTransaction(
          FfiConverterString.lift(tx),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // BitcoinChainService: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeBitcoinChainService.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(
      uniffiCallbackInterfaceBitcoinChainService.vtable
    );
  },
};

/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
export interface BreezSdkInterface {
  /**
   * Registers a listener to receive SDK events
   *
   * # Arguments
   *
   * * `listener` - An implementation of the `EventListener` trait
   *
   * # Returns
   *
   * A unique identifier for the listener, which can be used to remove it later
   */
  addEventListener(listener: EventListener): string;
  checkLightningAddressAvailable(
    req: CheckLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  claimDeposit(
    request: ClaimDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ClaimDepositResponse>;
  deleteLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Stops the SDK's background tasks
   *
   * This method stops the background tasks started by the `start()` method.
   * It should be called before your application terminates to ensure proper cleanup.
   *
   * # Returns
   *
   * Result containing either success or an `SdkError` if the background task couldn't be stopped
   */
  disconnect() /*throws*/ : void;
  /**
   * Returns the balance of the wallet in satoshis
   */
  getInfo(
    request: GetInfoRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<GetInfoResponse>;
  getLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<LightningAddressInfo | undefined>;
  getPayment(
    request: GetPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<GetPaymentResponse>;
  /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
  listPayments(
    request: ListPaymentsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ListPaymentsResponse>;
  listUnclaimedDeposits(
    request: ListUnclaimedDepositsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ListUnclaimedDepositsResponse>;
  lnurlPay(
    request: LnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<LnurlPayResponse>;
  pollLightningSendPayment(paymentId: string): void;
  prepareLnurlPay(
    request: PrepareLnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<PrepareLnurlPayResponse>;
  prepareSendPayment(
    request: PrepareSendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<PrepareSendPaymentResponse>;
  receivePayment(
    request: ReceivePaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ReceivePaymentResponse>;
  /**
   * Attempts to recover a lightning address from the lnurl server.
   */
  recoverLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<LightningAddressInfo | undefined>;
  refundDeposit(
    request: RefundDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RefundDepositResponse>;
  registerLightningAddress(
    request: RegisterLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<LightningAddressInfo>;
  /**
   * Removes a previously registered event listener
   *
   * # Arguments
   *
   * * `id` - The listener ID returned from `add_event_listener`
   *
   * # Returns
   *
   * `true` if the listener was found and removed, `false` otherwise
   */
  removeEventListener(id: string): boolean;
  sendPayment(
    request: SendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendPaymentResponse>;
  sendPaymentInternal(
    request: SendPaymentRequest,
    suppressPaymentEvent: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendPaymentResponse>;
  /**
   * Synchronizes the wallet with the Spark network
   */
  syncWallet(request: SyncWalletRequest) /*throws*/ : SyncWalletResponse;
}

/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
export class BreezSdk
  extends UniffiAbstractObject
  implements BreezSdkInterface
{
  readonly [uniffiTypeNameSymbol] = 'BreezSdk';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeBreezSdkObjectFactory.bless(pointer);
  }

  /**
   * Registers a listener to receive SDK events
   *
   * # Arguments
   *
   * * `listener` - An implementation of the `EventListener` trait
   *
   * # Returns
   *
   * A unique identifier for the listener, which can be used to remove it later
   */
  public addEventListener(listener: EventListener): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeEventListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async checkLightningAddressAvailable(
    req: CheckLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeCheckLightningAddressRequest.lower(req)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async claimDeposit(
    request: ClaimDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ClaimDepositResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeClaimDepositRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeClaimDepositResponse.lift.bind(
          FfiConverterTypeClaimDepositResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async deleteLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Stops the SDK's background tasks
   *
   * This method stops the background tasks started by the `start()` method.
   * It should be called before your application terminates to ensure proper cleanup.
   *
   * # Returns
   *
   * Result containing either success or an `SdkError` if the background task couldn't be stopped
   */
  public disconnect(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(
          uniffiTypeBreezSdkObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Returns the balance of the wallet in satoshis
   */
  public async getInfo(
    request: GetInfoRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<GetInfoResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeGetInfoRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeGetInfoResponse.lift.bind(
          FfiConverterTypeGetInfoResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<LightningAddressInfo | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeLightningAddressInfo.lift.bind(
          FfiConverterOptionalTypeLightningAddressInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getPayment(
    request: GetPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<GetPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeGetPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeGetPaymentResponse.lift.bind(
          FfiConverterTypeGetPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
  public async listPayments(
    request: ListPaymentsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ListPaymentsResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeListPaymentsRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeListPaymentsResponse.lift.bind(
          FfiConverterTypeListPaymentsResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async listUnclaimedDeposits(
    request: ListUnclaimedDepositsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ListUnclaimedDepositsResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeListUnclaimedDepositsRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeListUnclaimedDepositsResponse.lift.bind(
          FfiConverterTypeListUnclaimedDepositsResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async lnurlPay(
    request: LnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<LnurlPayResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeLnurlPayRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeLnurlPayResponse.lift.bind(
          FfiConverterTypeLnurlPayResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public pollLightningSendPayment(paymentId: string): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_poll_lightning_send_payment(
          uniffiTypeBreezSdkObjectFactory.clonePointer(this),
          FfiConverterString.lower(paymentId),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public async prepareLnurlPay(
    request: PrepareLnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<PrepareLnurlPayResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareLnurlPayRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePrepareLnurlPayResponse.lift.bind(
          FfiConverterTypePrepareLnurlPayResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async prepareSendPayment(
    request: PrepareSendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<PrepareSendPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareSendPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePrepareSendPaymentResponse.lift.bind(
          FfiConverterTypePrepareSendPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async receivePayment(
    request: ReceivePaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ReceivePaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeReceivePaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeReceivePaymentResponse.lift.bind(
          FfiConverterTypeReceivePaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Attempts to recover a lightning address from the lnurl server.
   */
  public async recoverLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<LightningAddressInfo | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_recover_lightning_address(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeLightningAddressInfo.lift.bind(
          FfiConverterOptionalTypeLightningAddressInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async refundDeposit(
    request: RefundDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RefundDepositResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeRefundDepositRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRefundDepositResponse.lift.bind(
          FfiConverterTypeRefundDepositResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async registerLightningAddress(
    request: RegisterLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<LightningAddressInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeRegisterLightningAddressRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeLightningAddressInfo.lift.bind(
          FfiConverterTypeLightningAddressInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Removes a previously registered event listener
   *
   * # Arguments
   *
   * * `id` - The listener ID returned from `add_event_listener`
   *
   * # Returns
   *
   * `true` if the listener was found and removed, `false` otherwise
   */
  public removeEventListener(id: string): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterString.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async sendPayment(
    request: SendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeSendPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendPaymentResponse.lift.bind(
          FfiConverterTypeSendPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async sendPaymentInternal(
    request: SendPaymentRequest,
    suppressPaymentEvent: boolean,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment_internal(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeSendPaymentRequest.lower(request),
            FfiConverterBool.lower(suppressPaymentEvent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendPaymentResponse.lift.bind(
          FfiConverterTypeSendPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Synchronizes the wallet with the Spark network
   */
  public syncWallet(request: SyncWalletRequest): SyncWalletResponse /*throws*/ {
    return FfiConverterTypeSyncWalletResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeSyncWalletRequest.lower(request),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeBreezSdkObjectFactory.pointer(this);
      uniffiTypeBreezSdkObjectFactory.freePointer(pointer);
      uniffiTypeBreezSdkObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is BreezSdk {
    return uniffiTypeBreezSdkObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeBreezSdkObjectFactory: UniffiObjectFactory<BreezSdkInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): BreezSdkInterface {
      const instance = Object.create(BreezSdk.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'BreezSdk';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_breezsdk_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: BreezSdkInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: BreezSdkInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_breezsdk(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_breezsdk(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is BreezSdkInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'BreezSdk'
      );
    },
  };
// FfiConverter for BreezSdkInterface
const FfiConverterTypeBreezSdk = new FfiConverterObject(
  uniffiTypeBreezSdkObjectFactory
);

/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
export interface SdkBuilderInterface {
  /**
   * Builds the `BreezSdk` instance with the configured components.
   */
  build(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<BreezSdkInterface>;
  /**
   * Sets the chain service to be used by the SDK.
   * Arguments:
   * - `chain_service`: The chain service to be used.
   */
  withChainService(
    chainService: BitcoinChainService,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  withLnurlClient(
    lnurlClient: RestClient,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the REST chain service to be used by the SDK.
   * Arguments:
   * - `url`: The base URL of the REST API.
   * - `credentials`: Optional credentials for basic authentication.
   */
  withRestChainService(
    url: string,
    credentials: Credentials | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
}

/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
export class SdkBuilder
  extends UniffiAbstractObject
  implements SdkBuilderInterface
{
  readonly [uniffiTypeNameSymbol] = 'SdkBuilder';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Creates a new `SdkBuilder` with the provided configuration.
   * Arguments:
   * - `config`: The configuration to be used.
   * - `mnemonic`: The mnemonic phrase for the wallet.
   * - `storage`: The storage backend to be used.
   */
  constructor(config: Config, mnemonic: string, storage: Storage) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
          FfiConverterTypeConfig.lower(config),
          FfiConverterString.lower(mnemonic),
          FfiConverterTypeStorage.lower(storage),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSdkBuilderObjectFactory.bless(pointer);
  }

  /**
   * Builds the `BreezSdk` instance with the configured components.
   */
  public async build(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<BreezSdkInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeBreezSdk.lift.bind(
          FfiConverterTypeBreezSdk
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the chain service to be used by the SDK.
   * Arguments:
   * - `chain_service`: The chain service to be used.
   */
  public async withChainService(
    chainService: BitcoinChainService,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeBitcoinChainService.lower(chainService)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async withLnurlClient(
    lnurlClient: RestClient,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeRestClient.lower(lnurlClient)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the REST chain service to be used by the SDK.
   * Arguments:
   * - `url`: The base URL of the REST API.
   * - `credentials`: Optional credentials for basic authentication.
   */
  public async withRestChainService(
    url: string,
    credentials: Credentials | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterOptionalTypeCredentials.lower(credentials)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSdkBuilderObjectFactory.pointer(this);
      uniffiTypeSdkBuilderObjectFactory.freePointer(pointer);
      uniffiTypeSdkBuilderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SdkBuilder {
    return uniffiTypeSdkBuilderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSdkBuilderObjectFactory: UniffiObjectFactory<SdkBuilderInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SdkBuilderInterface {
      const instance = Object.create(SdkBuilder.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SdkBuilder';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sdkbuilder_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SdkBuilderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SdkBuilderInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_sdkbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_sdkbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SdkBuilderInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'SdkBuilder'
      );
    },
  };
// FfiConverter for SdkBuilderInterface
const FfiConverterTypeSdkBuilder = new FfiConverterObject(
  uniffiTypeSdkBuilderObjectFactory
);

/**
 * Trait for persistent storage
 */
export interface Storage {
  deleteCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  getCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  setCachedItem(
    key: string,
    value: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Lists payments with pagination
   *
   * # Arguments
   *
   * * `offset` - Number of records to skip
   * * `limit` - Maximum number of records to return
   *
   * # Returns
   *
   * A vector of payments or a `StorageError`
   */
  listPayments(
    offset: /*u32*/ number | undefined,
    limit: /*u32*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Array<Payment>>;
  /**
   * Inserts a payment into storage
   *
   * # Arguments
   *
   * * `payment` - The payment to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  insertPayment(
    payment: Payment,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Inserts payment metadata into storage
   *
   * # Arguments
   *
   * * `payment_id` - The ID of the payment
   * * `metadata` - The metadata to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  setPaymentMetadata(
    paymentId: string,
    metadata: PaymentMetadata,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Gets a payment by its ID
   * # Arguments
   *
   * * `id` - The ID of the payment to retrieve
   *
   * # Returns
   *
   * The payment if found or None if not found
   */
  getPaymentById(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Payment>;
  /**
   * Add a deposit to storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `amount_sats` - The amount of the deposit in sats
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  addDeposit(
    txid: string,
    vout: /*u32*/ number,
    amountSats: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Removes an unclaimed deposit from storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  deleteDeposit(
    txid: string,
    vout: /*u32*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Lists all unclaimed deposits from storage
   * # Returns
   *
   * A vector of `DepositInfo` or a `StorageError`
   */
  listDeposits(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<DepositInfo>>;
  /**
   * Updates or inserts unclaimed deposit details
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `payload` - The payload for the update
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  updateDeposit(
    txid: string,
    vout: /*u32*/ number,
    payload: UpdateDepositPayload,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

/**
 * Trait for persistent storage
 */
export class StorageImpl extends UniffiAbstractObject implements Storage {
  readonly [uniffiTypeNameSymbol] = 'StorageImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeStorageImplObjectFactory.bless(pointer);
  }

  public async deleteCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async setCachedItem(
    key: string,
    value: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterString.lower(value)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Lists payments with pagination
   *
   * # Arguments
   *
   * * `offset` - Number of records to skip
   * * `limit` - Maximum number of records to return
   *
   * # Returns
   *
   * A vector of payments or a `StorageError`
   */
  public async listPayments(
    offset: /*u32*/ number | undefined,
    limit: /*u32*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<Payment>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_payments(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterOptionalUInt32.lower(offset),
            FfiConverterOptionalUInt32.lower(limit)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypePayment.lift.bind(
          FfiConverterArrayTypePayment
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Inserts a payment into storage
   *
   * # Arguments
   *
   * * `payment` - The payment to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async insertPayment(
    payment: Payment,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterTypePayment.lower(payment)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Inserts payment metadata into storage
   *
   * # Arguments
   *
   * * `payment_id` - The ID of the payment
   * * `metadata` - The metadata to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async setPaymentMetadata(
    paymentId: string,
    metadata: PaymentMetadata,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(paymentId),
            FfiConverterTypePaymentMetadata.lower(metadata)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Gets a payment by its ID
   * # Arguments
   *
   * * `id` - The ID of the payment to retrieve
   *
   * # Returns
   *
   * The payment if found or None if not found
   */
  public async getPaymentById(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Payment> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(id)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePayment.lift.bind(
          FfiConverterTypePayment
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Add a deposit to storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `amount_sats` - The amount of the deposit in sats
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async addDeposit(
    txid: string,
    vout: /*u32*/ number,
    amountSats: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid),
            FfiConverterUInt32.lower(vout),
            FfiConverterUInt64.lower(amountSats)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Removes an unclaimed deposit from storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async deleteDeposit(
    txid: string,
    vout: /*u32*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid),
            FfiConverterUInt32.lower(vout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Lists all unclaimed deposits from storage
   * # Returns
   *
   * A vector of `DepositInfo` or a `StorageError`
   */
  public async listDeposits(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<DepositInfo>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
            uniffiTypeStorageImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeDepositInfo.lift.bind(
          FfiConverterArrayTypeDepositInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Updates or inserts unclaimed deposit details
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `payload` - The payload for the update
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async updateDeposit(
    txid: string,
    vout: /*u32*/ number,
    payload: UpdateDepositPayload,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid),
            FfiConverterUInt32.lower(vout),
            FfiConverterTypeUpdateDepositPayload.lower(payload)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeStorageImplObjectFactory.pointer(this);
      uniffiTypeStorageImplObjectFactory.freePointer(pointer);
      uniffiTypeStorageImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is StorageImpl {
    return uniffiTypeStorageImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeStorageImplObjectFactory: UniffiObjectFactory<Storage> = {
  create(pointer: UnsafeMutableRawPointer): Storage {
    const instance = Object.create(StorageImpl.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'StorageImpl';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_storage_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: Storage): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: Storage): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_storage(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_storage(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is Storage {
    return (
      obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'StorageImpl'
    );
  },
};
// FfiConverter for Storage
const FfiConverterTypeStorage = new FfiConverterObjectWithCallbacks(
  uniffiTypeStorageImplObjectFactory
);

// Add a vtavble for the callbacks that go in Storage.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceStorage: {
  vtable: UniffiVTableCallbackInterfaceStorage;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    deleteCachedItem: (
      uniffiHandle: bigint,
      key: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.deleteCachedItem(FfiConverterString.lift(key), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getCachedItem: (
      uniffiHandle: bigint,
      key: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<string | undefined> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.getCachedItem(FfiConverterString.lift(key), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: string | undefined) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterOptionalString.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    setCachedItem: (
      uniffiHandle: bigint,
      key: Uint8Array,
      value: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.setCachedItem(
          FfiConverterString.lift(key),
          FfiConverterString.lift(value),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    listPayments: (
      uniffiHandle: bigint,
      offset: Uint8Array,
      limit: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<Payment>> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.listPayments(
          FfiConverterOptionalUInt32.lift(offset),
          FfiConverterOptionalUInt32.lift(limit),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: Array<Payment>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypePayment.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    insertPayment: (
      uniffiHandle: bigint,
      payment: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.insertPayment(
          FfiConverterTypePayment.lift(payment),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    setPaymentMetadata: (
      uniffiHandle: bigint,
      paymentId: Uint8Array,
      metadata: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.setPaymentMetadata(
          FfiConverterString.lift(paymentId),
          FfiConverterTypePaymentMetadata.lift(metadata),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getPaymentById: (
      uniffiHandle: bigint,
      id: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<Payment> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.getPaymentById(FfiConverterString.lift(id), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: Payment) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterTypePayment.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    addDeposit: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      vout: number,
      amountSats: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.addDeposit(
          FfiConverterString.lift(txid),
          FfiConverterUInt32.lift(vout),
          FfiConverterUInt64.lift(amountSats),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    deleteDeposit: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      vout: number,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.deleteDeposit(
          FfiConverterString.lift(txid),
          FfiConverterUInt32.lift(vout),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    listDeposits: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<DepositInfo>> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.listDeposits({ signal });
      };
      const uniffiHandleSuccess = (returnValue: Array<DepositInfo>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypeDepositInfo.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    updateDeposit: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      vout: number,
      payload: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.updateDeposit(
          FfiConverterString.lift(txid),
          FfiConverterUInt32.lift(vout),
          FfiConverterTypeUpdateDepositPayload.lift(payload),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Storage: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeStorage.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(
      uniffiCallbackInterfaceStorage.vtable
    );
  },
};

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for Logger | undefined
const FfiConverterOptionalTypeLogger = new FfiConverterOptional(
  FfiConverterTypeLogger
);

// FfiConverter for SuccessAction | undefined
const FfiConverterOptionalTypeSuccessAction = new FfiConverterOptional(
  FfiConverterTypeSuccessAction
);

// FfiConverter for SuccessActionProcessed | undefined
const FfiConverterOptionalTypeSuccessActionProcessed = new FfiConverterOptional(
  FfiConverterTypeSuccessActionProcessed
);

// FfiConverter for Credentials | undefined
const FfiConverterOptionalTypeCredentials = new FfiConverterOptional(
  FfiConverterTypeCredentials
);

// FfiConverter for LightningAddressInfo | undefined
const FfiConverterOptionalTypeLightningAddressInfo = new FfiConverterOptional(
  FfiConverterTypeLightningAddressInfo
);

// FfiConverter for LnurlPayInfo | undefined
const FfiConverterOptionalTypeLnurlPayInfo = new FfiConverterOptional(
  FfiConverterTypeLnurlPayInfo
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for Array<DepositInfo>
const FfiConverterArrayTypeDepositInfo = new FfiConverterArray(
  FfiConverterTypeDepositInfo
);

// FfiConverter for Array<Payment>
const FfiConverterArrayTypePayment = new FfiConverterArray(
  FfiConverterTypePayment
);

// FfiConverter for Array<Utxo>
const FfiConverterArrayTypeUtxo = new FfiConverterArray(FfiConverterTypeUtxo);

// FfiConverter for DepositClaimError | undefined
const FfiConverterOptionalTypeDepositClaimError = new FfiConverterOptional(
  FfiConverterTypeDepositClaimError
);

// FfiConverter for Fee | undefined
const FfiConverterOptionalTypeFee = new FfiConverterOptional(
  FfiConverterTypeFee
);

// FfiConverter for PaymentDetails | undefined
const FfiConverterOptionalTypePaymentDetails = new FfiConverterOptional(
  FfiConverterTypePaymentDetails
);

// FfiConverter for SendPaymentOptions | undefined
const FfiConverterOptionalTypeSendPaymentOptions = new FfiConverterOptional(
  FfiConverterTypeSendPaymentOptions
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 26;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_breez_sdk_spark_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_connect() !== 40345
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_default_config() !==
    62194
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_default_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_default_storage() !==
    46285
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_default_storage'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_init_logging() !==
    8518
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_init_logging'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_parse() !== 58372
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos() !==
    20959
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex() !==
    19571
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction() !==
    61083
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener() !==
    61844
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available() !==
    31624
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit() !==
    43529
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address() !==
    44132
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect() !==
    30986
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info() !==
    6771
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address() !==
    36552
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment() !==
    11540
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments() !==
    16156
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits() !==
    22486
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay() !==
    10147
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_poll_lightning_send_payment() !==
    5478
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_poll_lightning_send_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay() !==
    37691
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment() !==
    34185
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment() !==
    36984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_recover_lightning_address() !==
    43367
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_recover_lightning_address'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit() !==
    33646
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address() !==
    530
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener() !==
    60980
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment() !==
    54349
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment_internal() !==
    37855
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment_internal'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet() !==
    36066
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build() !==
    8126
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service() !==
    2848
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client() !==
    61720
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service() !==
    56288
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item() !==
    6883
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item() !==
    30248
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item() !==
    7970
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_list_payments() !==
    35678
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_list_payments'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_insert_payment() !==
    28075
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_insert_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata() !==
    45500
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id() !==
    35394
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_add_deposit() !==
    55082
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_add_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit() !==
    13111
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_list_deposits() !==
    22806
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_list_deposits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_update_deposit() !==
    48478
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_update_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new() !==
    52744
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event() !==
    10824
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_logger_log() !==
    11839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_logger_log'
    );
  }

  uniffiCallbackInterfaceEventListener.register();
  uniffiCallbackInterfaceLogger.register();
  uniffiCallbackInterfaceBitcoinChainService.register();
  uniffiCallbackInterfaceStorage.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBitcoinChainService,
    FfiConverterTypeBreezSdk,
    FfiConverterTypeCheckLightningAddressRequest,
    FfiConverterTypeClaimDepositRequest,
    FfiConverterTypeClaimDepositResponse,
    FfiConverterTypeConfig,
    FfiConverterTypeConnectRequest,
    FfiConverterTypeCredentials,
    FfiConverterTypeDepositClaimError,
    FfiConverterTypeDepositInfo,
    FfiConverterTypeFee,
    FfiConverterTypeGetInfoRequest,
    FfiConverterTypeGetInfoResponse,
    FfiConverterTypeGetPaymentRequest,
    FfiConverterTypeGetPaymentResponse,
    FfiConverterTypeLightningAddressInfo,
    FfiConverterTypeListPaymentsRequest,
    FfiConverterTypeListPaymentsResponse,
    FfiConverterTypeListUnclaimedDepositsRequest,
    FfiConverterTypeListUnclaimedDepositsResponse,
    FfiConverterTypeLnurlPayInfo,
    FfiConverterTypeLnurlPayRequest,
    FfiConverterTypeLnurlPayResponse,
    FfiConverterTypeLogEntry,
    FfiConverterTypeNetwork,
    FfiConverterTypeOnchainConfirmationSpeed,
    FfiConverterTypePayment,
    FfiConverterTypePaymentDetails,
    FfiConverterTypePaymentMetadata,
    FfiConverterTypePaymentMethod,
    FfiConverterTypePaymentStatus,
    FfiConverterTypePaymentType,
    FfiConverterTypePrepareLnurlPayRequest,
    FfiConverterTypePrepareLnurlPayResponse,
    FfiConverterTypePrepareSendPaymentRequest,
    FfiConverterTypePrepareSendPaymentResponse,
    FfiConverterTypeReceivePaymentMethod,
    FfiConverterTypeReceivePaymentRequest,
    FfiConverterTypeReceivePaymentResponse,
    FfiConverterTypeRefundDepositRequest,
    FfiConverterTypeRefundDepositResponse,
    FfiConverterTypeRegisterLightningAddressRequest,
    FfiConverterTypeSdkBuilder,
    FfiConverterTypeSdkEvent,
    FfiConverterTypeSendOnchainFeeQuote,
    FfiConverterTypeSendOnchainSpeedFeeQuote,
    FfiConverterTypeSendPaymentMethod,
    FfiConverterTypeSendPaymentOptions,
    FfiConverterTypeSendPaymentRequest,
    FfiConverterTypeSendPaymentResponse,
    FfiConverterTypeStorage,
    FfiConverterTypeSyncWalletRequest,
    FfiConverterTypeSyncWalletResponse,
    FfiConverterTypeTxStatus,
    FfiConverterTypeUpdateDepositPayload,
    FfiConverterTypeUtxo,
  },
});
