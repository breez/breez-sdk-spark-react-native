// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceEventListener,
  type UniffiVTableCallbackInterfaceLogger,
  type UniffiVTableCallbackInterfaceBitcoinChainService,
  type UniffiVTableCallbackInterfaceFiatService,
  type UniffiVTableCallbackInterfacePaymentObserver,
  type UniffiVTableCallbackInterfaceRestClient,
  type UniffiVTableCallbackInterfaceStorage,
  type UniffiVTableCallbackInterfaceSyncStorage,
} from './breez_sdk_spark-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterCallback,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterObjectWithCallbacks,
  FfiConverterOptional,
  FfiConverterUInt16,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiRustCallAsync,
  uniffiTraitInterfaceCall,
  uniffiTraitInterfaceCallAsync,
  uniffiTraitInterfaceCallAsyncWithError,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Connects to the Spark network using the provided configuration and mnemonic.
 *
 * # Arguments
 *
 * * `request` - The connection request object
 *
 * # Returns
 *
 * Result containing either the initialized `BreezSdk` or an `SdkError`
 */
export async function connect(
  request: ConnectRequest,
  asyncOpts_?: { signal: AbortSignal }
): Promise<BreezSdkInterface> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_connect(
          FfiConverterTypeConnectRequest.lower(request)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_breez_sdk_spark_rust_future_free_pointer,
      /*liftFunc:*/ FfiConverterTypeBreezSdk.lift.bind(
        FfiConverterTypeBreezSdk
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
        FfiConverterTypeSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export function defaultConfig(network: Network): Config {
  return FfiConverterTypeConfig.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_default_config(
          FfiConverterTypeNetwork.lower(network),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function initLogging(
  logDir: string | undefined,
  appLogger: Logger | undefined,
  logFilter: string | undefined
): void /*throws*/ {
  uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError),
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_init_logging(
        FfiConverterOptionalString.lower(logDir),
        FfiConverterOptionalTypeLogger.lower(appLogger),
        FfiConverterOptionalString.lower(logFilter),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}

/**
 * Trait for event listeners
 */
export interface EventListener {
  /**
   * Called when an event occurs
   */
  onEvent(event: SdkEvent, asyncOpts_?: { signal: AbortSignal }): Promise<void>;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEventListener: {
  vtable: UniffiVTableCallbackInterfaceEventListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onEvent: (
      uniffiHandle: bigint,
      event: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeEventListener.lift(uniffiHandle);
        return await jsCallback.onEvent(FfiConverterTypeSdkEvent.lift(event), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // EventListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeEventListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(
      uniffiCallbackInterfaceEventListener.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeEventListener = new FfiConverterCallback<EventListener>();

export interface Logger {
  log(l: LogEntry): void;
}

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLogger: {
  vtable: UniffiVTableCallbackInterfaceLogger;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    log: (uniffiHandle: bigint, l: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeLogger.lift(uniffiHandle);
        return jsCallback.log(FfiConverterTypeLogEntry.lift(l));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Logger: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeLogger.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(
      uniffiCallbackInterfaceLogger.vtable
    );
  },
};

// FfiConverter protocol for callback interfaces
const FfiConverterTypeLogger = new FfiConverterCallback<Logger>();

/**
 * Payload of the AES success action, as received from the LNURL endpoint
 *
 * See [`AesSuccessActionDataDecrypted`] for a similar wrapper containing the decrypted payload
 */
export type AesSuccessActionData = {
  /**
   * Contents description, up to 144 characters
   */
  description: string;
  /**
   * Base64, AES-encrypted data where encryption key is payment preimage, up to 4kb of characters
   */
  ciphertext: string;
  /**
   * Base64, initialization vector, exactly 24 characters
   */
  iv: string;
};

/**
 * Generated factory for {@link AesSuccessActionData} record objects.
 */
export const AesSuccessActionData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      AesSuccessActionData,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AesSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AesSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AesSuccessActionData>,
  });
})();

const FfiConverterTypeAesSuccessActionData = (() => {
  type TypeName = AesSuccessActionData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterString.read(from),
        ciphertext: FfiConverterString.read(from),
        iv: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.description, into);
      FfiConverterString.write(value.ciphertext, into);
      FfiConverterString.write(value.iv, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.ciphertext) +
        FfiConverterString.allocationSize(value.iv)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Wrapper for the decrypted [`AesSuccessActionData`] payload
 */
export type AesSuccessActionDataDecrypted = {
  /**
   * Contents description, up to 144 characters
   */
  description: string;
  /**
   * Decrypted content
   */
  plaintext: string;
};

/**
 * Generated factory for {@link AesSuccessActionDataDecrypted} record objects.
 */
export const AesSuccessActionDataDecrypted = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      AesSuccessActionDataDecrypted,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AesSuccessActionDataDecrypted}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AesSuccessActionDataDecrypted}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<AesSuccessActionDataDecrypted>,
  });
})();

const FfiConverterTypeAesSuccessActionDataDecrypted = (() => {
  type TypeName = AesSuccessActionDataDecrypted;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterString.read(from),
        plaintext: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.description, into);
      FfiConverterString.write(value.plaintext, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.plaintext)
      );
    }
  }
  return new FFIConverter();
})();

export type Bip21Details = {
  amountSat: /*u64*/ bigint | undefined;
  assetId: string | undefined;
  uri: string;
  extras: Array<Bip21Extra>;
  label: string | undefined;
  message: string | undefined;
  paymentMethods: Array<InputType>;
};

/**
 * Generated factory for {@link Bip21Details} record objects.
 */
export const Bip21Details = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Bip21Details, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bip21Details}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bip21Details}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bip21Details>,
  });
})();

const FfiConverterTypeBip21Details = (() => {
  type TypeName = Bip21Details;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amountSat: FfiConverterOptionalUInt64.read(from),
        assetId: FfiConverterOptionalString.read(from),
        uri: FfiConverterString.read(from),
        extras: FfiConverterArrayTypeBip21Extra.read(from),
        label: FfiConverterOptionalString.read(from),
        message: FfiConverterOptionalString.read(from),
        paymentMethods: FfiConverterArrayTypeInputType.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.amountSat, into);
      FfiConverterOptionalString.write(value.assetId, into);
      FfiConverterString.write(value.uri, into);
      FfiConverterArrayTypeBip21Extra.write(value.extras, into);
      FfiConverterOptionalString.write(value.label, into);
      FfiConverterOptionalString.write(value.message, into);
      FfiConverterArrayTypeInputType.write(value.paymentMethods, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.amountSat) +
        FfiConverterOptionalString.allocationSize(value.assetId) +
        FfiConverterString.allocationSize(value.uri) +
        FfiConverterArrayTypeBip21Extra.allocationSize(value.extras) +
        FfiConverterOptionalString.allocationSize(value.label) +
        FfiConverterOptionalString.allocationSize(value.message) +
        FfiConverterArrayTypeInputType.allocationSize(value.paymentMethods)
      );
    }
  }
  return new FFIConverter();
})();

export type Bip21Extra = {
  key: string;
  value: string;
};

/**
 * Generated factory for {@link Bip21Extra} record objects.
 */
export const Bip21Extra = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Bip21Extra, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bip21Extra}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bip21Extra}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bip21Extra>,
  });
})();

const FfiConverterTypeBip21Extra = (() => {
  type TypeName = Bip21Extra;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        key: FfiConverterString.read(from),
        value: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.key, into);
      FfiConverterString.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.key) +
        FfiConverterString.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

export type BitcoinAddressDetails = {
  address: string;
  network: BitcoinNetwork;
  source: PaymentRequestSource;
};

/**
 * Generated factory for {@link BitcoinAddressDetails} record objects.
 */
export const BitcoinAddressDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      BitcoinAddressDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BitcoinAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link BitcoinAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<BitcoinAddressDetails>,
  });
})();

const FfiConverterTypeBitcoinAddressDetails = (() => {
  type TypeName = BitcoinAddressDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        address: FfiConverterString.read(from),
        network: FfiConverterTypeBitcoinNetwork.read(from),
        source: FfiConverterTypePaymentRequestSource.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.address, into);
      FfiConverterTypeBitcoinNetwork.write(value.network, into);
      FfiConverterTypePaymentRequestSource.write(value.source, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.address) +
        FfiConverterTypeBitcoinNetwork.allocationSize(value.network) +
        FfiConverterTypePaymentRequestSource.allocationSize(value.source)
      );
    }
  }
  return new FFIConverter();
})();

export type Bolt11Invoice = {
  bolt11: string;
  source: PaymentRequestSource;
};

/**
 * Generated factory for {@link Bolt11Invoice} record objects.
 */
export const Bolt11Invoice = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Bolt11Invoice, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bolt11Invoice}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bolt11Invoice}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bolt11Invoice>,
  });
})();

const FfiConverterTypeBolt11Invoice = (() => {
  type TypeName = Bolt11Invoice;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        bolt11: FfiConverterString.read(from),
        source: FfiConverterTypePaymentRequestSource.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.bolt11, into);
      FfiConverterTypePaymentRequestSource.write(value.source, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.bolt11) +
        FfiConverterTypePaymentRequestSource.allocationSize(value.source)
      );
    }
  }
  return new FFIConverter();
})();

export type Bolt11InvoiceDetails = {
  amountMsat: /*u64*/ bigint | undefined;
  description: string | undefined;
  descriptionHash: string | undefined;
  expiry: /*u64*/ bigint;
  invoice: Bolt11Invoice;
  minFinalCltvExpiryDelta: /*u64*/ bigint;
  network: BitcoinNetwork;
  payeePubkey: string;
  paymentHash: string;
  paymentSecret: string;
  routingHints: Array<Bolt11RouteHint>;
  timestamp: /*u64*/ bigint;
};

/**
 * Generated factory for {@link Bolt11InvoiceDetails} record objects.
 */
export const Bolt11InvoiceDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      Bolt11InvoiceDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bolt11InvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bolt11InvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bolt11InvoiceDetails>,
  });
})();

const FfiConverterTypeBolt11InvoiceDetails = (() => {
  type TypeName = Bolt11InvoiceDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amountMsat: FfiConverterOptionalUInt64.read(from),
        description: FfiConverterOptionalString.read(from),
        descriptionHash: FfiConverterOptionalString.read(from),
        expiry: FfiConverterUInt64.read(from),
        invoice: FfiConverterTypeBolt11Invoice.read(from),
        minFinalCltvExpiryDelta: FfiConverterUInt64.read(from),
        network: FfiConverterTypeBitcoinNetwork.read(from),
        payeePubkey: FfiConverterString.read(from),
        paymentHash: FfiConverterString.read(from),
        paymentSecret: FfiConverterString.read(from),
        routingHints: FfiConverterArrayTypeBolt11RouteHint.read(from),
        timestamp: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.amountMsat, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalString.write(value.descriptionHash, into);
      FfiConverterUInt64.write(value.expiry, into);
      FfiConverterTypeBolt11Invoice.write(value.invoice, into);
      FfiConverterUInt64.write(value.minFinalCltvExpiryDelta, into);
      FfiConverterTypeBitcoinNetwork.write(value.network, into);
      FfiConverterString.write(value.payeePubkey, into);
      FfiConverterString.write(value.paymentHash, into);
      FfiConverterString.write(value.paymentSecret, into);
      FfiConverterArrayTypeBolt11RouteHint.write(value.routingHints, into);
      FfiConverterUInt64.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.amountMsat) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalString.allocationSize(value.descriptionHash) +
        FfiConverterUInt64.allocationSize(value.expiry) +
        FfiConverterTypeBolt11Invoice.allocationSize(value.invoice) +
        FfiConverterUInt64.allocationSize(value.minFinalCltvExpiryDelta) +
        FfiConverterTypeBitcoinNetwork.allocationSize(value.network) +
        FfiConverterString.allocationSize(value.payeePubkey) +
        FfiConverterString.allocationSize(value.paymentHash) +
        FfiConverterString.allocationSize(value.paymentSecret) +
        FfiConverterArrayTypeBolt11RouteHint.allocationSize(
          value.routingHints
        ) +
        FfiConverterUInt64.allocationSize(value.timestamp)
      );
    }
  }
  return new FFIConverter();
})();

export type Bolt11RouteHint = {
  hops: Array<Bolt11RouteHintHop>;
};

/**
 * Generated factory for {@link Bolt11RouteHint} record objects.
 */
export const Bolt11RouteHint = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Bolt11RouteHint, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bolt11RouteHint}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bolt11RouteHint}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bolt11RouteHint>,
  });
})();

const FfiConverterTypeBolt11RouteHint = (() => {
  type TypeName = Bolt11RouteHint;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        hops: FfiConverterArrayTypeBolt11RouteHintHop.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeBolt11RouteHintHop.write(value.hops, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeBolt11RouteHintHop.allocationSize(value.hops);
    }
  }
  return new FFIConverter();
})();

export type Bolt11RouteHintHop = {
  /**
   * The `node_id` of the non-target end of the route
   */
  srcNodeId: string;
  /**
   * The `short_channel_id` of this channel
   */
  shortChannelId: string;
  /**
   * The fees which must be paid to use this channel
   */
  feesBaseMsat: /*u32*/ number;
  feesProportionalMillionths: /*u32*/ number;
  /**
   * The difference in CLTV values between this node and the next node.
   */
  cltvExpiryDelta: /*u16*/ number;
  /**
   * The minimum value, in msat, which must be relayed to the next hop.
   */
  htlcMinimumMsat: /*u64*/ bigint | undefined;
  /**
   * The maximum value in msat available for routing with a single HTLC.
   */
  htlcMaximumMsat: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link Bolt11RouteHintHop} record objects.
 */
export const Bolt11RouteHintHop = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Bolt11RouteHintHop, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bolt11RouteHintHop}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bolt11RouteHintHop}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bolt11RouteHintHop>,
  });
})();

const FfiConverterTypeBolt11RouteHintHop = (() => {
  type TypeName = Bolt11RouteHintHop;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        srcNodeId: FfiConverterString.read(from),
        shortChannelId: FfiConverterString.read(from),
        feesBaseMsat: FfiConverterUInt32.read(from),
        feesProportionalMillionths: FfiConverterUInt32.read(from),
        cltvExpiryDelta: FfiConverterUInt16.read(from),
        htlcMinimumMsat: FfiConverterOptionalUInt64.read(from),
        htlcMaximumMsat: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.srcNodeId, into);
      FfiConverterString.write(value.shortChannelId, into);
      FfiConverterUInt32.write(value.feesBaseMsat, into);
      FfiConverterUInt32.write(value.feesProportionalMillionths, into);
      FfiConverterUInt16.write(value.cltvExpiryDelta, into);
      FfiConverterOptionalUInt64.write(value.htlcMinimumMsat, into);
      FfiConverterOptionalUInt64.write(value.htlcMaximumMsat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.srcNodeId) +
        FfiConverterString.allocationSize(value.shortChannelId) +
        FfiConverterUInt32.allocationSize(value.feesBaseMsat) +
        FfiConverterUInt32.allocationSize(value.feesProportionalMillionths) +
        FfiConverterUInt16.allocationSize(value.cltvExpiryDelta) +
        FfiConverterOptionalUInt64.allocationSize(value.htlcMinimumMsat) +
        FfiConverterOptionalUInt64.allocationSize(value.htlcMaximumMsat)
      );
    }
  }
  return new FFIConverter();
})();

export type Bolt12Invoice = {
  invoice: string;
  source: PaymentRequestSource;
};

/**
 * Generated factory for {@link Bolt12Invoice} record objects.
 */
export const Bolt12Invoice = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Bolt12Invoice, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bolt12Invoice}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bolt12Invoice}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bolt12Invoice>,
  });
})();

const FfiConverterTypeBolt12Invoice = (() => {
  type TypeName = Bolt12Invoice;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        invoice: FfiConverterString.read(from),
        source: FfiConverterTypePaymentRequestSource.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.invoice, into);
      FfiConverterTypePaymentRequestSource.write(value.source, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.invoice) +
        FfiConverterTypePaymentRequestSource.allocationSize(value.source)
      );
    }
  }
  return new FFIConverter();
})();

export type Bolt12InvoiceDetails = {
  amountMsat: /*u64*/ bigint;
  invoice: Bolt12Invoice;
};

/**
 * Generated factory for {@link Bolt12InvoiceDetails} record objects.
 */
export const Bolt12InvoiceDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      Bolt12InvoiceDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bolt12InvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bolt12InvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bolt12InvoiceDetails>,
  });
})();

const FfiConverterTypeBolt12InvoiceDetails = (() => {
  type TypeName = Bolt12InvoiceDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amountMsat: FfiConverterUInt64.read(from),
        invoice: FfiConverterTypeBolt12Invoice.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.amountMsat, into);
      FfiConverterTypeBolt12Invoice.write(value.invoice, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.amountMsat) +
        FfiConverterTypeBolt12Invoice.allocationSize(value.invoice)
      );
    }
  }
  return new FFIConverter();
})();

export type Bolt12InvoiceRequestDetails = {};

/**
 * Generated factory for {@link Bolt12InvoiceRequestDetails} record objects.
 */
export const Bolt12InvoiceRequestDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      Bolt12InvoiceRequestDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bolt12InvoiceRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bolt12InvoiceRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<Bolt12InvoiceRequestDetails>,
  });
})();

const FfiConverterTypeBolt12InvoiceRequestDetails = (() => {
  type TypeName = Bolt12InvoiceRequestDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export type Bolt12Offer = {
  offer: string;
  source: PaymentRequestSource;
};

/**
 * Generated factory for {@link Bolt12Offer} record objects.
 */
export const Bolt12Offer = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Bolt12Offer, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bolt12Offer}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bolt12Offer}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bolt12Offer>,
  });
})();

const FfiConverterTypeBolt12Offer = (() => {
  type TypeName = Bolt12Offer;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        offer: FfiConverterString.read(from),
        source: FfiConverterTypePaymentRequestSource.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.offer, into);
      FfiConverterTypePaymentRequestSource.write(value.source, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.offer) +
        FfiConverterTypePaymentRequestSource.allocationSize(value.source)
      );
    }
  }
  return new FFIConverter();
})();

export type Bolt12OfferBlindedPath = {
  blindedHops: Array<string>;
};

/**
 * Generated factory for {@link Bolt12OfferBlindedPath} record objects.
 */
export const Bolt12OfferBlindedPath = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      Bolt12OfferBlindedPath,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bolt12OfferBlindedPath}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bolt12OfferBlindedPath}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<Bolt12OfferBlindedPath>,
  });
})();

const FfiConverterTypeBolt12OfferBlindedPath = (() => {
  type TypeName = Bolt12OfferBlindedPath;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        blindedHops: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.blindedHops, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayString.allocationSize(value.blindedHops);
    }
  }
  return new FFIConverter();
})();

export type Bolt12OfferDetails = {
  absoluteExpiry: /*u64*/ bigint | undefined;
  chains: Array<string>;
  description: string | undefined;
  issuer: string | undefined;
  minAmount: Amount | undefined;
  offer: Bolt12Offer;
  paths: Array<Bolt12OfferBlindedPath>;
  signingPubkey: string | undefined;
};

/**
 * Generated factory for {@link Bolt12OfferDetails} record objects.
 */
export const Bolt12OfferDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Bolt12OfferDetails, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bolt12OfferDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bolt12OfferDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bolt12OfferDetails>,
  });
})();

const FfiConverterTypeBolt12OfferDetails = (() => {
  type TypeName = Bolt12OfferDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        absoluteExpiry: FfiConverterOptionalUInt64.read(from),
        chains: FfiConverterArrayString.read(from),
        description: FfiConverterOptionalString.read(from),
        issuer: FfiConverterOptionalString.read(from),
        minAmount: FfiConverterOptionalTypeAmount.read(from),
        offer: FfiConverterTypeBolt12Offer.read(from),
        paths: FfiConverterArrayTypeBolt12OfferBlindedPath.read(from),
        signingPubkey: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalUInt64.write(value.absoluteExpiry, into);
      FfiConverterArrayString.write(value.chains, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalString.write(value.issuer, into);
      FfiConverterOptionalTypeAmount.write(value.minAmount, into);
      FfiConverterTypeBolt12Offer.write(value.offer, into);
      FfiConverterArrayTypeBolt12OfferBlindedPath.write(value.paths, into);
      FfiConverterOptionalString.write(value.signingPubkey, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalUInt64.allocationSize(value.absoluteExpiry) +
        FfiConverterArrayString.allocationSize(value.chains) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalString.allocationSize(value.issuer) +
        FfiConverterOptionalTypeAmount.allocationSize(value.minAmount) +
        FfiConverterTypeBolt12Offer.allocationSize(value.offer) +
        FfiConverterArrayTypeBolt12OfferBlindedPath.allocationSize(
          value.paths
        ) +
        FfiConverterOptionalString.allocationSize(value.signingPubkey)
      );
    }
  }
  return new FFIConverter();
})();

export type CheckLightningAddressRequest = {
  username: string;
};

/**
 * Generated factory for {@link CheckLightningAddressRequest} record objects.
 */
export const CheckLightningAddressRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      CheckLightningAddressRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CheckLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CheckLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<CheckLightningAddressRequest>,
  });
})();

const FfiConverterTypeCheckLightningAddressRequest = (() => {
  type TypeName = CheckLightningAddressRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        username: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.username, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.username);
    }
  }
  return new FFIConverter();
})();

export type CheckMessageRequest = {
  /**
   * The message that was signed
   */
  message: string;
  /**
   * The public key that signed the message
   */
  pubkey: string;
  /**
   * The DER or compact hex encoded signature
   */
  signature: string;
};

/**
 * Generated factory for {@link CheckMessageRequest} record objects.
 */
export const CheckMessageRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CheckMessageRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CheckMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CheckMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CheckMessageRequest>,
  });
})();

const FfiConverterTypeCheckMessageRequest = (() => {
  type TypeName = CheckMessageRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        message: FfiConverterString.read(from),
        pubkey: FfiConverterString.read(from),
        signature: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.message, into);
      FfiConverterString.write(value.pubkey, into);
      FfiConverterString.write(value.signature, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.message) +
        FfiConverterString.allocationSize(value.pubkey) +
        FfiConverterString.allocationSize(value.signature)
      );
    }
  }
  return new FFIConverter();
})();

export type CheckMessageResponse = {
  isValid: boolean;
};

/**
 * Generated factory for {@link CheckMessageResponse} record objects.
 */
export const CheckMessageResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      CheckMessageResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CheckMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CheckMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CheckMessageResponse>,
  });
})();

const FfiConverterTypeCheckMessageResponse = (() => {
  type TypeName = CheckMessageResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        isValid: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.isValid, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterBool.allocationSize(value.isValid);
    }
  }
  return new FFIConverter();
})();

export type ClaimDepositRequest = {
  txid: string;
  vout: /*u32*/ number;
  maxFee: Fee | undefined;
};

/**
 * Generated factory for {@link ClaimDepositRequest} record objects.
 */
export const ClaimDepositRequest = (() => {
  const defaults = () => ({ maxFee: undefined });
  const create = (() => {
    return uniffiCreateRecord<ClaimDepositRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ClaimDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ClaimDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ClaimDepositRequest>,
  });
})();

const FfiConverterTypeClaimDepositRequest = (() => {
  type TypeName = ClaimDepositRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        maxFee: FfiConverterOptionalTypeFee.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterOptionalTypeFee.write(value.maxFee, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterOptionalTypeFee.allocationSize(value.maxFee)
      );
    }
  }
  return new FFIConverter();
})();

export type ClaimDepositResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link ClaimDepositResponse} record objects.
 */
export const ClaimDepositResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ClaimDepositResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ClaimDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ClaimDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ClaimDepositResponse>,
  });
})();

const FfiConverterTypeClaimDepositResponse = (() => {
  type TypeName = ClaimDepositResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

export type Config = {
  apiKey: string | undefined;
  network: Network;
  syncIntervalSecs: /*u32*/ number;
  maxDepositClaimFee: Fee | undefined;
  /**
   * The domain used for receiving through lnurl-pay and lightning address.
   */
  lnurlDomain: string | undefined;
  /**
   * When this is set to `true` we will prefer to use spark payments over
   * lightning when sending and receiving. This has the benefit of lower fees
   * but is at the cost of privacy.
   */
  preferSparkOverLightning: boolean;
  /**
   * A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
   * is not recognized. See [`ExternalInputParser`] for more details on how to configure
   * external parsing.
   */
  externalInputParsers: Array<ExternalInputParser> | undefined;
  /**
   * The SDK includes some default external input parsers
   * ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
   * Set this to false in order to prevent their use.
   */
  useDefaultExternalInputParsers: boolean;
  /**
   * Url to use for the real-time sync server. Defaults to the Breez real-time sync server.
   */
  realTimeSyncServerUrl: string | undefined;
  /**
   * Whether the Spark private mode is enabled by default.
   *
   * If set to true, the Spark private mode will be enabled on the first initialization of the SDK.
   * If set to false, no changes will be made to the Spark private mode.
   */
  privateEnabledDefault: boolean;
};

/**
 * Generated factory for {@link Config} record objects.
 */
export const Config = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Config, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Config>,
  });
})();

const FfiConverterTypeConfig = (() => {
  type TypeName = Config;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        apiKey: FfiConverterOptionalString.read(from),
        network: FfiConverterTypeNetwork.read(from),
        syncIntervalSecs: FfiConverterUInt32.read(from),
        maxDepositClaimFee: FfiConverterOptionalTypeFee.read(from),
        lnurlDomain: FfiConverterOptionalString.read(from),
        preferSparkOverLightning: FfiConverterBool.read(from),
        externalInputParsers:
          FfiConverterOptionalArrayTypeExternalInputParser.read(from),
        useDefaultExternalInputParsers: FfiConverterBool.read(from),
        realTimeSyncServerUrl: FfiConverterOptionalString.read(from),
        privateEnabledDefault: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.apiKey, into);
      FfiConverterTypeNetwork.write(value.network, into);
      FfiConverterUInt32.write(value.syncIntervalSecs, into);
      FfiConverterOptionalTypeFee.write(value.maxDepositClaimFee, into);
      FfiConverterOptionalString.write(value.lnurlDomain, into);
      FfiConverterBool.write(value.preferSparkOverLightning, into);
      FfiConverterOptionalArrayTypeExternalInputParser.write(
        value.externalInputParsers,
        into
      );
      FfiConverterBool.write(value.useDefaultExternalInputParsers, into);
      FfiConverterOptionalString.write(value.realTimeSyncServerUrl, into);
      FfiConverterBool.write(value.privateEnabledDefault, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.apiKey) +
        FfiConverterTypeNetwork.allocationSize(value.network) +
        FfiConverterUInt32.allocationSize(value.syncIntervalSecs) +
        FfiConverterOptionalTypeFee.allocationSize(value.maxDepositClaimFee) +
        FfiConverterOptionalString.allocationSize(value.lnurlDomain) +
        FfiConverterBool.allocationSize(value.preferSparkOverLightning) +
        FfiConverterOptionalArrayTypeExternalInputParser.allocationSize(
          value.externalInputParsers
        ) +
        FfiConverterBool.allocationSize(value.useDefaultExternalInputParsers) +
        FfiConverterOptionalString.allocationSize(value.realTimeSyncServerUrl) +
        FfiConverterBool.allocationSize(value.privateEnabledDefault)
      );
    }
  }
  return new FFIConverter();
})();

export type ConnectRequest = {
  config: Config;
  seed: Seed;
  storageDir: string;
};

/**
 * Generated factory for {@link ConnectRequest} record objects.
 */
export const ConnectRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ConnectRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ConnectRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ConnectRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ConnectRequest>,
  });
})();

const FfiConverterTypeConnectRequest = (() => {
  type TypeName = ConnectRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        config: FfiConverterTypeConfig.read(from),
        seed: FfiConverterTypeSeed.read(from),
        storageDir: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeConfig.write(value.config, into);
      FfiConverterTypeSeed.write(value.seed, into);
      FfiConverterString.write(value.storageDir, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeConfig.allocationSize(value.config) +
        FfiConverterTypeSeed.allocationSize(value.seed) +
        FfiConverterString.allocationSize(value.storageDir)
      );
    }
  }
  return new FFIConverter();
})();

export type Credentials = {
  username: string;
  password: string;
};

/**
 * Generated factory for {@link Credentials} record objects.
 */
export const Credentials = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Credentials, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Credentials}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Credentials}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Credentials>,
  });
})();

const FfiConverterTypeCredentials = (() => {
  type TypeName = Credentials;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        username: FfiConverterString.read(from),
        password: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.username, into);
      FfiConverterString.write(value.password, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.username) +
        FfiConverterString.allocationSize(value.password)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Details about a supported currency in the fiat rate feed
 */
export type CurrencyInfo = {
  name: string;
  fractionSize: /*u32*/ number;
  spacing: /*u32*/ number | undefined;
  symbol: Symbol | undefined;
  uniqSymbol: Symbol | undefined;
  localizedName: Array<LocalizedName>;
  localeOverrides: Array<LocaleOverrides>;
};

/**
 * Generated factory for {@link CurrencyInfo} record objects.
 */
export const CurrencyInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CurrencyInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CurrencyInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CurrencyInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CurrencyInfo>,
  });
})();

const FfiConverterTypeCurrencyInfo = (() => {
  type TypeName = CurrencyInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterString.read(from),
        fractionSize: FfiConverterUInt32.read(from),
        spacing: FfiConverterOptionalUInt32.read(from),
        symbol: FfiConverterOptionalTypeSymbol.read(from),
        uniqSymbol: FfiConverterOptionalTypeSymbol.read(from),
        localizedName: FfiConverterArrayTypeLocalizedName.read(from),
        localeOverrides: FfiConverterArrayTypeLocaleOverrides.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.name, into);
      FfiConverterUInt32.write(value.fractionSize, into);
      FfiConverterOptionalUInt32.write(value.spacing, into);
      FfiConverterOptionalTypeSymbol.write(value.symbol, into);
      FfiConverterOptionalTypeSymbol.write(value.uniqSymbol, into);
      FfiConverterArrayTypeLocalizedName.write(value.localizedName, into);
      FfiConverterArrayTypeLocaleOverrides.write(value.localeOverrides, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.name) +
        FfiConverterUInt32.allocationSize(value.fractionSize) +
        FfiConverterOptionalUInt32.allocationSize(value.spacing) +
        FfiConverterOptionalTypeSymbol.allocationSize(value.symbol) +
        FfiConverterOptionalTypeSymbol.allocationSize(value.uniqSymbol) +
        FfiConverterArrayTypeLocalizedName.allocationSize(value.localizedName) +
        FfiConverterArrayTypeLocaleOverrides.allocationSize(
          value.localeOverrides
        )
      );
    }
  }
  return new FFIConverter();
})();

export type DepositInfo = {
  txid: string;
  vout: /*u32*/ number;
  amountSats: /*u64*/ bigint;
  refundTx: string | undefined;
  refundTxId: string | undefined;
  claimError: DepositClaimError | undefined;
};

/**
 * Generated factory for {@link DepositInfo} record objects.
 */
export const DepositInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<DepositInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link DepositInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link DepositInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<DepositInfo>,
  });
})();

const FfiConverterTypeDepositInfo = (() => {
  type TypeName = DepositInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        amountSats: FfiConverterUInt64.read(from),
        refundTx: FfiConverterOptionalString.read(from),
        refundTxId: FfiConverterOptionalString.read(from),
        claimError: FfiConverterOptionalTypeDepositClaimError.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterUInt64.write(value.amountSats, into);
      FfiConverterOptionalString.write(value.refundTx, into);
      FfiConverterOptionalString.write(value.refundTxId, into);
      FfiConverterOptionalTypeDepositClaimError.write(value.claimError, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterUInt64.allocationSize(value.amountSats) +
        FfiConverterOptionalString.allocationSize(value.refundTx) +
        FfiConverterOptionalString.allocationSize(value.refundTxId) +
        FfiConverterOptionalTypeDepositClaimError.allocationSize(
          value.claimError
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Configuration for an external input parser
 */
export type ExternalInputParser = {
  /**
   * An arbitrary parser provider id
   */
  providerId: string;
  /**
   * The external parser will be used when an input conforms to this regex
   */
  inputRegex: string;
  /**
   * The URL of the parser containing a placeholder `<input>` that will be replaced with the
   * input to be parsed. The input is sanitized using percent encoding.
   */
  parserUrl: string;
};

/**
 * Generated factory for {@link ExternalInputParser} record objects.
 */
export const ExternalInputParser = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ExternalInputParser, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ExternalInputParser}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ExternalInputParser}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ExternalInputParser>,
  });
})();

const FfiConverterTypeExternalInputParser = (() => {
  type TypeName = ExternalInputParser;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        providerId: FfiConverterString.read(from),
        inputRegex: FfiConverterString.read(from),
        parserUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.providerId, into);
      FfiConverterString.write(value.inputRegex, into);
      FfiConverterString.write(value.parserUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.providerId) +
        FfiConverterString.allocationSize(value.inputRegex) +
        FfiConverterString.allocationSize(value.parserUrl)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Wrapper around the [`CurrencyInfo`] of a fiat currency
 */
export type FiatCurrency = {
  id: string;
  info: CurrencyInfo;
};

/**
 * Generated factory for {@link FiatCurrency} record objects.
 */
export const FiatCurrency = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FiatCurrency, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FiatCurrency}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FiatCurrency}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FiatCurrency>,
  });
})();

const FfiConverterTypeFiatCurrency = (() => {
  type TypeName = FiatCurrency;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        info: FfiConverterTypeCurrencyInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterTypeCurrencyInfo.write(value.info, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterTypeCurrencyInfo.allocationSize(value.info)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Request to get the balance of the wallet
 */
export type GetInfoRequest = {
  ensureSynced: boolean | undefined;
};

/**
 * Generated factory for {@link GetInfoRequest} record objects.
 */
export const GetInfoRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetInfoRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetInfoRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetInfoRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetInfoRequest>,
  });
})();

const FfiConverterTypeGetInfoRequest = (() => {
  type TypeName = GetInfoRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ensureSynced: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalBool.write(value.ensureSynced, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalBool.allocationSize(value.ensureSynced);
    }
  }
  return new FFIConverter();
})();

/**
 * Response containing the balance of the wallet
 */
export type GetInfoResponse = {
  /**
   * The balance in satoshis
   */
  balanceSats: /*u64*/ bigint;
  /**
   * The balances of the tokens in the wallet keyed by the token identifier
   */
  tokenBalances: Map<string, TokenBalance>;
};

/**
 * Generated factory for {@link GetInfoResponse} record objects.
 */
export const GetInfoResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetInfoResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetInfoResponse>,
  });
})();

const FfiConverterTypeGetInfoResponse = (() => {
  type TypeName = GetInfoResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        balanceSats: FfiConverterUInt64.read(from),
        tokenBalances: FfiConverterMapStringTypeTokenBalance.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.balanceSats, into);
      FfiConverterMapStringTypeTokenBalance.write(value.tokenBalances, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.balanceSats) +
        FfiConverterMapStringTypeTokenBalance.allocationSize(
          value.tokenBalances
        )
      );
    }
  }
  return new FFIConverter();
})();

export type GetPaymentRequest = {
  paymentId: string;
};

/**
 * Generated factory for {@link GetPaymentRequest} record objects.
 */
export const GetPaymentRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetPaymentRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetPaymentRequest>,
  });
})();

const FfiConverterTypeGetPaymentRequest = (() => {
  type TypeName = GetPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentId, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.paymentId);
    }
  }
  return new FFIConverter();
})();

export type GetPaymentResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link GetPaymentResponse} record objects.
 */
export const GetPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetPaymentResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetPaymentResponse>,
  });
})();

const FfiConverterTypeGetPaymentResponse = (() => {
  type TypeName = GetPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

export type GetTokensMetadataRequest = {
  tokenIdentifiers: Array<string>;
};

/**
 * Generated factory for {@link GetTokensMetadataRequest} record objects.
 */
export const GetTokensMetadataRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      GetTokensMetadataRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetTokensMetadataRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetTokensMetadataRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<GetTokensMetadataRequest>,
  });
})();

const FfiConverterTypeGetTokensMetadataRequest = (() => {
  type TypeName = GetTokensMetadataRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        tokenIdentifiers: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.tokenIdentifiers, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayString.allocationSize(value.tokenIdentifiers);
    }
  }
  return new FFIConverter();
})();

export type GetTokensMetadataResponse = {
  tokensMetadata: Array<TokenMetadata>;
};

/**
 * Generated factory for {@link GetTokensMetadataResponse} record objects.
 */
export const GetTokensMetadataResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      GetTokensMetadataResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetTokensMetadataResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetTokensMetadataResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<GetTokensMetadataResponse>,
  });
})();

const FfiConverterTypeGetTokensMetadataResponse = (() => {
  type TypeName = GetTokensMetadataResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        tokensMetadata: FfiConverterArrayTypeTokenMetadata.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeTokenMetadata.write(value.tokensMetadata, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeTokenMetadata.allocationSize(
        value.tokensMetadata
      );
    }
  }
  return new FFIConverter();
})();

export type IncomingChange = {
  newState: Record;
  oldState: Record | undefined;
};

/**
 * Generated factory for {@link IncomingChange} record objects.
 */
export const IncomingChange = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<IncomingChange, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link IncomingChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link IncomingChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<IncomingChange>,
  });
})();

const FfiConverterTypeIncomingChange = (() => {
  type TypeName = IncomingChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        newState: FfiConverterTypeRecord.read(from),
        oldState: FfiConverterOptionalTypeRecord.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRecord.write(value.newState, into);
      FfiConverterOptionalTypeRecord.write(value.oldState, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRecord.allocationSize(value.newState) +
        FfiConverterOptionalTypeRecord.allocationSize(value.oldState)
      );
    }
  }
  return new FFIConverter();
})();

export type LightningAddressDetails = {
  address: string;
  payRequest: LnurlPayRequestDetails;
};

/**
 * Generated factory for {@link LightningAddressDetails} record objects.
 */
export const LightningAddressDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LightningAddressDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LightningAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LightningAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<LightningAddressDetails>,
  });
})();

const FfiConverterTypeLightningAddressDetails = (() => {
  type TypeName = LightningAddressDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        address: FfiConverterString.read(from),
        payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.address, into);
      FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.address) +
        FfiConverterTypeLnurlPayRequestDetails.allocationSize(value.payRequest)
      );
    }
  }
  return new FFIConverter();
})();

export type LightningAddressInfo = {
  description: string;
  lightningAddress: string;
  lnurl: string;
  username: string;
};

/**
 * Generated factory for {@link LightningAddressInfo} record objects.
 */
export const LightningAddressInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LightningAddressInfo,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LightningAddressInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LightningAddressInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LightningAddressInfo>,
  });
})();

const FfiConverterTypeLightningAddressInfo = (() => {
  type TypeName = LightningAddressInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterString.read(from),
        lightningAddress: FfiConverterString.read(from),
        lnurl: FfiConverterString.read(from),
        username: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.description, into);
      FfiConverterString.write(value.lightningAddress, into);
      FfiConverterString.write(value.lnurl, into);
      FfiConverterString.write(value.username, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.lightningAddress) +
        FfiConverterString.allocationSize(value.lnurl) +
        FfiConverterString.allocationSize(value.username)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Response from listing fiat currencies
 */
export type ListFiatCurrenciesResponse = {
  /**
   * The list of fiat currencies
   */
  currencies: Array<FiatCurrency>;
};

/**
 * Generated factory for {@link ListFiatCurrenciesResponse} record objects.
 */
export const ListFiatCurrenciesResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListFiatCurrenciesResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListFiatCurrenciesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListFiatCurrenciesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ListFiatCurrenciesResponse>,
  });
})();

const FfiConverterTypeListFiatCurrenciesResponse = (() => {
  type TypeName = ListFiatCurrenciesResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        currencies: FfiConverterArrayTypeFiatCurrency.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeFiatCurrency.write(value.currencies, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeFiatCurrency.allocationSize(value.currencies);
    }
  }
  return new FFIConverter();
})();

/**
 * Response from listing fiat rates
 */
export type ListFiatRatesResponse = {
  /**
   * The list of fiat rates
   */
  rates: Array<Rate>;
};

/**
 * Generated factory for {@link ListFiatRatesResponse} record objects.
 */
export const ListFiatRatesResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListFiatRatesResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListFiatRatesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListFiatRatesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ListFiatRatesResponse>,
  });
})();

const FfiConverterTypeListFiatRatesResponse = (() => {
  type TypeName = ListFiatRatesResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        rates: FfiConverterArrayTypeRate.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeRate.write(value.rates, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeRate.allocationSize(value.rates);
    }
  }
  return new FFIConverter();
})();

/**
 * Request to list payments with optional filters and pagination
 */
export type ListPaymentsRequest = {
  typeFilter: Array<PaymentType> | undefined;
  statusFilter: Array<PaymentStatus> | undefined;
  assetFilter: AssetFilter | undefined;
  /**
   * Only include payments created after this timestamp (inclusive)
   */
  fromTimestamp: /*u64*/ bigint | undefined;
  /**
   * Only include payments created before this timestamp (exclusive)
   */
  toTimestamp: /*u64*/ bigint | undefined;
  /**
   * Number of records to skip
   */
  offset: /*u32*/ number | undefined;
  /**
   * Maximum number of records to return
   */
  limit: /*u32*/ number | undefined;
  sortAscending: boolean | undefined;
};

/**
 * Generated factory for {@link ListPaymentsRequest} record objects.
 */
export const ListPaymentsRequest = (() => {
  const defaults = () => ({
    typeFilter: undefined,
    statusFilter: undefined,
    assetFilter: undefined,
    fromTimestamp: undefined,
    toTimestamp: undefined,
    offset: undefined,
    limit: undefined,
    sortAscending: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<ListPaymentsRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListPaymentsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListPaymentsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ListPaymentsRequest>,
  });
})();

const FfiConverterTypeListPaymentsRequest = (() => {
  type TypeName = ListPaymentsRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        typeFilter: FfiConverterOptionalArrayTypePaymentType.read(from),
        statusFilter: FfiConverterOptionalArrayTypePaymentStatus.read(from),
        assetFilter: FfiConverterOptionalTypeAssetFilter.read(from),
        fromTimestamp: FfiConverterOptionalUInt64.read(from),
        toTimestamp: FfiConverterOptionalUInt64.read(from),
        offset: FfiConverterOptionalUInt32.read(from),
        limit: FfiConverterOptionalUInt32.read(from),
        sortAscending: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalArrayTypePaymentType.write(value.typeFilter, into);
      FfiConverterOptionalArrayTypePaymentStatus.write(
        value.statusFilter,
        into
      );
      FfiConverterOptionalTypeAssetFilter.write(value.assetFilter, into);
      FfiConverterOptionalUInt64.write(value.fromTimestamp, into);
      FfiConverterOptionalUInt64.write(value.toTimestamp, into);
      FfiConverterOptionalUInt32.write(value.offset, into);
      FfiConverterOptionalUInt32.write(value.limit, into);
      FfiConverterOptionalBool.write(value.sortAscending, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalArrayTypePaymentType.allocationSize(
          value.typeFilter
        ) +
        FfiConverterOptionalArrayTypePaymentStatus.allocationSize(
          value.statusFilter
        ) +
        FfiConverterOptionalTypeAssetFilter.allocationSize(value.assetFilter) +
        FfiConverterOptionalUInt64.allocationSize(value.fromTimestamp) +
        FfiConverterOptionalUInt64.allocationSize(value.toTimestamp) +
        FfiConverterOptionalUInt32.allocationSize(value.offset) +
        FfiConverterOptionalUInt32.allocationSize(value.limit) +
        FfiConverterOptionalBool.allocationSize(value.sortAscending)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Response from listing payments
 */
export type ListPaymentsResponse = {
  /**
   * The list of payments
   */
  payments: Array<Payment>;
};

/**
 * Generated factory for {@link ListPaymentsResponse} record objects.
 */
export const ListPaymentsResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListPaymentsResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListPaymentsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListPaymentsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ListPaymentsResponse>,
  });
})();

const FfiConverterTypeListPaymentsResponse = (() => {
  type TypeName = ListPaymentsResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payments: FfiConverterArrayTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypePayment.write(value.payments, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypePayment.allocationSize(value.payments);
    }
  }
  return new FFIConverter();
})();

export type ListUnclaimedDepositsRequest = {};

/**
 * Generated factory for {@link ListUnclaimedDepositsRequest} record objects.
 */
export const ListUnclaimedDepositsRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListUnclaimedDepositsRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ListUnclaimedDepositsRequest>,
  });
})();

const FfiConverterTypeListUnclaimedDepositsRequest = (() => {
  type TypeName = ListUnclaimedDepositsRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export type ListUnclaimedDepositsResponse = {
  deposits: Array<DepositInfo>;
};

/**
 * Generated factory for {@link ListUnclaimedDepositsResponse} record objects.
 */
export const ListUnclaimedDepositsResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListUnclaimedDepositsResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListUnclaimedDepositsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ListUnclaimedDepositsResponse>,
  });
})();

const FfiConverterTypeListUnclaimedDepositsResponse = (() => {
  type TypeName = ListUnclaimedDepositsResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        deposits: FfiConverterArrayTypeDepositInfo.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeDepositInfo.write(value.deposits, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeDepositInfo.allocationSize(value.deposits);
    }
  }
  return new FFIConverter();
})();

/**
 * Wrapped in a [`LnurlAuth`], this is the result of [`parse`] when given a LNURL-auth endpoint.
 *
 * It represents the endpoint's parameters for the LNURL workflow.
 *
 * See <https://github.com/lnurl/luds/blob/luds/04.md>
 */
export type LnurlAuthRequestDetails = {
  /**
   * Hex encoded 32 bytes of challenge
   */
  k1: string;
  /**
   * When available, one of: register, login, link, auth
   */
  action: string | undefined;
  /**
   * Indicates the domain of the LNURL-auth service, to be shown to the user when asking for
   * auth confirmation, as per LUD-04 spec.
   */
  domain: string;
  /**
   * Indicates the URL of the LNURL-auth service, including the query arguments. This will be
   * extended with the signed challenge and the linking key, then called in the second step of the workflow.
   */
  url: string;
};

/**
 * Generated factory for {@link LnurlAuthRequestDetails} record objects.
 */
export const LnurlAuthRequestDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LnurlAuthRequestDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlAuthRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlAuthRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<LnurlAuthRequestDetails>,
  });
})();

const FfiConverterTypeLnurlAuthRequestDetails = (() => {
  type TypeName = LnurlAuthRequestDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        k1: FfiConverterString.read(from),
        action: FfiConverterOptionalString.read(from),
        domain: FfiConverterString.read(from),
        url: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.k1, into);
      FfiConverterOptionalString.write(value.action, into);
      FfiConverterString.write(value.domain, into);
      FfiConverterString.write(value.url, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.k1) +
        FfiConverterOptionalString.allocationSize(value.action) +
        FfiConverterString.allocationSize(value.domain) +
        FfiConverterString.allocationSize(value.url)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Represents the payment LNURL info
 */
export type LnurlPayInfo = {
  lnAddress: string | undefined;
  comment: string | undefined;
  domain: string | undefined;
  metadata: string | undefined;
  processedSuccessAction: SuccessActionProcessed | undefined;
  rawSuccessAction: SuccessAction | undefined;
};

/**
 * Generated factory for {@link LnurlPayInfo} record objects.
 */
export const LnurlPayInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnurlPayInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlPayInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlPayInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlPayInfo>,
  });
})();

const FfiConverterTypeLnurlPayInfo = (() => {
  type TypeName = LnurlPayInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lnAddress: FfiConverterOptionalString.read(from),
        comment: FfiConverterOptionalString.read(from),
        domain: FfiConverterOptionalString.read(from),
        metadata: FfiConverterOptionalString.read(from),
        processedSuccessAction:
          FfiConverterOptionalTypeSuccessActionProcessed.read(from),
        rawSuccessAction: FfiConverterOptionalTypeSuccessAction.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.lnAddress, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterOptionalString.write(value.domain, into);
      FfiConverterOptionalString.write(value.metadata, into);
      FfiConverterOptionalTypeSuccessActionProcessed.write(
        value.processedSuccessAction,
        into
      );
      FfiConverterOptionalTypeSuccessAction.write(value.rawSuccessAction, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.lnAddress) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterOptionalString.allocationSize(value.domain) +
        FfiConverterOptionalString.allocationSize(value.metadata) +
        FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(
          value.processedSuccessAction
        ) +
        FfiConverterOptionalTypeSuccessAction.allocationSize(
          value.rawSuccessAction
        )
      );
    }
  }
  return new FFIConverter();
})();

export type LnurlPayRequest = {
  prepareResponse: PrepareLnurlPayResponse;
};

/**
 * Generated factory for {@link LnurlPayRequest} record objects.
 */
export const LnurlPayRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnurlPayRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlPayRequest>,
  });
})();

const FfiConverterTypeLnurlPayRequest = (() => {
  type TypeName = LnurlPayRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prepareResponse: FfiConverterTypePrepareLnurlPayResponse.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePrepareLnurlPayResponse.write(
        value.prepareResponse,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePrepareLnurlPayResponse.allocationSize(
        value.prepareResponse
      );
    }
  }
  return new FFIConverter();
})();

export type LnurlPayRequestDetails = {
  callback: string;
  /**
   * The minimum amount, in millisats, that this LNURL-pay endpoint accepts
   */
  minSendable: /*u64*/ bigint;
  /**
   * The maximum amount, in millisats, that this LNURL-pay endpoint accepts
   */
  maxSendable: /*u64*/ bigint;
  /**
   * As per LUD-06, `metadata` is a raw string (e.g. a json representation of the inner map).
   * Use `metadata_vec()` to get the parsed items.
   */
  metadataStr: string;
  /**
   * The comment length accepted by this endpoint
   *
   * See <https://github.com/lnurl/luds/blob/luds/12.md>
   */
  commentAllowed: /*u16*/ number;
  /**
   * Indicates the domain of the LNURL-pay service, to be shown to the user when asking for
   * payment input, as per LUD-06 spec.
   *
   * Note: this is not the domain of the callback, but the domain of the LNURL-pay endpoint.
   */
  domain: string;
  url: string;
  /**
   * Optional lightning address if that was used to resolve the lnurl.
   */
  address: string | undefined;
  /**
   * Value indicating whether the recipient supports Nostr Zaps through NIP-57.
   *
   * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
   */
  allowsNostr: boolean | undefined;
  /**
   * Optional recipient's lnurl provider's Nostr pubkey for NIP-57. If it exists it should be a
   * valid BIP 340 public key in hex.
   *
   * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
   * See <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
   */
  nostrPubkey: string | undefined;
};

/**
 * Generated factory for {@link LnurlPayRequestDetails} record objects.
 */
export const LnurlPayRequestDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LnurlPayRequestDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlPayRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlPayRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<LnurlPayRequestDetails>,
  });
})();

const FfiConverterTypeLnurlPayRequestDetails = (() => {
  type TypeName = LnurlPayRequestDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        callback: FfiConverterString.read(from),
        minSendable: FfiConverterUInt64.read(from),
        maxSendable: FfiConverterUInt64.read(from),
        metadataStr: FfiConverterString.read(from),
        commentAllowed: FfiConverterUInt16.read(from),
        domain: FfiConverterString.read(from),
        url: FfiConverterString.read(from),
        address: FfiConverterOptionalString.read(from),
        allowsNostr: FfiConverterOptionalBool.read(from),
        nostrPubkey: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.callback, into);
      FfiConverterUInt64.write(value.minSendable, into);
      FfiConverterUInt64.write(value.maxSendable, into);
      FfiConverterString.write(value.metadataStr, into);
      FfiConverterUInt16.write(value.commentAllowed, into);
      FfiConverterString.write(value.domain, into);
      FfiConverterString.write(value.url, into);
      FfiConverterOptionalString.write(value.address, into);
      FfiConverterOptionalBool.write(value.allowsNostr, into);
      FfiConverterOptionalString.write(value.nostrPubkey, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.callback) +
        FfiConverterUInt64.allocationSize(value.minSendable) +
        FfiConverterUInt64.allocationSize(value.maxSendable) +
        FfiConverterString.allocationSize(value.metadataStr) +
        FfiConverterUInt16.allocationSize(value.commentAllowed) +
        FfiConverterString.allocationSize(value.domain) +
        FfiConverterString.allocationSize(value.url) +
        FfiConverterOptionalString.allocationSize(value.address) +
        FfiConverterOptionalBool.allocationSize(value.allowsNostr) +
        FfiConverterOptionalString.allocationSize(value.nostrPubkey)
      );
    }
  }
  return new FFIConverter();
})();

export type LnurlPayResponse = {
  payment: Payment;
  successAction: SuccessActionProcessed | undefined;
};

/**
 * Generated factory for {@link LnurlPayResponse} record objects.
 */
export const LnurlPayResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnurlPayResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlPayResponse>,
  });
})();

const FfiConverterTypeLnurlPayResponse = (() => {
  type TypeName = LnurlPayResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
        successAction:
          FfiConverterOptionalTypeSuccessActionProcessed.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
      FfiConverterOptionalTypeSuccessActionProcessed.write(
        value.successAction,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePayment.allocationSize(value.payment) +
        FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(
          value.successAction
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Represents the withdraw LNURL info
 */
export type LnurlWithdrawInfo = {
  withdrawUrl: string;
};

/**
 * Generated factory for {@link LnurlWithdrawInfo} record objects.
 */
export const LnurlWithdrawInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LnurlWithdrawInfo, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlWithdrawInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlWithdrawInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlWithdrawInfo>,
  });
})();

const FfiConverterTypeLnurlWithdrawInfo = (() => {
  type TypeName = LnurlWithdrawInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        withdrawUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.withdrawUrl, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.withdrawUrl);
    }
  }
  return new FFIConverter();
})();

export type LnurlWithdrawRequest = {
  /**
   * The amount to withdraw in satoshis
   * Must be within the min and max withdrawable limits
   */
  amountSats: /*u64*/ bigint;
  withdrawRequest: LnurlWithdrawRequestDetails;
  /**
   * If set, the function will return the payment if it is still pending after this
   * number of seconds. If unset, the function will return immediately after
   * initiating the LNURL withdraw.
   */
  completionTimeoutSecs: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link LnurlWithdrawRequest} record objects.
 */
export const LnurlWithdrawRequest = (() => {
  const defaults = () => ({ completionTimeoutSecs: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      LnurlWithdrawRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlWithdrawRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlWithdrawRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlWithdrawRequest>,
  });
})();

const FfiConverterTypeLnurlWithdrawRequest = (() => {
  type TypeName = LnurlWithdrawRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amountSats: FfiConverterUInt64.read(from),
        withdrawRequest: FfiConverterTypeLnurlWithdrawRequestDetails.read(from),
        completionTimeoutSecs: FfiConverterOptionalUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.amountSats, into);
      FfiConverterTypeLnurlWithdrawRequestDetails.write(
        value.withdrawRequest,
        into
      );
      FfiConverterOptionalUInt32.write(value.completionTimeoutSecs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.amountSats) +
        FfiConverterTypeLnurlWithdrawRequestDetails.allocationSize(
          value.withdrawRequest
        ) +
        FfiConverterOptionalUInt32.allocationSize(value.completionTimeoutSecs)
      );
    }
  }
  return new FFIConverter();
})();

export type LnurlWithdrawRequestDetails = {
  callback: string;
  k1: string;
  defaultDescription: string;
  /**
   * The minimum amount, in millisats, that this LNURL-withdraw endpoint accepts
   */
  minWithdrawable: /*u64*/ bigint;
  /**
   * The maximum amount, in millisats, that this LNURL-withdraw endpoint accepts
   */
  maxWithdrawable: /*u64*/ bigint;
};

/**
 * Generated factory for {@link LnurlWithdrawRequestDetails} record objects.
 */
export const LnurlWithdrawRequestDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LnurlWithdrawRequestDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlWithdrawRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlWithdrawRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<LnurlWithdrawRequestDetails>,
  });
})();

const FfiConverterTypeLnurlWithdrawRequestDetails = (() => {
  type TypeName = LnurlWithdrawRequestDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        callback: FfiConverterString.read(from),
        k1: FfiConverterString.read(from),
        defaultDescription: FfiConverterString.read(from),
        minWithdrawable: FfiConverterUInt64.read(from),
        maxWithdrawable: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.callback, into);
      FfiConverterString.write(value.k1, into);
      FfiConverterString.write(value.defaultDescription, into);
      FfiConverterUInt64.write(value.minWithdrawable, into);
      FfiConverterUInt64.write(value.maxWithdrawable, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.callback) +
        FfiConverterString.allocationSize(value.k1) +
        FfiConverterString.allocationSize(value.defaultDescription) +
        FfiConverterUInt64.allocationSize(value.minWithdrawable) +
        FfiConverterUInt64.allocationSize(value.maxWithdrawable)
      );
    }
  }
  return new FFIConverter();
})();

export type LnurlWithdrawResponse = {
  /**
   * The Lightning invoice generated for the LNURL withdraw
   */
  paymentRequest: string;
  payment: Payment | undefined;
};

/**
 * Generated factory for {@link LnurlWithdrawResponse} record objects.
 */
export const LnurlWithdrawResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LnurlWithdrawResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LnurlWithdrawResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LnurlWithdrawResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LnurlWithdrawResponse>,
  });
})();

const FfiConverterTypeLnurlWithdrawResponse = (() => {
  type TypeName = LnurlWithdrawResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentRequest: FfiConverterString.read(from),
        payment: FfiConverterOptionalTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentRequest, into);
      FfiConverterOptionalTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.paymentRequest) +
        FfiConverterOptionalTypePayment.allocationSize(value.payment)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Locale-specific settings for the representation of a currency
 */
export type LocaleOverrides = {
  locale: string;
  spacing: /*u32*/ number | undefined;
  symbol: Symbol;
};

/**
 * Generated factory for {@link LocaleOverrides} record objects.
 */
export const LocaleOverrides = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LocaleOverrides, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LocaleOverrides}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LocaleOverrides}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LocaleOverrides>,
  });
})();

const FfiConverterTypeLocaleOverrides = (() => {
  type TypeName = LocaleOverrides;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        locale: FfiConverterString.read(from),
        spacing: FfiConverterOptionalUInt32.read(from),
        symbol: FfiConverterTypeSymbol.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.locale, into);
      FfiConverterOptionalUInt32.write(value.spacing, into);
      FfiConverterTypeSymbol.write(value.symbol, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.locale) +
        FfiConverterOptionalUInt32.allocationSize(value.spacing) +
        FfiConverterTypeSymbol.allocationSize(value.symbol)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Localized name of a currency
 */
export type LocalizedName = {
  locale: string;
  name: string;
};

/**
 * Generated factory for {@link LocalizedName} record objects.
 */
export const LocalizedName = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LocalizedName, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LocalizedName}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LocalizedName}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LocalizedName>,
  });
})();

const FfiConverterTypeLocalizedName = (() => {
  type TypeName = LocalizedName;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        locale: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.locale, into);
      FfiConverterString.write(value.name, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.locale) +
        FfiConverterString.allocationSize(value.name)
      );
    }
  }
  return new FFIConverter();
})();

export type LogEntry = {
  line: string;
  level: string;
};

/**
 * Generated factory for {@link LogEntry} record objects.
 */
export const LogEntry = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LogEntry, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LogEntry}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LogEntry}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LogEntry>,
  });
})();

const FfiConverterTypeLogEntry = (() => {
  type TypeName = LogEntry;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        line: FfiConverterString.read(from),
        level: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.line, into);
      FfiConverterString.write(value.level, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.line) +
        FfiConverterString.allocationSize(value.level)
      );
    }
  }
  return new FFIConverter();
})();

export type MessageSuccessActionData = {
  message: string;
};

/**
 * Generated factory for {@link MessageSuccessActionData} record objects.
 */
export const MessageSuccessActionData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      MessageSuccessActionData,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MessageSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MessageSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<MessageSuccessActionData>,
  });
})();

const FfiConverterTypeMessageSuccessActionData = (() => {
  type TypeName = MessageSuccessActionData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        message: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.message, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.message);
    }
  }
  return new FFIConverter();
})();

export type OutgoingChange = {
  change: RecordChange;
  parent: Record | undefined;
};

/**
 * Generated factory for {@link OutgoingChange} record objects.
 */
export const OutgoingChange = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<OutgoingChange, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link OutgoingChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link OutgoingChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<OutgoingChange>,
  });
})();

const FfiConverterTypeOutgoingChange = (() => {
  type TypeName = OutgoingChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        change: FfiConverterTypeRecordChange.read(from),
        parent: FfiConverterOptionalTypeRecord.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRecordChange.write(value.change, into);
      FfiConverterOptionalTypeRecord.write(value.parent, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRecordChange.allocationSize(value.change) +
        FfiConverterOptionalTypeRecord.allocationSize(value.parent)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Represents a payment (sent or received)
 */
export type Payment = {
  /**
   * Unique identifier for the payment
   */
  id: string;
  /**
   * Type of payment (send or receive)
   */
  paymentType: PaymentType;
  /**
   * Status of the payment
   */
  status: PaymentStatus;
  /**
   * Amount in satoshis or token base units
   */
  amount: U128;
  /**
   * Fee paid in satoshis or token base units
   */
  fees: U128;
  /**
   * Timestamp of when the payment was created
   */
  timestamp: /*u64*/ bigint;
  /**
   * Method of payment. Sometimes the payment details is empty so this field
   * is used to determine the payment method.
   */
  method: PaymentMethod;
  /**
   * Details of the payment
   */
  details: PaymentDetails | undefined;
};

/**
 * Generated factory for {@link Payment} record objects.
 */
export const Payment = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Payment, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Payment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Payment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Payment>,
  });
})();

const FfiConverterTypePayment = (() => {
  type TypeName = Payment;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        paymentType: FfiConverterTypePaymentType.read(from),
        status: FfiConverterTypePaymentStatus.read(from),
        amount: FfiConverterTypeu128.read(from),
        fees: FfiConverterTypeu128.read(from),
        timestamp: FfiConverterUInt64.read(from),
        method: FfiConverterTypePaymentMethod.read(from),
        details: FfiConverterOptionalTypePaymentDetails.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterTypePaymentType.write(value.paymentType, into);
      FfiConverterTypePaymentStatus.write(value.status, into);
      FfiConverterTypeu128.write(value.amount, into);
      FfiConverterTypeu128.write(value.fees, into);
      FfiConverterUInt64.write(value.timestamp, into);
      FfiConverterTypePaymentMethod.write(value.method, into);
      FfiConverterOptionalTypePaymentDetails.write(value.details, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterTypePaymentType.allocationSize(value.paymentType) +
        FfiConverterTypePaymentStatus.allocationSize(value.status) +
        FfiConverterTypeu128.allocationSize(value.amount) +
        FfiConverterTypeu128.allocationSize(value.fees) +
        FfiConverterUInt64.allocationSize(value.timestamp) +
        FfiConverterTypePaymentMethod.allocationSize(value.method) +
        FfiConverterOptionalTypePaymentDetails.allocationSize(value.details)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Metadata associated with a payment that cannot be extracted from the Spark operator.
 */
export type PaymentMetadata = {
  lnurlPayInfo: LnurlPayInfo | undefined;
  lnurlWithdrawInfo: LnurlWithdrawInfo | undefined;
  lnurlDescription: string | undefined;
};

/**
 * Generated factory for {@link PaymentMetadata} record objects.
 */
export const PaymentMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PaymentMetadata, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PaymentMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PaymentMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PaymentMetadata>,
  });
})();

const FfiConverterTypePaymentMetadata = (() => {
  type TypeName = PaymentMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lnurlPayInfo: FfiConverterOptionalTypeLnurlPayInfo.read(from),
        lnurlWithdrawInfo: FfiConverterOptionalTypeLnurlWithdrawInfo.read(from),
        lnurlDescription: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeLnurlPayInfo.write(value.lnurlPayInfo, into);
      FfiConverterOptionalTypeLnurlWithdrawInfo.write(
        value.lnurlWithdrawInfo,
        into
      );
      FfiConverterOptionalString.write(value.lnurlDescription, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeLnurlPayInfo.allocationSize(
          value.lnurlPayInfo
        ) +
        FfiConverterOptionalTypeLnurlWithdrawInfo.allocationSize(
          value.lnurlWithdrawInfo
        ) +
        FfiConverterOptionalString.allocationSize(value.lnurlDescription)
      );
    }
  }
  return new FFIConverter();
})();

export type PaymentRequestSource = {
  bip21Uri: string | undefined;
  bip353Address: string | undefined;
};

/**
 * Generated factory for {@link PaymentRequestSource} record objects.
 */
export const PaymentRequestSource = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PaymentRequestSource,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PaymentRequestSource}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PaymentRequestSource}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PaymentRequestSource>,
  });
})();

const FfiConverterTypePaymentRequestSource = (() => {
  type TypeName = PaymentRequestSource;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        bip21Uri: FfiConverterOptionalString.read(from),
        bip353Address: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.bip21Uri, into);
      FfiConverterOptionalString.write(value.bip353Address, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.bip21Uri) +
        FfiConverterOptionalString.allocationSize(value.bip353Address)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareLnurlPayRequest = {
  amountSats: /*u64*/ bigint;
  payRequest: LnurlPayRequestDetails;
  comment: string | undefined;
  validateSuccessActionUrl: boolean | undefined;
};

/**
 * Generated factory for {@link PrepareLnurlPayRequest} record objects.
 */
export const PrepareLnurlPayRequest = (() => {
  const defaults = () => ({
    comment: undefined,
    validateSuccessActionUrl: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<
      PrepareLnurlPayRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareLnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareLnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareLnurlPayRequest>,
  });
})();

const FfiConverterTypePrepareLnurlPayRequest = (() => {
  type TypeName = PrepareLnurlPayRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amountSats: FfiConverterUInt64.read(from),
        payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from),
        comment: FfiConverterOptionalString.read(from),
        validateSuccessActionUrl: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.amountSats, into);
      FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterOptionalBool.write(value.validateSuccessActionUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.amountSats) +
        FfiConverterTypeLnurlPayRequestDetails.allocationSize(
          value.payRequest
        ) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterOptionalBool.allocationSize(value.validateSuccessActionUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareLnurlPayResponse = {
  amountSats: /*u64*/ bigint;
  comment: string | undefined;
  payRequest: LnurlPayRequestDetails;
  feeSats: /*u64*/ bigint;
  invoiceDetails: Bolt11InvoiceDetails;
  successAction: SuccessAction | undefined;
};

/**
 * Generated factory for {@link PrepareLnurlPayResponse} record objects.
 */
export const PrepareLnurlPayResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PrepareLnurlPayResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareLnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareLnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareLnurlPayResponse>,
  });
})();

const FfiConverterTypePrepareLnurlPayResponse = (() => {
  type TypeName = PrepareLnurlPayResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amountSats: FfiConverterUInt64.read(from),
        comment: FfiConverterOptionalString.read(from),
        payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from),
        feeSats: FfiConverterUInt64.read(from),
        invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.read(from),
        successAction: FfiConverterOptionalTypeSuccessAction.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.amountSats, into);
      FfiConverterOptionalString.write(value.comment, into);
      FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into);
      FfiConverterUInt64.write(value.feeSats, into);
      FfiConverterTypeBolt11InvoiceDetails.write(value.invoiceDetails, into);
      FfiConverterOptionalTypeSuccessAction.write(value.successAction, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.amountSats) +
        FfiConverterOptionalString.allocationSize(value.comment) +
        FfiConverterTypeLnurlPayRequestDetails.allocationSize(
          value.payRequest
        ) +
        FfiConverterUInt64.allocationSize(value.feeSats) +
        FfiConverterTypeBolt11InvoiceDetails.allocationSize(
          value.invoiceDetails
        ) +
        FfiConverterOptionalTypeSuccessAction.allocationSize(
          value.successAction
        )
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareSendPaymentRequest = {
  paymentRequest: string;
  /**
   * Amount to send. By default is denominated in sats.
   * If a token identifier is provided, the amount will be denominated in the token base units.
   */
  amount: U128 | undefined;
  /**
   * If provided, the payment will be for a token
   * May only be provided if the payment request is a spark address
   */
  tokenIdentifier: string | undefined;
};

/**
 * Generated factory for {@link PrepareSendPaymentRequest} record objects.
 */
export const PrepareSendPaymentRequest = (() => {
  const defaults = () => ({ amount: undefined, tokenIdentifier: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      PrepareSendPaymentRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareSendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareSendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareSendPaymentRequest>,
  });
})();

const FfiConverterTypePrepareSendPaymentRequest = (() => {
  type TypeName = PrepareSendPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentRequest: FfiConverterString.read(from),
        amount: FfiConverterOptionalTypeu128.read(from),
        tokenIdentifier: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentRequest, into);
      FfiConverterOptionalTypeu128.write(value.amount, into);
      FfiConverterOptionalString.write(value.tokenIdentifier, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.paymentRequest) +
        FfiConverterOptionalTypeu128.allocationSize(value.amount) +
        FfiConverterOptionalString.allocationSize(value.tokenIdentifier)
      );
    }
  }
  return new FFIConverter();
})();

export type PrepareSendPaymentResponse = {
  paymentMethod: SendPaymentMethod;
  /**
   * Amount to send. By default is denominated in sats.
   * If a token identifier is provided, the amount will be denominated in the token base units.
   */
  amount: U128;
  /**
   * The presence of this field indicates that the payment is for a token
   * If empty, it is a Bitcoin payment
   */
  tokenIdentifier: string | undefined;
};

/**
 * Generated factory for {@link PrepareSendPaymentResponse} record objects.
 */
export const PrepareSendPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PrepareSendPaymentResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PrepareSendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PrepareSendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PrepareSendPaymentResponse>,
  });
})();

const FfiConverterTypePrepareSendPaymentResponse = (() => {
  type TypeName = PrepareSendPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentMethod: FfiConverterTypeSendPaymentMethod.read(from),
        amount: FfiConverterTypeu128.read(from),
        tokenIdentifier: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeSendPaymentMethod.write(value.paymentMethod, into);
      FfiConverterTypeu128.write(value.amount, into);
      FfiConverterOptionalString.write(value.tokenIdentifier, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeSendPaymentMethod.allocationSize(value.paymentMethod) +
        FfiConverterTypeu128.allocationSize(value.amount) +
        FfiConverterOptionalString.allocationSize(value.tokenIdentifier)
      );
    }
  }
  return new FFIConverter();
})();

export type ProvisionalPayment = {
  /**
   * Unique identifier for the payment
   */
  paymentId: string;
  /**
   * Amount in satoshis or token base units
   */
  amount: U128;
  /**
   * Details of the payment
   */
  details: ProvisionalPaymentDetails;
};

/**
 * Generated factory for {@link ProvisionalPayment} record objects.
 */
export const ProvisionalPayment = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ProvisionalPayment, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ProvisionalPayment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ProvisionalPayment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ProvisionalPayment>,
  });
})();

const FfiConverterTypeProvisionalPayment = (() => {
  type TypeName = ProvisionalPayment;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentId: FfiConverterString.read(from),
        amount: FfiConverterTypeu128.read(from),
        details: FfiConverterTypeProvisionalPaymentDetails.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentId, into);
      FfiConverterTypeu128.write(value.amount, into);
      FfiConverterTypeProvisionalPaymentDetails.write(value.details, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.paymentId) +
        FfiConverterTypeu128.allocationSize(value.amount) +
        FfiConverterTypeProvisionalPaymentDetails.allocationSize(value.details)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Denominator in an exchange rate
 */
export type Rate = {
  coin: string;
  value: /*f64*/ number;
};

/**
 * Generated factory for {@link Rate} record objects.
 */
export const Rate = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Rate, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Rate}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Rate}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Rate>,
  });
})();

const FfiConverterTypeRate = (() => {
  type TypeName = Rate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        coin: FfiConverterString.read(from),
        value: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.coin, into);
      FfiConverterFloat64.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.coin) +
        FfiConverterFloat64.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

export type ReceivePaymentRequest = {
  paymentMethod: ReceivePaymentMethod;
};

/**
 * Generated factory for {@link ReceivePaymentRequest} record objects.
 */
export const ReceivePaymentRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ReceivePaymentRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReceivePaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReceivePaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ReceivePaymentRequest>,
  });
})();

const FfiConverterTypeReceivePaymentRequest = (() => {
  type TypeName = ReceivePaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentMethod: FfiConverterTypeReceivePaymentMethod.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeReceivePaymentMethod.write(value.paymentMethod, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeReceivePaymentMethod.allocationSize(
        value.paymentMethod
      );
    }
  }
  return new FFIConverter();
})();

export type ReceivePaymentResponse = {
  paymentRequest: string;
  /**
   * Fee to pay to receive the payment
   * Denominated in sats or token base units
   */
  fee: U128;
};

/**
 * Generated factory for {@link ReceivePaymentResponse} record objects.
 */
export const ReceivePaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ReceivePaymentResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReceivePaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReceivePaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ReceivePaymentResponse>,
  });
})();

const FfiConverterTypeReceivePaymentResponse = (() => {
  type TypeName = ReceivePaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentRequest: FfiConverterString.read(from),
        fee: FfiConverterTypeu128.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.paymentRequest, into);
      FfiConverterTypeu128.write(value.fee, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.paymentRequest) +
        FfiConverterTypeu128.allocationSize(value.fee)
      );
    }
  }
  return new FFIConverter();
})();

export type Record = {
  id: RecordId;
  revision: /*u64*/ bigint;
  schemaVersion: string;
  data: Map<string, string>;
};

/**
 * Generated factory for {@link Record} record objects.
 */
export const Record = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Record, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Record}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Record}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Record>,
  });
})();

const FfiConverterTypeRecord = (() => {
  type TypeName = Record;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterTypeRecordId.read(from),
        revision: FfiConverterUInt64.read(from),
        schemaVersion: FfiConverterString.read(from),
        data: FfiConverterMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRecordId.write(value.id, into);
      FfiConverterUInt64.write(value.revision, into);
      FfiConverterString.write(value.schemaVersion, into);
      FfiConverterMapStringString.write(value.data, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRecordId.allocationSize(value.id) +
        FfiConverterUInt64.allocationSize(value.revision) +
        FfiConverterString.allocationSize(value.schemaVersion) +
        FfiConverterMapStringString.allocationSize(value.data)
      );
    }
  }
  return new FFIConverter();
})();

export type RecordChange = {
  id: RecordId;
  schemaVersion: string;
  updatedFields: Map<string, string>;
  revision: /*u64*/ bigint;
};

/**
 * Generated factory for {@link RecordChange} record objects.
 */
export const RecordChange = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RecordChange, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RecordChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RecordChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RecordChange>,
  });
})();

const FfiConverterTypeRecordChange = (() => {
  type TypeName = RecordChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterTypeRecordId.read(from),
        schemaVersion: FfiConverterString.read(from),
        updatedFields: FfiConverterMapStringString.read(from),
        revision: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRecordId.write(value.id, into);
      FfiConverterString.write(value.schemaVersion, into);
      FfiConverterMapStringString.write(value.updatedFields, into);
      FfiConverterUInt64.write(value.revision, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRecordId.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.schemaVersion) +
        FfiConverterMapStringString.allocationSize(value.updatedFields) +
        FfiConverterUInt64.allocationSize(value.revision)
      );
    }
  }
  return new FFIConverter();
})();

export type RecordId = {
  type: string;
  dataId: string;
};

/**
 * Generated factory for {@link RecordId} record objects.
 */
export const RecordId = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RecordId, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RecordId}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RecordId}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RecordId>,
  });
})();

const FfiConverterTypeRecordId = (() => {
  type TypeName = RecordId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        type: FfiConverterString.read(from),
        dataId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.type, into);
      FfiConverterString.write(value.dataId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.type) +
        FfiConverterString.allocationSize(value.dataId)
      );
    }
  }
  return new FFIConverter();
})();

export type RefundDepositRequest = {
  txid: string;
  vout: /*u32*/ number;
  destinationAddress: string;
  fee: Fee;
};

/**
 * Generated factory for {@link RefundDepositRequest} record objects.
 */
export const RefundDepositRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RefundDepositRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RefundDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RefundDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RefundDepositRequest>,
  });
})();

const FfiConverterTypeRefundDepositRequest = (() => {
  type TypeName = RefundDepositRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        destinationAddress: FfiConverterString.read(from),
        fee: FfiConverterTypeFee.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterString.write(value.destinationAddress, into);
      FfiConverterTypeFee.write(value.fee, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterString.allocationSize(value.destinationAddress) +
        FfiConverterTypeFee.allocationSize(value.fee)
      );
    }
  }
  return new FFIConverter();
})();

export type RefundDepositResponse = {
  txId: string;
  txHex: string;
};

/**
 * Generated factory for {@link RefundDepositResponse} record objects.
 */
export const RefundDepositResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      RefundDepositResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RefundDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RefundDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RefundDepositResponse>,
  });
})();

const FfiConverterTypeRefundDepositResponse = (() => {
  type TypeName = RefundDepositResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txId: FfiConverterString.read(from),
        txHex: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txId, into);
      FfiConverterString.write(value.txHex, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txId) +
        FfiConverterString.allocationSize(value.txHex)
      );
    }
  }
  return new FFIConverter();
})();

export type RegisterLightningAddressRequest = {
  username: string;
  description: string | undefined;
};

/**
 * Generated factory for {@link RegisterLightningAddressRequest} record objects.
 */
export const RegisterLightningAddressRequest = (() => {
  const defaults = () => ({ description: undefined });
  const create = (() => {
    return uniffiCreateRecord<
      RegisterLightningAddressRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RegisterLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RegisterLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<RegisterLightningAddressRequest>,
  });
})();

const FfiConverterTypeRegisterLightningAddressRequest = (() => {
  type TypeName = RegisterLightningAddressRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        username: FfiConverterString.read(from),
        description: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.username, into);
      FfiConverterOptionalString.write(value.description, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.username) +
        FfiConverterOptionalString.allocationSize(value.description)
      );
    }
  }
  return new FFIConverter();
})();

export type RestResponse = {
  status: /*u16*/ number;
  body: string;
};

/**
 * Generated factory for {@link RestResponse} record objects.
 */
export const RestResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RestResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RestResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RestResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RestResponse>,
  });
})();

const FfiConverterTypeRestResponse = (() => {
  type TypeName = RestResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        status: FfiConverterUInt16.read(from),
        body: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt16.write(value.status, into);
      FfiConverterString.write(value.body, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt16.allocationSize(value.status) +
        FfiConverterString.allocationSize(value.body)
      );
    }
  }
  return new FFIConverter();
})();

export type SendOnchainFeeQuote = {
  id: string;
  expiresAt: /*u64*/ bigint;
  speedFast: SendOnchainSpeedFeeQuote;
  speedMedium: SendOnchainSpeedFeeQuote;
  speedSlow: SendOnchainSpeedFeeQuote;
};

/**
 * Generated factory for {@link SendOnchainFeeQuote} record objects.
 */
export const SendOnchainFeeQuote = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SendOnchainFeeQuote, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendOnchainFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendOnchainFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendOnchainFeeQuote>,
  });
})();

const FfiConverterTypeSendOnchainFeeQuote = (() => {
  type TypeName = SendOnchainFeeQuote;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        expiresAt: FfiConverterUInt64.read(from),
        speedFast: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),
        speedMedium: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),
        speedSlow: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterUInt64.write(value.expiresAt, into);
      FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedFast, into);
      FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedMedium, into);
      FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedSlow, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterUInt64.allocationSize(value.expiresAt) +
        FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(
          value.speedFast
        ) +
        FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(
          value.speedMedium
        ) +
        FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(value.speedSlow)
      );
    }
  }
  return new FFIConverter();
})();

export type SendOnchainSpeedFeeQuote = {
  userFeeSat: /*u64*/ bigint;
  l1BroadcastFeeSat: /*u64*/ bigint;
};

/**
 * Generated factory for {@link SendOnchainSpeedFeeQuote} record objects.
 */
export const SendOnchainSpeedFeeQuote = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SendOnchainSpeedFeeQuote,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendOnchainSpeedFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendOnchainSpeedFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<SendOnchainSpeedFeeQuote>,
  });
})();

const FfiConverterTypeSendOnchainSpeedFeeQuote = (() => {
  type TypeName = SendOnchainSpeedFeeQuote;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        userFeeSat: FfiConverterUInt64.read(from),
        l1BroadcastFeeSat: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.userFeeSat, into);
      FfiConverterUInt64.write(value.l1BroadcastFeeSat, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.userFeeSat) +
        FfiConverterUInt64.allocationSize(value.l1BroadcastFeeSat)
      );
    }
  }
  return new FFIConverter();
})();

export type SendPaymentRequest = {
  prepareResponse: PrepareSendPaymentResponse;
  options: SendPaymentOptions | undefined;
};

/**
 * Generated factory for {@link SendPaymentRequest} record objects.
 */
export const SendPaymentRequest = (() => {
  const defaults = () => ({ options: undefined });
  const create = (() => {
    return uniffiCreateRecord<SendPaymentRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendPaymentRequest>,
  });
})();

const FfiConverterTypeSendPaymentRequest = (() => {
  type TypeName = SendPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prepareResponse: FfiConverterTypePrepareSendPaymentResponse.read(from),
        options: FfiConverterOptionalTypeSendPaymentOptions.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePrepareSendPaymentResponse.write(
        value.prepareResponse,
        into
      );
      FfiConverterOptionalTypeSendPaymentOptions.write(value.options, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePrepareSendPaymentResponse.allocationSize(
          value.prepareResponse
        ) +
        FfiConverterOptionalTypeSendPaymentOptions.allocationSize(value.options)
      );
    }
  }
  return new FFIConverter();
})();

export type SendPaymentResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link SendPaymentResponse} record objects.
 */
export const SendPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SendPaymentResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendPaymentResponse>,
  });
})();

const FfiConverterTypeSendPaymentResponse = (() => {
  type TypeName = SendPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

export type SignMessageRequest = {
  message: string;
  /**
   * If true, the signature will be encoded in compact format instead of DER format
   */
  compact: boolean;
};

/**
 * Generated factory for {@link SignMessageRequest} record objects.
 */
export const SignMessageRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SignMessageRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SignMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SignMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SignMessageRequest>,
  });
})();

const FfiConverterTypeSignMessageRequest = (() => {
  type TypeName = SignMessageRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        message: FfiConverterString.read(from),
        compact: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.message, into);
      FfiConverterBool.write(value.compact, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.message) +
        FfiConverterBool.allocationSize(value.compact)
      );
    }
  }
  return new FFIConverter();
})();

export type SignMessageResponse = {
  pubkey: string;
  /**
   * The DER or compact hex encoded signature
   */
  signature: string;
};

/**
 * Generated factory for {@link SignMessageResponse} record objects.
 */
export const SignMessageResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SignMessageResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SignMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SignMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SignMessageResponse>,
  });
})();

const FfiConverterTypeSignMessageResponse = (() => {
  type TypeName = SignMessageResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        pubkey: FfiConverterString.read(from),
        signature: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.pubkey, into);
      FfiConverterString.write(value.signature, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.pubkey) +
        FfiConverterString.allocationSize(value.signature)
      );
    }
  }
  return new FFIConverter();
})();

export type SilentPaymentAddressDetails = {
  address: string;
  network: BitcoinNetwork;
  source: PaymentRequestSource;
};

/**
 * Generated factory for {@link SilentPaymentAddressDetails} record objects.
 */
export const SilentPaymentAddressDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SilentPaymentAddressDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SilentPaymentAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SilentPaymentAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<SilentPaymentAddressDetails>,
  });
})();

const FfiConverterTypeSilentPaymentAddressDetails = (() => {
  type TypeName = SilentPaymentAddressDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        address: FfiConverterString.read(from),
        network: FfiConverterTypeBitcoinNetwork.read(from),
        source: FfiConverterTypePaymentRequestSource.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.address, into);
      FfiConverterTypeBitcoinNetwork.write(value.network, into);
      FfiConverterTypePaymentRequestSource.write(value.source, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.address) +
        FfiConverterTypeBitcoinNetwork.allocationSize(value.network) +
        FfiConverterTypePaymentRequestSource.allocationSize(value.source)
      );
    }
  }
  return new FFIConverter();
})();

export type SparkAddressDetails = {
  /**
   * The raw address string
   */
  address: string;
  /**
   * The identity public key of the address owner
   */
  identityPublicKey: string;
  network: BitcoinNetwork;
  source: PaymentRequestSource;
};

/**
 * Generated factory for {@link SparkAddressDetails} record objects.
 */
export const SparkAddressDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SparkAddressDetails, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SparkAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SparkAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SparkAddressDetails>,
  });
})();

const FfiConverterTypeSparkAddressDetails = (() => {
  type TypeName = SparkAddressDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        address: FfiConverterString.read(from),
        identityPublicKey: FfiConverterString.read(from),
        network: FfiConverterTypeBitcoinNetwork.read(from),
        source: FfiConverterTypePaymentRequestSource.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.address, into);
      FfiConverterString.write(value.identityPublicKey, into);
      FfiConverterTypeBitcoinNetwork.write(value.network, into);
      FfiConverterTypePaymentRequestSource.write(value.source, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.address) +
        FfiConverterString.allocationSize(value.identityPublicKey) +
        FfiConverterTypeBitcoinNetwork.allocationSize(value.network) +
        FfiConverterTypePaymentRequestSource.allocationSize(value.source)
      );
    }
  }
  return new FFIConverter();
})();

export type SparkInvoiceDetails = {
  /**
   * The raw invoice string
   */
  invoice: string;
  /**
   * The identity public key of the invoice issuer
   */
  identityPublicKey: string;
  network: BitcoinNetwork;
  /**
   * Optional amount denominated in sats if `token_identifier` is absent, otherwise in the token base units
   */
  amount: U128 | undefined;
  /**
   * The token identifier of the token payment. Absence indicates a Bitcoin payment.
   */
  tokenIdentifier: string | undefined;
  /**
   * Optional expiry time. If not provided, the invoice will never expire.
   */
  expiryTime: /*u64*/ bigint | undefined;
  /**
   * Optional description.
   */
  description: string | undefined;
  /**
   * If set, the invoice may only be fulfilled by a payer with this public key.
   */
  senderPublicKey: string | undefined;
};

/**
 * Generated factory for {@link SparkInvoiceDetails} record objects.
 */
export const SparkInvoiceDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SparkInvoiceDetails, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SparkInvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SparkInvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SparkInvoiceDetails>,
  });
})();

const FfiConverterTypeSparkInvoiceDetails = (() => {
  type TypeName = SparkInvoiceDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        invoice: FfiConverterString.read(from),
        identityPublicKey: FfiConverterString.read(from),
        network: FfiConverterTypeBitcoinNetwork.read(from),
        amount: FfiConverterOptionalTypeu128.read(from),
        tokenIdentifier: FfiConverterOptionalString.read(from),
        expiryTime: FfiConverterOptionalUInt64.read(from),
        description: FfiConverterOptionalString.read(from),
        senderPublicKey: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.invoice, into);
      FfiConverterString.write(value.identityPublicKey, into);
      FfiConverterTypeBitcoinNetwork.write(value.network, into);
      FfiConverterOptionalTypeu128.write(value.amount, into);
      FfiConverterOptionalString.write(value.tokenIdentifier, into);
      FfiConverterOptionalUInt64.write(value.expiryTime, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalString.write(value.senderPublicKey, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.invoice) +
        FfiConverterString.allocationSize(value.identityPublicKey) +
        FfiConverterTypeBitcoinNetwork.allocationSize(value.network) +
        FfiConverterOptionalTypeu128.allocationSize(value.amount) +
        FfiConverterOptionalString.allocationSize(value.tokenIdentifier) +
        FfiConverterOptionalUInt64.allocationSize(value.expiryTime) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalString.allocationSize(value.senderPublicKey)
      );
    }
  }
  return new FFIConverter();
})();

export type SparkInvoicePaymentDetails = {
  /**
   * Represents the spark invoice description
   */
  description: string | undefined;
  /**
   * The raw spark invoice string
   */
  invoice: string;
};

/**
 * Generated factory for {@link SparkInvoicePaymentDetails} record objects.
 */
export const SparkInvoicePaymentDetails = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SparkInvoicePaymentDetails,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SparkInvoicePaymentDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SparkInvoicePaymentDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<SparkInvoicePaymentDetails>,
  });
})();

const FfiConverterTypeSparkInvoicePaymentDetails = (() => {
  type TypeName = SparkInvoicePaymentDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterOptionalString.read(from),
        invoice: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterString.write(value.invoice, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.invoice)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Settings for the symbol representation of a currency
 */
export type Symbol = {
  grapheme: string | undefined;
  template: string | undefined;
  rtl: boolean | undefined;
  position: /*u32*/ number | undefined;
};

/**
 * Generated factory for {@link Symbol} record objects.
 */
export const Symbol = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Symbol, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Symbol}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Symbol}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Symbol>,
  });
})();

const FfiConverterTypeSymbol = (() => {
  type TypeName = Symbol;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        grapheme: FfiConverterOptionalString.read(from),
        template: FfiConverterOptionalString.read(from),
        rtl: FfiConverterOptionalBool.read(from),
        position: FfiConverterOptionalUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.grapheme, into);
      FfiConverterOptionalString.write(value.template, into);
      FfiConverterOptionalBool.write(value.rtl, into);
      FfiConverterOptionalUInt32.write(value.position, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.grapheme) +
        FfiConverterOptionalString.allocationSize(value.template) +
        FfiConverterOptionalBool.allocationSize(value.rtl) +
        FfiConverterOptionalUInt32.allocationSize(value.position)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Request to sync the wallet with the Spark network
 */
export type SyncWalletRequest = {};

/**
 * Generated factory for {@link SyncWalletRequest} record objects.
 */
export const SyncWalletRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SyncWalletRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SyncWalletRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SyncWalletRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SyncWalletRequest>,
  });
})();

const FfiConverterTypeSyncWalletRequest = (() => {
  type TypeName = SyncWalletRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

/**
 * Response from synchronizing the wallet
 */
export type SyncWalletResponse = {};

/**
 * Generated factory for {@link SyncWalletResponse} record objects.
 */
export const SyncWalletResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SyncWalletResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SyncWalletResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SyncWalletResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SyncWalletResponse>,
  });
})();

const FfiConverterTypeSyncWalletResponse = (() => {
  type TypeName = SyncWalletResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {};
    }
    write(value: TypeName, into: RustBuffer): void {}
    allocationSize(value: TypeName): number {
      return 0;
    }
  }
  return new FFIConverter();
})();

export type TokenBalance = {
  balance: U128;
  tokenMetadata: TokenMetadata;
};

/**
 * Generated factory for {@link TokenBalance} record objects.
 */
export const TokenBalance = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TokenBalance, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TokenBalance}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TokenBalance}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TokenBalance>,
  });
})();

const FfiConverterTypeTokenBalance = (() => {
  type TypeName = TokenBalance;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        balance: FfiConverterTypeu128.read(from),
        tokenMetadata: FfiConverterTypeTokenMetadata.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeu128.write(value.balance, into);
      FfiConverterTypeTokenMetadata.write(value.tokenMetadata, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeu128.allocationSize(value.balance) +
        FfiConverterTypeTokenMetadata.allocationSize(value.tokenMetadata)
      );
    }
  }
  return new FFIConverter();
})();

export type TokenMetadata = {
  identifier: string;
  /**
   * Hex representation of the issuer public key
   */
  issuerPublicKey: string;
  name: string;
  ticker: string;
  /**
   * Number of decimals the token uses
   */
  decimals: /*u32*/ number;
  maxSupply: U128;
  isFreezable: boolean;
};

/**
 * Generated factory for {@link TokenMetadata} record objects.
 */
export const TokenMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TokenMetadata, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TokenMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TokenMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TokenMetadata>,
  });
})();

const FfiConverterTypeTokenMetadata = (() => {
  type TypeName = TokenMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        identifier: FfiConverterString.read(from),
        issuerPublicKey: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        ticker: FfiConverterString.read(from),
        decimals: FfiConverterUInt32.read(from),
        maxSupply: FfiConverterTypeu128.read(from),
        isFreezable: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.identifier, into);
      FfiConverterString.write(value.issuerPublicKey, into);
      FfiConverterString.write(value.name, into);
      FfiConverterString.write(value.ticker, into);
      FfiConverterUInt32.write(value.decimals, into);
      FfiConverterTypeu128.write(value.maxSupply, into);
      FfiConverterBool.write(value.isFreezable, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.identifier) +
        FfiConverterString.allocationSize(value.issuerPublicKey) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterString.allocationSize(value.ticker) +
        FfiConverterUInt32.allocationSize(value.decimals) +
        FfiConverterTypeu128.allocationSize(value.maxSupply) +
        FfiConverterBool.allocationSize(value.isFreezable)
      );
    }
  }
  return new FFIConverter();
})();

export type TxStatus = {
  confirmed: boolean;
  blockHeight: /*u32*/ number | undefined;
  blockTime: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link TxStatus} record objects.
 */
export const TxStatus = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TxStatus, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TxStatus}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TxStatus}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TxStatus>,
  });
})();

const FfiConverterTypeTxStatus = (() => {
  type TypeName = TxStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        confirmed: FfiConverterBool.read(from),
        blockHeight: FfiConverterOptionalUInt32.read(from),
        blockTime: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.confirmed, into);
      FfiConverterOptionalUInt32.write(value.blockHeight, into);
      FfiConverterOptionalUInt64.write(value.blockTime, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterBool.allocationSize(value.confirmed) +
        FfiConverterOptionalUInt32.allocationSize(value.blockHeight) +
        FfiConverterOptionalUInt64.allocationSize(value.blockTime)
      );
    }
  }
  return new FFIConverter();
})();

export type UnversionedRecordChange = {
  id: RecordId;
  schemaVersion: string;
  updatedFields: Map<string, string>;
};

/**
 * Generated factory for {@link UnversionedRecordChange} record objects.
 */
export const UnversionedRecordChange = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UnversionedRecordChange,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UnversionedRecordChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UnversionedRecordChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<UnversionedRecordChange>,
  });
})();

const FfiConverterTypeUnversionedRecordChange = (() => {
  type TypeName = UnversionedRecordChange;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterTypeRecordId.read(from),
        schemaVersion: FfiConverterString.read(from),
        updatedFields: FfiConverterMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeRecordId.write(value.id, into);
      FfiConverterString.write(value.schemaVersion, into);
      FfiConverterMapStringString.write(value.updatedFields, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeRecordId.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.schemaVersion) +
        FfiConverterMapStringString.allocationSize(value.updatedFields)
      );
    }
  }
  return new FFIConverter();
})();

export type UpdateUserSettingsRequest = {
  sparkPrivateModeEnabled: boolean | undefined;
};

/**
 * Generated factory for {@link UpdateUserSettingsRequest} record objects.
 */
export const UpdateUserSettingsRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UpdateUserSettingsRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UpdateUserSettingsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UpdateUserSettingsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<UpdateUserSettingsRequest>,
  });
})();

const FfiConverterTypeUpdateUserSettingsRequest = (() => {
  type TypeName = UpdateUserSettingsRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        sparkPrivateModeEnabled: FfiConverterOptionalBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalBool.write(value.sparkPrivateModeEnabled, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterOptionalBool.allocationSize(
        value.sparkPrivateModeEnabled
      );
    }
  }
  return new FFIConverter();
})();

export type UrlSuccessActionData = {
  /**
   * Contents description, up to 144 characters
   */
  description: string;
  /**
   * URL of the success action
   */
  url: string;
  /**
   * Indicates the success URL domain matches the LNURL callback domain.
   *
   * See <https://github.com/lnurl/luds/blob/luds/09.md>
   */
  matchesCallbackDomain: boolean;
};

/**
 * Generated factory for {@link UrlSuccessActionData} record objects.
 */
export const UrlSuccessActionData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UrlSuccessActionData,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UrlSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UrlSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UrlSuccessActionData>,
  });
})();

const FfiConverterTypeUrlSuccessActionData = (() => {
  type TypeName = UrlSuccessActionData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        description: FfiConverterString.read(from),
        url: FfiConverterString.read(from),
        matchesCallbackDomain: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.description, into);
      FfiConverterString.write(value.url, into);
      FfiConverterBool.write(value.matchesCallbackDomain, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.url) +
        FfiConverterBool.allocationSize(value.matchesCallbackDomain)
      );
    }
  }
  return new FFIConverter();
})();

export type UserSettings = {
  sparkPrivateModeEnabled: boolean;
};

/**
 * Generated factory for {@link UserSettings} record objects.
 */
export const UserSettings = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UserSettings, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UserSettings}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UserSettings}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UserSettings>,
  });
})();

const FfiConverterTypeUserSettings = (() => {
  type TypeName = UserSettings;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        sparkPrivateModeEnabled: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.sparkPrivateModeEnabled, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterBool.allocationSize(value.sparkPrivateModeEnabled);
    }
  }
  return new FFIConverter();
})();

export type Utxo = {
  txid: string;
  vout: /*u32*/ number;
  value: /*u64*/ bigint;
  status: TxStatus;
};

/**
 * Generated factory for {@link Utxo} record objects.
 */
export const Utxo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Utxo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Utxo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Utxo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Utxo>,
  });
})();

const FfiConverterTypeUtxo = (() => {
  type TypeName = Utxo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txid: FfiConverterString.read(from),
        vout: FfiConverterUInt32.read(from),
        value: FfiConverterUInt64.read(from),
        status: FfiConverterTypeTxStatus.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txid, into);
      FfiConverterUInt32.write(value.vout, into);
      FfiConverterUInt64.write(value.value, into);
      FfiConverterTypeTxStatus.write(value.status, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txid) +
        FfiConverterUInt32.allocationSize(value.vout) +
        FfiConverterUInt64.allocationSize(value.value) +
        FfiConverterTypeTxStatus.allocationSize(value.status)
      );
    }
  }
  return new FFIConverter();
})();

export type WaitForPaymentRequest = {
  identifier: WaitForPaymentIdentifier;
};

/**
 * Generated factory for {@link WaitForPaymentRequest} record objects.
 */
export const WaitForPaymentRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      WaitForPaymentRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WaitForPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WaitForPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WaitForPaymentRequest>,
  });
})();

const FfiConverterTypeWaitForPaymentRequest = (() => {
  type TypeName = WaitForPaymentRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        identifier: FfiConverterTypeWaitForPaymentIdentifier.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeWaitForPaymentIdentifier.write(value.identifier, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeWaitForPaymentIdentifier.allocationSize(
        value.identifier
      );
    }
  }
  return new FFIConverter();
})();

export type WaitForPaymentResponse = {
  payment: Payment;
};

/**
 * Generated factory for {@link WaitForPaymentResponse} record objects.
 */
export const WaitForPaymentResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      WaitForPaymentResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WaitForPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WaitForPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<WaitForPaymentResponse>,
  });
})();

const FfiConverterTypeWaitForPaymentResponse = (() => {
  type TypeName = WaitForPaymentResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        payment: FfiConverterTypePayment.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePayment.write(value.payment, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypePayment.allocationSize(value.payment);
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type U128 = bigint;

// FfiConverter for U128
const FfiConverterTypeu128 = (() => {
  type TsType = U128;
  type FfiType = Uint8Array;
  const intermediateConverter = FfiConverterString;
  class FFIConverter implements FfiConverter<FfiType, TsType> {
    lift(value: FfiType): TsType {
      const intermediate = intermediateConverter.lift(value);
      return BigInt(intermediate);
    }
    lower(value: TsType): FfiType {
      const intermediate = value.toString();
      return intermediateConverter.lower(intermediate);
    }
    read(from: RustBuffer): TsType {
      const intermediate = intermediateConverter.read(from);
      return BigInt(intermediate);
    }
    write(value: TsType, into: RustBuffer): void {
      const intermediate = value.toString();
      intermediateConverter.write(intermediate, into);
    }
    allocationSize(value: TsType): number {
      const intermediate = value.toString();
      return intermediateConverter.allocationSize(intermediate);
    }
  }

  return new FFIConverter();
})();

// Enum: AesSuccessActionDataResult
export enum AesSuccessActionDataResult_Tags {
  Decrypted = 'Decrypted',
  ErrorStatus = 'ErrorStatus',
}
/**
 * Result of decryption of [`AesSuccessActionData`] payload
 */
export const AesSuccessActionDataResult = (() => {
  type Decrypted__interface = {
    tag: AesSuccessActionDataResult_Tags.Decrypted;
    inner: Readonly<{ data: AesSuccessActionDataDecrypted }>;
  };

  class Decrypted_ extends UniffiEnum implements Decrypted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AesSuccessActionDataResult';
    readonly tag = AesSuccessActionDataResult_Tags.Decrypted;
    readonly inner: Readonly<{ data: AesSuccessActionDataDecrypted }>;
    constructor(inner: { data: AesSuccessActionDataDecrypted }) {
      super('AesSuccessActionDataResult', 'Decrypted');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: AesSuccessActionDataDecrypted }): Decrypted_ {
      return new Decrypted_(inner);
    }

    static instanceOf(obj: any): obj is Decrypted_ {
      return obj.tag === AesSuccessActionDataResult_Tags.Decrypted;
    }
  }

  type ErrorStatus__interface = {
    tag: AesSuccessActionDataResult_Tags.ErrorStatus;
    inner: Readonly<{ reason: string }>;
  };

  class ErrorStatus_ extends UniffiEnum implements ErrorStatus__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AesSuccessActionDataResult';
    readonly tag = AesSuccessActionDataResult_Tags.ErrorStatus;
    readonly inner: Readonly<{ reason: string }>;
    constructor(inner: { reason: string }) {
      super('AesSuccessActionDataResult', 'ErrorStatus');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { reason: string }): ErrorStatus_ {
      return new ErrorStatus_(inner);
    }

    static instanceOf(obj: any): obj is ErrorStatus_ {
      return obj.tag === AesSuccessActionDataResult_Tags.ErrorStatus;
    }
  }

  function instanceOf(obj: any): obj is AesSuccessActionDataResult {
    return obj[uniffiTypeNameSymbol] === 'AesSuccessActionDataResult';
  }

  return Object.freeze({
    instanceOf,
    Decrypted: Decrypted_,
    ErrorStatus: ErrorStatus_,
  });
})();

/**
 * Result of decryption of [`AesSuccessActionData`] payload
 */

export type AesSuccessActionDataResult = InstanceType<
  (typeof AesSuccessActionDataResult)[keyof Omit<
    typeof AesSuccessActionDataResult,
    'instanceOf'
  >]
>;

// FfiConverter for enum AesSuccessActionDataResult
const FfiConverterTypeAesSuccessActionDataResult = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AesSuccessActionDataResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AesSuccessActionDataResult.Decrypted({
            data: FfiConverterTypeAesSuccessActionDataDecrypted.read(from),
          });
        case 2:
          return new AesSuccessActionDataResult.ErrorStatus({
            reason: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AesSuccessActionDataResult_Tags.Decrypted: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeAesSuccessActionDataDecrypted.write(inner.data, into);
          return;
        }
        case AesSuccessActionDataResult_Tags.ErrorStatus: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.reason, into);
          return;
        }
        default:
          // Throwing from here means that AesSuccessActionDataResult_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AesSuccessActionDataResult_Tags.Decrypted: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeAesSuccessActionDataDecrypted.allocationSize(
            inner.data
          );
          return size;
        }
        case AesSuccessActionDataResult_Tags.ErrorStatus: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.reason);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Amount
export enum Amount_Tags {
  Bitcoin = 'Bitcoin',
  Currency = 'Currency',
}
export const Amount = (() => {
  type Bitcoin__interface = {
    tag: Amount_Tags.Bitcoin;
    inner: Readonly<{ amountMsat: /*u64*/ bigint }>;
  };

  class Bitcoin_ extends UniffiEnum implements Bitcoin__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Amount';
    readonly tag = Amount_Tags.Bitcoin;
    readonly inner: Readonly<{ amountMsat: /*u64*/ bigint }>;
    constructor(inner: { amountMsat: /*u64*/ bigint }) {
      super('Amount', 'Bitcoin');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { amountMsat: /*u64*/ bigint }): Bitcoin_ {
      return new Bitcoin_(inner);
    }

    static instanceOf(obj: any): obj is Bitcoin_ {
      return obj.tag === Amount_Tags.Bitcoin;
    }
  }

  type Currency__interface = {
    tag: Amount_Tags.Currency;
    inner: Readonly<{ iso4217Code: string; fractionalAmount: /*u64*/ bigint }>;
  };

  /**
   * An amount of currency specified using ISO 4712.
   */
  class Currency_ extends UniffiEnum implements Currency__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Amount';
    readonly tag = Amount_Tags.Currency;
    readonly inner: Readonly<{
      iso4217Code: string;
      fractionalAmount: /*u64*/ bigint;
    }>;
    constructor(inner: {
      /**
       * The currency that the amount is denominated in.
       */ iso4217Code: string;
      /**
       * The amount in the currency unit adjusted by the ISO 4712 exponent (e.g., USD cents).
       */ fractionalAmount: /*u64*/ bigint;
    }) {
      super('Amount', 'Currency');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The currency that the amount is denominated in.
       */ iso4217Code: string;
      /**
       * The amount in the currency unit adjusted by the ISO 4712 exponent (e.g., USD cents).
       */ fractionalAmount: /*u64*/ bigint;
    }): Currency_ {
      return new Currency_(inner);
    }

    static instanceOf(obj: any): obj is Currency_ {
      return obj.tag === Amount_Tags.Currency;
    }
  }

  function instanceOf(obj: any): obj is Amount {
    return obj[uniffiTypeNameSymbol] === 'Amount';
  }

  return Object.freeze({
    instanceOf,
    Bitcoin: Bitcoin_,
    Currency: Currency_,
  });
})();

export type Amount = InstanceType<
  (typeof Amount)[keyof Omit<typeof Amount, 'instanceOf'>]
>;

// FfiConverter for enum Amount
const FfiConverterTypeAmount = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Amount;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Amount.Bitcoin({
            amountMsat: FfiConverterUInt64.read(from),
          });
        case 2:
          return new Amount.Currency({
            iso4217Code: FfiConverterString.read(from),
            fractionalAmount: FfiConverterUInt64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Amount_Tags.Bitcoin: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.amountMsat, into);
          return;
        }
        case Amount_Tags.Currency: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.iso4217Code, into);
          FfiConverterUInt64.write(inner.fractionalAmount, into);
          return;
        }
        default:
          // Throwing from here means that Amount_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Amount_Tags.Bitcoin: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner.amountMsat);
          return size;
        }
        case Amount_Tags.Currency: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.iso4217Code);
          size += FfiConverterUInt64.allocationSize(inner.fractionalAmount);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: AssetFilter
export enum AssetFilter_Tags {
  Bitcoin = 'Bitcoin',
  Token = 'Token',
}
/**
 * A field of [`ListPaymentsRequest`] when listing payments filtered by asset
 */
export const AssetFilter = (() => {
  type Bitcoin__interface = {
    tag: AssetFilter_Tags.Bitcoin;
  };

  class Bitcoin_ extends UniffiEnum implements Bitcoin__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AssetFilter';
    readonly tag = AssetFilter_Tags.Bitcoin;
    constructor() {
      super('AssetFilter', 'Bitcoin');
    }

    static new(): Bitcoin_ {
      return new Bitcoin_();
    }

    static instanceOf(obj: any): obj is Bitcoin_ {
      return obj.tag === AssetFilter_Tags.Bitcoin;
    }
  }

  type Token__interface = {
    tag: AssetFilter_Tags.Token;
    inner: Readonly<{ tokenIdentifier: string | undefined }>;
  };

  class Token_ extends UniffiEnum implements Token__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'AssetFilter';
    readonly tag = AssetFilter_Tags.Token;
    readonly inner: Readonly<{ tokenIdentifier: string | undefined }>;
    constructor(inner: {
      /**
       * Optional token identifier to filter by
       */ tokenIdentifier: string | undefined;
    }) {
      super('AssetFilter', 'Token');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Optional token identifier to filter by
       */ tokenIdentifier: string | undefined;
    }): Token_ {
      return new Token_(inner);
    }

    static instanceOf(obj: any): obj is Token_ {
      return obj.tag === AssetFilter_Tags.Token;
    }
  }

  function instanceOf(obj: any): obj is AssetFilter {
    return obj[uniffiTypeNameSymbol] === 'AssetFilter';
  }

  return Object.freeze({
    instanceOf,
    Bitcoin: Bitcoin_,
    Token: Token_,
  });
})();

/**
 * A field of [`ListPaymentsRequest`] when listing payments filtered by asset
 */

export type AssetFilter = InstanceType<
  (typeof AssetFilter)[keyof Omit<typeof AssetFilter, 'instanceOf'>]
>;

// FfiConverter for enum AssetFilter
const FfiConverterTypeAssetFilter = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AssetFilter;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new AssetFilter.Bitcoin();
        case 2:
          return new AssetFilter.Token({
            tokenIdentifier: FfiConverterOptionalString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case AssetFilter_Tags.Bitcoin: {
          ordinalConverter.write(1, into);
          return;
        }
        case AssetFilter_Tags.Token: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.tokenIdentifier, into);
          return;
        }
        default:
          // Throwing from here means that AssetFilter_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case AssetFilter_Tags.Bitcoin: {
          return ordinalConverter.allocationSize(1);
        }
        case AssetFilter_Tags.Token: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalString.allocationSize(
            inner.tokenIdentifier
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum BitcoinNetwork {
  /**
   * Mainnet
   */
  Bitcoin,
  Testnet3,
  Testnet4,
  Signet,
  Regtest,
}

const FfiConverterTypeBitcoinNetwork = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BitcoinNetwork;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return BitcoinNetwork.Bitcoin;
        case 2:
          return BitcoinNetwork.Testnet3;
        case 3:
          return BitcoinNetwork.Testnet4;
        case 4:
          return BitcoinNetwork.Signet;
        case 5:
          return BitcoinNetwork.Regtest;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case BitcoinNetwork.Bitcoin:
          return ordinalConverter.write(1, into);
        case BitcoinNetwork.Testnet3:
          return ordinalConverter.write(2, into);
        case BitcoinNetwork.Testnet4:
          return ordinalConverter.write(3, into);
        case BitcoinNetwork.Signet:
          return ordinalConverter.write(4, into);
        case BitcoinNetwork.Regtest:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: ChainServiceError

// Enum: ChainServiceError
export enum ChainServiceError_Tags {
  InvalidAddress = 'InvalidAddress',
  ServiceConnectivity = 'ServiceConnectivity',
  Generic = 'Generic',
}
export const ChainServiceError = (() => {
  type InvalidAddress__interface = {
    tag: ChainServiceError_Tags.InvalidAddress;
    inner: Readonly<[string]>;
  };

  class InvalidAddress_
    extends UniffiError
    implements InvalidAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ChainServiceError';
    readonly tag = ChainServiceError_Tags.InvalidAddress;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ChainServiceError', 'InvalidAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidAddress_ {
      return new InvalidAddress_(v0);
    }

    static instanceOf(obj: any): obj is InvalidAddress_ {
      return obj.tag === ChainServiceError_Tags.InvalidAddress;
    }

    static hasInner(obj: any): obj is InvalidAddress_ {
      return InvalidAddress_.instanceOf(obj);
    }

    static getInner(obj: InvalidAddress_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type ServiceConnectivity__interface = {
    tag: ChainServiceError_Tags.ServiceConnectivity;
    inner: Readonly<[string]>;
  };

  class ServiceConnectivity_
    extends UniffiError
    implements ServiceConnectivity__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ChainServiceError';
    readonly tag = ChainServiceError_Tags.ServiceConnectivity;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ChainServiceError', 'ServiceConnectivity');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): ServiceConnectivity_ {
      return new ServiceConnectivity_(v0);
    }

    static instanceOf(obj: any): obj is ServiceConnectivity_ {
      return obj.tag === ChainServiceError_Tags.ServiceConnectivity;
    }

    static hasInner(obj: any): obj is ServiceConnectivity_ {
      return ServiceConnectivity_.instanceOf(obj);
    }

    static getInner(obj: ServiceConnectivity_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Generic__interface = {
    tag: ChainServiceError_Tags.Generic;
    inner: Readonly<[string]>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ChainServiceError';
    readonly tag = ChainServiceError_Tags.Generic;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ChainServiceError', 'Generic');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Generic_ {
      return new Generic_(v0);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === ChainServiceError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is ChainServiceError {
    return obj[uniffiTypeNameSymbol] === 'ChainServiceError';
  }

  return Object.freeze({
    instanceOf,
    InvalidAddress: InvalidAddress_,
    ServiceConnectivity: ServiceConnectivity_,
    Generic: Generic_,
  });
})();

export type ChainServiceError = InstanceType<
  (typeof ChainServiceError)[keyof Omit<typeof ChainServiceError, 'instanceOf'>]
>;

// FfiConverter for enum ChainServiceError
const FfiConverterTypeChainServiceError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ChainServiceError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ChainServiceError.InvalidAddress(
            FfiConverterString.read(from)
          );
        case 2:
          return new ChainServiceError.ServiceConnectivity(
            FfiConverterString.read(from)
          );
        case 3:
          return new ChainServiceError.Generic(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ChainServiceError_Tags.InvalidAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ChainServiceError_Tags.ServiceConnectivity: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ChainServiceError_Tags.Generic: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that ChainServiceError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ChainServiceError_Tags.InvalidAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ChainServiceError_Tags.ServiceConnectivity: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ChainServiceError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: DepositClaimError
export enum DepositClaimError_Tags {
  DepositClaimFeeExceeded = 'DepositClaimFeeExceeded',
  MissingUtxo = 'MissingUtxo',
  Generic = 'Generic',
}
export const DepositClaimError = (() => {
  type DepositClaimFeeExceeded__interface = {
    tag: DepositClaimError_Tags.DepositClaimFeeExceeded;
    inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee | undefined;
      actualFee: /*u64*/ bigint;
    }>;
  };

  class DepositClaimFeeExceeded_
    extends UniffiEnum
    implements DepositClaimFeeExceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DepositClaimError';
    readonly tag = DepositClaimError_Tags.DepositClaimFeeExceeded;
    readonly inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee | undefined;
      actualFee: /*u64*/ bigint;
    }>;
    constructor(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee | undefined;
      actualFee: /*u64*/ bigint;
    }) {
      super('DepositClaimError', 'DepositClaimFeeExceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee | undefined;
      actualFee: /*u64*/ bigint;
    }): DepositClaimFeeExceeded_ {
      return new DepositClaimFeeExceeded_(inner);
    }

    static instanceOf(obj: any): obj is DepositClaimFeeExceeded_ {
      return obj.tag === DepositClaimError_Tags.DepositClaimFeeExceeded;
    }
  }

  type MissingUtxo__interface = {
    tag: DepositClaimError_Tags.MissingUtxo;
    inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
  };

  class MissingUtxo_ extends UniffiEnum implements MissingUtxo__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DepositClaimError';
    readonly tag = DepositClaimError_Tags.MissingUtxo;
    readonly inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
    constructor(inner: { tx: string; vout: /*u32*/ number }) {
      super('DepositClaimError', 'MissingUtxo');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { tx: string; vout: /*u32*/ number }): MissingUtxo_ {
      return new MissingUtxo_(inner);
    }

    static instanceOf(obj: any): obj is MissingUtxo_ {
      return obj.tag === DepositClaimError_Tags.MissingUtxo;
    }
  }

  type Generic__interface = {
    tag: DepositClaimError_Tags.Generic;
    inner: Readonly<{ message: string }>;
  };

  class Generic_ extends UniffiEnum implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DepositClaimError';
    readonly tag = DepositClaimError_Tags.Generic;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('DepositClaimError', 'Generic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Generic_ {
      return new Generic_(inner);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === DepositClaimError_Tags.Generic;
    }
  }

  function instanceOf(obj: any): obj is DepositClaimError {
    return obj[uniffiTypeNameSymbol] === 'DepositClaimError';
  }

  return Object.freeze({
    instanceOf,
    DepositClaimFeeExceeded: DepositClaimFeeExceeded_,
    MissingUtxo: MissingUtxo_,
    Generic: Generic_,
  });
})();

export type DepositClaimError = InstanceType<
  (typeof DepositClaimError)[keyof Omit<typeof DepositClaimError, 'instanceOf'>]
>;

// FfiConverter for enum DepositClaimError
const FfiConverterTypeDepositClaimError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = DepositClaimError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new DepositClaimError.DepositClaimFeeExceeded({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
            maxFee: FfiConverterOptionalTypeFee.read(from),
            actualFee: FfiConverterUInt64.read(from),
          });
        case 2:
          return new DepositClaimError.MissingUtxo({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
          });
        case 3:
          return new DepositClaimError.Generic({
            message: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case DepositClaimError_Tags.DepositClaimFeeExceeded: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          FfiConverterOptionalTypeFee.write(inner.maxFee, into);
          FfiConverterUInt64.write(inner.actualFee, into);
          return;
        }
        case DepositClaimError_Tags.MissingUtxo: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          return;
        }
        case DepositClaimError_Tags.Generic: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that DepositClaimError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case DepositClaimError_Tags.DepositClaimFeeExceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          size += FfiConverterOptionalTypeFee.allocationSize(inner.maxFee);
          size += FfiConverterUInt64.allocationSize(inner.actualFee);
          return size;
        }
        case DepositClaimError_Tags.MissingUtxo: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          return size;
        }
        case DepositClaimError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Fee
export enum Fee_Tags {
  Fixed = 'Fixed',
  Rate = 'Rate',
}
export const Fee = (() => {
  type Fixed__interface = {
    tag: Fee_Tags.Fixed;
    inner: Readonly<{ amount: /*u64*/ bigint }>;
  };

  class Fixed_ extends UniffiEnum implements Fixed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Fee';
    readonly tag = Fee_Tags.Fixed;
    readonly inner: Readonly<{ amount: /*u64*/ bigint }>;
    constructor(inner: { amount: /*u64*/ bigint }) {
      super('Fee', 'Fixed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { amount: /*u64*/ bigint }): Fixed_ {
      return new Fixed_(inner);
    }

    static instanceOf(obj: any): obj is Fixed_ {
      return obj.tag === Fee_Tags.Fixed;
    }
  }

  type Rate__interface = {
    tag: Fee_Tags.Rate;
    inner: Readonly<{ satPerVbyte: /*u64*/ bigint }>;
  };

  class Rate_ extends UniffiEnum implements Rate__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Fee';
    readonly tag = Fee_Tags.Rate;
    readonly inner: Readonly<{ satPerVbyte: /*u64*/ bigint }>;
    constructor(inner: { satPerVbyte: /*u64*/ bigint }) {
      super('Fee', 'Rate');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { satPerVbyte: /*u64*/ bigint }): Rate_ {
      return new Rate_(inner);
    }

    static instanceOf(obj: any): obj is Rate_ {
      return obj.tag === Fee_Tags.Rate;
    }
  }

  function instanceOf(obj: any): obj is Fee {
    return obj[uniffiTypeNameSymbol] === 'Fee';
  }

  return Object.freeze({
    instanceOf,
    Fixed: Fixed_,
    Rate: Rate_,
  });
})();

export type Fee = InstanceType<
  (typeof Fee)[keyof Omit<typeof Fee, 'instanceOf'>]
>;

// FfiConverter for enum Fee
const FfiConverterTypeFee = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Fee;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Fee.Fixed({ amount: FfiConverterUInt64.read(from) });
        case 2:
          return new Fee.Rate({ satPerVbyte: FfiConverterUInt64.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Fee_Tags.Fixed: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.amount, into);
          return;
        }
        case Fee_Tags.Rate: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.satPerVbyte, into);
          return;
        }
        default:
          // Throwing from here means that Fee_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Fee_Tags.Fixed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner.amount);
          return size;
        }
        case Fee_Tags.Rate: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt64.allocationSize(inner.satPerVbyte);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: InputType
export enum InputType_Tags {
  BitcoinAddress = 'BitcoinAddress',
  Bolt11Invoice = 'Bolt11Invoice',
  Bolt12Invoice = 'Bolt12Invoice',
  Bolt12Offer = 'Bolt12Offer',
  LightningAddress = 'LightningAddress',
  LnurlPay = 'LnurlPay',
  SilentPaymentAddress = 'SilentPaymentAddress',
  LnurlAuth = 'LnurlAuth',
  Url = 'Url',
  Bip21 = 'Bip21',
  Bolt12InvoiceRequest = 'Bolt12InvoiceRequest',
  LnurlWithdraw = 'LnurlWithdraw',
  SparkAddress = 'SparkAddress',
  SparkInvoice = 'SparkInvoice',
}
export const InputType = (() => {
  type BitcoinAddress__interface = {
    tag: InputType_Tags.BitcoinAddress;
    inner: Readonly<[BitcoinAddressDetails]>;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.BitcoinAddress;
    readonly inner: Readonly<[BitcoinAddressDetails]>;
    constructor(v0: BitcoinAddressDetails) {
      super('InputType', 'BitcoinAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: BitcoinAddressDetails): BitcoinAddress_ {
      return new BitcoinAddress_(v0);
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === InputType_Tags.BitcoinAddress;
    }
  }

  type Bolt11Invoice__interface = {
    tag: InputType_Tags.Bolt11Invoice;
    inner: Readonly<[Bolt11InvoiceDetails]>;
  };

  class Bolt11Invoice_ extends UniffiEnum implements Bolt11Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.Bolt11Invoice;
    readonly inner: Readonly<[Bolt11InvoiceDetails]>;
    constructor(v0: Bolt11InvoiceDetails) {
      super('InputType', 'Bolt11Invoice');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: Bolt11InvoiceDetails): Bolt11Invoice_ {
      return new Bolt11Invoice_(v0);
    }

    static instanceOf(obj: any): obj is Bolt11Invoice_ {
      return obj.tag === InputType_Tags.Bolt11Invoice;
    }
  }

  type Bolt12Invoice__interface = {
    tag: InputType_Tags.Bolt12Invoice;
    inner: Readonly<[Bolt12InvoiceDetails]>;
  };

  class Bolt12Invoice_ extends UniffiEnum implements Bolt12Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.Bolt12Invoice;
    readonly inner: Readonly<[Bolt12InvoiceDetails]>;
    constructor(v0: Bolt12InvoiceDetails) {
      super('InputType', 'Bolt12Invoice');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: Bolt12InvoiceDetails): Bolt12Invoice_ {
      return new Bolt12Invoice_(v0);
    }

    static instanceOf(obj: any): obj is Bolt12Invoice_ {
      return obj.tag === InputType_Tags.Bolt12Invoice;
    }
  }

  type Bolt12Offer__interface = {
    tag: InputType_Tags.Bolt12Offer;
    inner: Readonly<[Bolt12OfferDetails]>;
  };

  class Bolt12Offer_ extends UniffiEnum implements Bolt12Offer__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.Bolt12Offer;
    readonly inner: Readonly<[Bolt12OfferDetails]>;
    constructor(v0: Bolt12OfferDetails) {
      super('InputType', 'Bolt12Offer');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: Bolt12OfferDetails): Bolt12Offer_ {
      return new Bolt12Offer_(v0);
    }

    static instanceOf(obj: any): obj is Bolt12Offer_ {
      return obj.tag === InputType_Tags.Bolt12Offer;
    }
  }

  type LightningAddress__interface = {
    tag: InputType_Tags.LightningAddress;
    inner: Readonly<[LightningAddressDetails]>;
  };

  class LightningAddress_
    extends UniffiEnum
    implements LightningAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.LightningAddress;
    readonly inner: Readonly<[LightningAddressDetails]>;
    constructor(v0: LightningAddressDetails) {
      super('InputType', 'LightningAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: LightningAddressDetails): LightningAddress_ {
      return new LightningAddress_(v0);
    }

    static instanceOf(obj: any): obj is LightningAddress_ {
      return obj.tag === InputType_Tags.LightningAddress;
    }
  }

  type LnurlPay__interface = {
    tag: InputType_Tags.LnurlPay;
    inner: Readonly<[LnurlPayRequestDetails]>;
  };

  class LnurlPay_ extends UniffiEnum implements LnurlPay__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.LnurlPay;
    readonly inner: Readonly<[LnurlPayRequestDetails]>;
    constructor(v0: LnurlPayRequestDetails) {
      super('InputType', 'LnurlPay');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: LnurlPayRequestDetails): LnurlPay_ {
      return new LnurlPay_(v0);
    }

    static instanceOf(obj: any): obj is LnurlPay_ {
      return obj.tag === InputType_Tags.LnurlPay;
    }
  }

  type SilentPaymentAddress__interface = {
    tag: InputType_Tags.SilentPaymentAddress;
    inner: Readonly<[SilentPaymentAddressDetails]>;
  };

  class SilentPaymentAddress_
    extends UniffiEnum
    implements SilentPaymentAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.SilentPaymentAddress;
    readonly inner: Readonly<[SilentPaymentAddressDetails]>;
    constructor(v0: SilentPaymentAddressDetails) {
      super('InputType', 'SilentPaymentAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: SilentPaymentAddressDetails): SilentPaymentAddress_ {
      return new SilentPaymentAddress_(v0);
    }

    static instanceOf(obj: any): obj is SilentPaymentAddress_ {
      return obj.tag === InputType_Tags.SilentPaymentAddress;
    }
  }

  type LnurlAuth__interface = {
    tag: InputType_Tags.LnurlAuth;
    inner: Readonly<[LnurlAuthRequestDetails]>;
  };

  class LnurlAuth_ extends UniffiEnum implements LnurlAuth__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.LnurlAuth;
    readonly inner: Readonly<[LnurlAuthRequestDetails]>;
    constructor(v0: LnurlAuthRequestDetails) {
      super('InputType', 'LnurlAuth');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: LnurlAuthRequestDetails): LnurlAuth_ {
      return new LnurlAuth_(v0);
    }

    static instanceOf(obj: any): obj is LnurlAuth_ {
      return obj.tag === InputType_Tags.LnurlAuth;
    }
  }

  type Url__interface = {
    tag: InputType_Tags.Url;
    inner: Readonly<[string]>;
  };

  class Url_ extends UniffiEnum implements Url__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.Url;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('InputType', 'Url');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Url_ {
      return new Url_(v0);
    }

    static instanceOf(obj: any): obj is Url_ {
      return obj.tag === InputType_Tags.Url;
    }
  }

  type Bip21__interface = {
    tag: InputType_Tags.Bip21;
    inner: Readonly<[Bip21Details]>;
  };

  class Bip21_ extends UniffiEnum implements Bip21__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.Bip21;
    readonly inner: Readonly<[Bip21Details]>;
    constructor(v0: Bip21Details) {
      super('InputType', 'Bip21');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: Bip21Details): Bip21_ {
      return new Bip21_(v0);
    }

    static instanceOf(obj: any): obj is Bip21_ {
      return obj.tag === InputType_Tags.Bip21;
    }
  }

  type Bolt12InvoiceRequest__interface = {
    tag: InputType_Tags.Bolt12InvoiceRequest;
    inner: Readonly<[Bolt12InvoiceRequestDetails]>;
  };

  class Bolt12InvoiceRequest_
    extends UniffiEnum
    implements Bolt12InvoiceRequest__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.Bolt12InvoiceRequest;
    readonly inner: Readonly<[Bolt12InvoiceRequestDetails]>;
    constructor(v0: Bolt12InvoiceRequestDetails) {
      super('InputType', 'Bolt12InvoiceRequest');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: Bolt12InvoiceRequestDetails): Bolt12InvoiceRequest_ {
      return new Bolt12InvoiceRequest_(v0);
    }

    static instanceOf(obj: any): obj is Bolt12InvoiceRequest_ {
      return obj.tag === InputType_Tags.Bolt12InvoiceRequest;
    }
  }

  type LnurlWithdraw__interface = {
    tag: InputType_Tags.LnurlWithdraw;
    inner: Readonly<[LnurlWithdrawRequestDetails]>;
  };

  class LnurlWithdraw_ extends UniffiEnum implements LnurlWithdraw__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.LnurlWithdraw;
    readonly inner: Readonly<[LnurlWithdrawRequestDetails]>;
    constructor(v0: LnurlWithdrawRequestDetails) {
      super('InputType', 'LnurlWithdraw');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: LnurlWithdrawRequestDetails): LnurlWithdraw_ {
      return new LnurlWithdraw_(v0);
    }

    static instanceOf(obj: any): obj is LnurlWithdraw_ {
      return obj.tag === InputType_Tags.LnurlWithdraw;
    }
  }

  type SparkAddress__interface = {
    tag: InputType_Tags.SparkAddress;
    inner: Readonly<[SparkAddressDetails]>;
  };

  class SparkAddress_ extends UniffiEnum implements SparkAddress__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.SparkAddress;
    readonly inner: Readonly<[SparkAddressDetails]>;
    constructor(v0: SparkAddressDetails) {
      super('InputType', 'SparkAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: SparkAddressDetails): SparkAddress_ {
      return new SparkAddress_(v0);
    }

    static instanceOf(obj: any): obj is SparkAddress_ {
      return obj.tag === InputType_Tags.SparkAddress;
    }
  }

  type SparkInvoice__interface = {
    tag: InputType_Tags.SparkInvoice;
    inner: Readonly<[SparkInvoiceDetails]>;
  };

  class SparkInvoice_ extends UniffiEnum implements SparkInvoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InputType';
    readonly tag = InputType_Tags.SparkInvoice;
    readonly inner: Readonly<[SparkInvoiceDetails]>;
    constructor(v0: SparkInvoiceDetails) {
      super('InputType', 'SparkInvoice');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: SparkInvoiceDetails): SparkInvoice_ {
      return new SparkInvoice_(v0);
    }

    static instanceOf(obj: any): obj is SparkInvoice_ {
      return obj.tag === InputType_Tags.SparkInvoice;
    }
  }

  function instanceOf(obj: any): obj is InputType {
    return obj[uniffiTypeNameSymbol] === 'InputType';
  }

  return Object.freeze({
    instanceOf,
    BitcoinAddress: BitcoinAddress_,
    Bolt11Invoice: Bolt11Invoice_,
    Bolt12Invoice: Bolt12Invoice_,
    Bolt12Offer: Bolt12Offer_,
    LightningAddress: LightningAddress_,
    LnurlPay: LnurlPay_,
    SilentPaymentAddress: SilentPaymentAddress_,
    LnurlAuth: LnurlAuth_,
    Url: Url_,
    Bip21: Bip21_,
    Bolt12InvoiceRequest: Bolt12InvoiceRequest_,
    LnurlWithdraw: LnurlWithdraw_,
    SparkAddress: SparkAddress_,
    SparkInvoice: SparkInvoice_,
  });
})();

export type InputType = InstanceType<
  (typeof InputType)[keyof Omit<typeof InputType, 'instanceOf'>]
>;

// FfiConverter for enum InputType
const FfiConverterTypeInputType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = InputType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new InputType.BitcoinAddress(
            FfiConverterTypeBitcoinAddressDetails.read(from)
          );
        case 2:
          return new InputType.Bolt11Invoice(
            FfiConverterTypeBolt11InvoiceDetails.read(from)
          );
        case 3:
          return new InputType.Bolt12Invoice(
            FfiConverterTypeBolt12InvoiceDetails.read(from)
          );
        case 4:
          return new InputType.Bolt12Offer(
            FfiConverterTypeBolt12OfferDetails.read(from)
          );
        case 5:
          return new InputType.LightningAddress(
            FfiConverterTypeLightningAddressDetails.read(from)
          );
        case 6:
          return new InputType.LnurlPay(
            FfiConverterTypeLnurlPayRequestDetails.read(from)
          );
        case 7:
          return new InputType.SilentPaymentAddress(
            FfiConverterTypeSilentPaymentAddressDetails.read(from)
          );
        case 8:
          return new InputType.LnurlAuth(
            FfiConverterTypeLnurlAuthRequestDetails.read(from)
          );
        case 9:
          return new InputType.Url(FfiConverterString.read(from));
        case 10:
          return new InputType.Bip21(FfiConverterTypeBip21Details.read(from));
        case 11:
          return new InputType.Bolt12InvoiceRequest(
            FfiConverterTypeBolt12InvoiceRequestDetails.read(from)
          );
        case 12:
          return new InputType.LnurlWithdraw(
            FfiConverterTypeLnurlWithdrawRequestDetails.read(from)
          );
        case 13:
          return new InputType.SparkAddress(
            FfiConverterTypeSparkAddressDetails.read(from)
          );
        case 14:
          return new InputType.SparkInvoice(
            FfiConverterTypeSparkInvoiceDetails.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case InputType_Tags.BitcoinAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeBitcoinAddressDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.Bolt11Invoice: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeBolt11InvoiceDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.Bolt12Invoice: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeBolt12InvoiceDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.Bolt12Offer: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeBolt12OfferDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.LightningAddress: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeLightningAddressDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.LnurlPay: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypeLnurlPayRequestDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.SilentPaymentAddress: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypeSilentPaymentAddressDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.LnurlAuth: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeLnurlAuthRequestDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.Url: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case InputType_Tags.Bip21: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterTypeBip21Details.write(inner[0], into);
          return;
        }
        case InputType_Tags.Bolt12InvoiceRequest: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterTypeBolt12InvoiceRequestDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.LnurlWithdraw: {
          ordinalConverter.write(12, into);
          const inner = value.inner;
          FfiConverterTypeLnurlWithdrawRequestDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.SparkAddress: {
          ordinalConverter.write(13, into);
          const inner = value.inner;
          FfiConverterTypeSparkAddressDetails.write(inner[0], into);
          return;
        }
        case InputType_Tags.SparkInvoice: {
          ordinalConverter.write(14, into);
          const inner = value.inner;
          FfiConverterTypeSparkInvoiceDetails.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that InputType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case InputType_Tags.BitcoinAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeBitcoinAddressDetails.allocationSize(
            inner[0]
          );
          return size;
        }
        case InputType_Tags.Bolt11Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeBolt11InvoiceDetails.allocationSize(inner[0]);
          return size;
        }
        case InputType_Tags.Bolt12Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeBolt12InvoiceDetails.allocationSize(inner[0]);
          return size;
        }
        case InputType_Tags.Bolt12Offer: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeBolt12OfferDetails.allocationSize(inner[0]);
          return size;
        }
        case InputType_Tags.LightningAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeLightningAddressDetails.allocationSize(
            inner[0]
          );
          return size;
        }
        case InputType_Tags.LnurlPay: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeLnurlPayRequestDetails.allocationSize(
            inner[0]
          );
          return size;
        }
        case InputType_Tags.SilentPaymentAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeSilentPaymentAddressDetails.allocationSize(
            inner[0]
          );
          return size;
        }
        case InputType_Tags.LnurlAuth: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeLnurlAuthRequestDetails.allocationSize(
            inner[0]
          );
          return size;
        }
        case InputType_Tags.Url: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case InputType_Tags.Bip21: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterTypeBip21Details.allocationSize(inner[0]);
          return size;
        }
        case InputType_Tags.Bolt12InvoiceRequest: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterTypeBolt12InvoiceRequestDetails.allocationSize(
            inner[0]
          );
          return size;
        }
        case InputType_Tags.LnurlWithdraw: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterTypeLnurlWithdrawRequestDetails.allocationSize(
            inner[0]
          );
          return size;
        }
        case InputType_Tags.SparkAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(13);
          size += FfiConverterTypeSparkAddressDetails.allocationSize(inner[0]);
          return size;
        }
        case InputType_Tags.SparkInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(14);
          size += FfiConverterTypeSparkInvoiceDetails.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum KeySetType {
  Default,
  Taproot,
  NativeSegwit,
  WrappedSegwit,
  Legacy,
}

const FfiConverterTypeKeySetType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = KeySetType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return KeySetType.Default;
        case 2:
          return KeySetType.Taproot;
        case 3:
          return KeySetType.NativeSegwit;
        case 4:
          return KeySetType.WrappedSegwit;
        case 5:
          return KeySetType.Legacy;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case KeySetType.Default:
          return ordinalConverter.write(1, into);
        case KeySetType.Taproot:
          return ordinalConverter.write(2, into);
        case KeySetType.NativeSegwit:
          return ordinalConverter.write(3, into);
        case KeySetType.WrappedSegwit:
          return ordinalConverter.write(4, into);
        case KeySetType.Legacy:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum Network {
  Mainnet,
  Regtest,
}

const FfiConverterTypeNetwork = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Network;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Network.Mainnet;
        case 2:
          return Network.Regtest;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Network.Mainnet:
          return ordinalConverter.write(1, into);
        case Network.Regtest:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum OnchainConfirmationSpeed {
  Fast,
  Medium,
  Slow,
}

const FfiConverterTypeOnchainConfirmationSpeed = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = OnchainConfirmationSpeed;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return OnchainConfirmationSpeed.Fast;
        case 2:
          return OnchainConfirmationSpeed.Medium;
        case 3:
          return OnchainConfirmationSpeed.Slow;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case OnchainConfirmationSpeed.Fast:
          return ordinalConverter.write(1, into);
        case OnchainConfirmationSpeed.Medium:
          return ordinalConverter.write(2, into);
        case OnchainConfirmationSpeed.Slow:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: PaymentDetails
export enum PaymentDetails_Tags {
  Spark = 'Spark',
  Token = 'Token',
  Lightning = 'Lightning',
  Withdraw = 'Withdraw',
  Deposit = 'Deposit',
}
export const PaymentDetails = (() => {
  type Spark__interface = {
    tag: PaymentDetails_Tags.Spark;
    inner: Readonly<{ invoiceDetails: SparkInvoicePaymentDetails | undefined }>;
  };

  class Spark_ extends UniffiEnum implements Spark__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Spark;
    readonly inner: Readonly<{
      invoiceDetails: SparkInvoicePaymentDetails | undefined;
    }>;
    constructor(inner: {
      /**
       * The invoice details if the payment fulfilled a spark invoice
       */ invoiceDetails: SparkInvoicePaymentDetails | undefined;
    }) {
      super('PaymentDetails', 'Spark');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The invoice details if the payment fulfilled a spark invoice
       */ invoiceDetails: SparkInvoicePaymentDetails | undefined;
    }): Spark_ {
      return new Spark_(inner);
    }

    static instanceOf(obj: any): obj is Spark_ {
      return obj.tag === PaymentDetails_Tags.Spark;
    }
  }

  type Token__interface = {
    tag: PaymentDetails_Tags.Token;
    inner: Readonly<{
      metadata: TokenMetadata;
      txHash: string;
      invoiceDetails: SparkInvoicePaymentDetails | undefined;
    }>;
  };

  class Token_ extends UniffiEnum implements Token__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Token;
    readonly inner: Readonly<{
      metadata: TokenMetadata;
      txHash: string;
      invoiceDetails: SparkInvoicePaymentDetails | undefined;
    }>;
    constructor(inner: {
      metadata: TokenMetadata;
      txHash: string;
      /**
       * The invoice details if the payment fulfilled a spark invoice
       */ invoiceDetails: SparkInvoicePaymentDetails | undefined;
    }) {
      super('PaymentDetails', 'Token');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      metadata: TokenMetadata;
      txHash: string;
      /**
       * The invoice details if the payment fulfilled a spark invoice
       */ invoiceDetails: SparkInvoicePaymentDetails | undefined;
    }): Token_ {
      return new Token_(inner);
    }

    static instanceOf(obj: any): obj is Token_ {
      return obj.tag === PaymentDetails_Tags.Token;
    }
  }

  type Lightning__interface = {
    tag: PaymentDetails_Tags.Lightning;
    inner: Readonly<{
      description: string | undefined;
      preimage: string | undefined;
      invoice: string;
      paymentHash: string;
      destinationPubkey: string;
      lnurlPayInfo: LnurlPayInfo | undefined;
      lnurlWithdrawInfo: LnurlWithdrawInfo | undefined;
    }>;
  };

  class Lightning_ extends UniffiEnum implements Lightning__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Lightning;
    readonly inner: Readonly<{
      description: string | undefined;
      preimage: string | undefined;
      invoice: string;
      paymentHash: string;
      destinationPubkey: string;
      lnurlPayInfo: LnurlPayInfo | undefined;
      lnurlWithdrawInfo: LnurlWithdrawInfo | undefined;
    }>;
    constructor(inner: {
      /**
       * Represents the invoice description
       */ description: string | undefined;
      /**
       * The preimage of the paid invoice (proof of payment).
       */ preimage: string | undefined;
      /**
       * Represents the Bolt11/Bolt12 invoice associated with a payment
       * In the case of a Send payment, this is the invoice paid by the user
       * In the case of a Receive payment, this is the invoice paid to the user
       */ invoice: string;
      /**
       * The payment hash of the invoice
       */ paymentHash: string;
      /**
       * The invoice destination/payee pubkey
       */ destinationPubkey: string;
      /**
       * Lnurl payment information if this was an lnurl payment.
       */ lnurlPayInfo: LnurlPayInfo | undefined;
      /**
       * Lnurl withdrawal information if this was an lnurl payment.
       */ lnurlWithdrawInfo: LnurlWithdrawInfo | undefined;
    }) {
      super('PaymentDetails', 'Lightning');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Represents the invoice description
       */ description: string | undefined;
      /**
       * The preimage of the paid invoice (proof of payment).
       */ preimage: string | undefined;
      /**
       * Represents the Bolt11/Bolt12 invoice associated with a payment
       * In the case of a Send payment, this is the invoice paid by the user
       * In the case of a Receive payment, this is the invoice paid to the user
       */ invoice: string;
      /**
       * The payment hash of the invoice
       */ paymentHash: string;
      /**
       * The invoice destination/payee pubkey
       */ destinationPubkey: string;
      /**
       * Lnurl payment information if this was an lnurl payment.
       */ lnurlPayInfo: LnurlPayInfo | undefined;
      /**
       * Lnurl withdrawal information if this was an lnurl payment.
       */ lnurlWithdrawInfo: LnurlWithdrawInfo | undefined;
    }): Lightning_ {
      return new Lightning_(inner);
    }

    static instanceOf(obj: any): obj is Lightning_ {
      return obj.tag === PaymentDetails_Tags.Lightning;
    }
  }

  type Withdraw__interface = {
    tag: PaymentDetails_Tags.Withdraw;
    inner: Readonly<{ txId: string }>;
  };

  class Withdraw_ extends UniffiEnum implements Withdraw__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Withdraw;
    readonly inner: Readonly<{ txId: string }>;
    constructor(inner: { txId: string }) {
      super('PaymentDetails', 'Withdraw');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { txId: string }): Withdraw_ {
      return new Withdraw_(inner);
    }

    static instanceOf(obj: any): obj is Withdraw_ {
      return obj.tag === PaymentDetails_Tags.Withdraw;
    }
  }

  type Deposit__interface = {
    tag: PaymentDetails_Tags.Deposit;
    inner: Readonly<{ txId: string }>;
  };

  class Deposit_ extends UniffiEnum implements Deposit__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentDetails';
    readonly tag = PaymentDetails_Tags.Deposit;
    readonly inner: Readonly<{ txId: string }>;
    constructor(inner: { txId: string }) {
      super('PaymentDetails', 'Deposit');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { txId: string }): Deposit_ {
      return new Deposit_(inner);
    }

    static instanceOf(obj: any): obj is Deposit_ {
      return obj.tag === PaymentDetails_Tags.Deposit;
    }
  }

  function instanceOf(obj: any): obj is PaymentDetails {
    return obj[uniffiTypeNameSymbol] === 'PaymentDetails';
  }

  return Object.freeze({
    instanceOf,
    Spark: Spark_,
    Token: Token_,
    Lightning: Lightning_,
    Withdraw: Withdraw_,
    Deposit: Deposit_,
  });
})();

export type PaymentDetails = InstanceType<
  (typeof PaymentDetails)[keyof Omit<typeof PaymentDetails, 'instanceOf'>]
>;

// FfiConverter for enum PaymentDetails
const FfiConverterTypePaymentDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PaymentDetails.Spark({
            invoiceDetails:
              FfiConverterOptionalTypeSparkInvoicePaymentDetails.read(from),
          });
        case 2:
          return new PaymentDetails.Token({
            metadata: FfiConverterTypeTokenMetadata.read(from),
            txHash: FfiConverterString.read(from),
            invoiceDetails:
              FfiConverterOptionalTypeSparkInvoicePaymentDetails.read(from),
          });
        case 3:
          return new PaymentDetails.Lightning({
            description: FfiConverterOptionalString.read(from),
            preimage: FfiConverterOptionalString.read(from),
            invoice: FfiConverterString.read(from),
            paymentHash: FfiConverterString.read(from),
            destinationPubkey: FfiConverterString.read(from),
            lnurlPayInfo: FfiConverterOptionalTypeLnurlPayInfo.read(from),
            lnurlWithdrawInfo:
              FfiConverterOptionalTypeLnurlWithdrawInfo.read(from),
          });
        case 4:
          return new PaymentDetails.Withdraw({
            txId: FfiConverterString.read(from),
          });
        case 5:
          return new PaymentDetails.Deposit({
            txId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PaymentDetails_Tags.Spark: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterOptionalTypeSparkInvoicePaymentDetails.write(
            inner.invoiceDetails,
            into
          );
          return;
        }
        case PaymentDetails_Tags.Token: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeTokenMetadata.write(inner.metadata, into);
          FfiConverterString.write(inner.txHash, into);
          FfiConverterOptionalTypeSparkInvoicePaymentDetails.write(
            inner.invoiceDetails,
            into
          );
          return;
        }
        case PaymentDetails_Tags.Lightning: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.description, into);
          FfiConverterOptionalString.write(inner.preimage, into);
          FfiConverterString.write(inner.invoice, into);
          FfiConverterString.write(inner.paymentHash, into);
          FfiConverterString.write(inner.destinationPubkey, into);
          FfiConverterOptionalTypeLnurlPayInfo.write(inner.lnurlPayInfo, into);
          FfiConverterOptionalTypeLnurlWithdrawInfo.write(
            inner.lnurlWithdrawInfo,
            into
          );
          return;
        }
        case PaymentDetails_Tags.Withdraw: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.txId, into);
          return;
        }
        case PaymentDetails_Tags.Deposit: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.txId, into);
          return;
        }
        default:
          // Throwing from here means that PaymentDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PaymentDetails_Tags.Spark: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size +=
            FfiConverterOptionalTypeSparkInvoicePaymentDetails.allocationSize(
              inner.invoiceDetails
            );
          return size;
        }
        case PaymentDetails_Tags.Token: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeTokenMetadata.allocationSize(inner.metadata);
          size += FfiConverterString.allocationSize(inner.txHash);
          size +=
            FfiConverterOptionalTypeSparkInvoicePaymentDetails.allocationSize(
              inner.invoiceDetails
            );
          return size;
        }
        case PaymentDetails_Tags.Lightning: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterOptionalString.allocationSize(inner.description);
          size += FfiConverterOptionalString.allocationSize(inner.preimage);
          size += FfiConverterString.allocationSize(inner.invoice);
          size += FfiConverterString.allocationSize(inner.paymentHash);
          size += FfiConverterString.allocationSize(inner.destinationPubkey);
          size += FfiConverterOptionalTypeLnurlPayInfo.allocationSize(
            inner.lnurlPayInfo
          );
          size += FfiConverterOptionalTypeLnurlWithdrawInfo.allocationSize(
            inner.lnurlWithdrawInfo
          );
          return size;
        }
        case PaymentDetails_Tags.Withdraw: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.txId);
          return size;
        }
        case PaymentDetails_Tags.Deposit: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.txId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum PaymentMethod {
  Lightning,
  Spark,
  Token,
  Deposit,
  Withdraw,
  Unknown,
}

const FfiConverterTypePaymentMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentMethod.Lightning;
        case 2:
          return PaymentMethod.Spark;
        case 3:
          return PaymentMethod.Token;
        case 4:
          return PaymentMethod.Deposit;
        case 5:
          return PaymentMethod.Withdraw;
        case 6:
          return PaymentMethod.Unknown;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentMethod.Lightning:
          return ordinalConverter.write(1, into);
        case PaymentMethod.Spark:
          return ordinalConverter.write(2, into);
        case PaymentMethod.Token:
          return ordinalConverter.write(3, into);
        case PaymentMethod.Deposit:
          return ordinalConverter.write(4, into);
        case PaymentMethod.Withdraw:
          return ordinalConverter.write(5, into);
        case PaymentMethod.Unknown:
          return ordinalConverter.write(6, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: PaymentObserverError

// Enum: PaymentObserverError
export enum PaymentObserverError_Tags {
  ServiceConnectivity = 'ServiceConnectivity',
  Generic = 'Generic',
}
export const PaymentObserverError = (() => {
  type ServiceConnectivity__interface = {
    tag: PaymentObserverError_Tags.ServiceConnectivity;
    inner: Readonly<[string]>;
  };

  class ServiceConnectivity_
    extends UniffiError
    implements ServiceConnectivity__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentObserverError';
    readonly tag = PaymentObserverError_Tags.ServiceConnectivity;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PaymentObserverError', 'ServiceConnectivity');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): ServiceConnectivity_ {
      return new ServiceConnectivity_(v0);
    }

    static instanceOf(obj: any): obj is ServiceConnectivity_ {
      return obj.tag === PaymentObserverError_Tags.ServiceConnectivity;
    }

    static hasInner(obj: any): obj is ServiceConnectivity_ {
      return ServiceConnectivity_.instanceOf(obj);
    }

    static getInner(obj: ServiceConnectivity_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Generic__interface = {
    tag: PaymentObserverError_Tags.Generic;
    inner: Readonly<[string]>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PaymentObserverError';
    readonly tag = PaymentObserverError_Tags.Generic;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PaymentObserverError', 'Generic');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Generic_ {
      return new Generic_(v0);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === PaymentObserverError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is PaymentObserverError {
    return obj[uniffiTypeNameSymbol] === 'PaymentObserverError';
  }

  return Object.freeze({
    instanceOf,
    ServiceConnectivity: ServiceConnectivity_,
    Generic: Generic_,
  });
})();

export type PaymentObserverError = InstanceType<
  (typeof PaymentObserverError)[keyof Omit<
    typeof PaymentObserverError,
    'instanceOf'
  >]
>;

// FfiConverter for enum PaymentObserverError
const FfiConverterTypePaymentObserverError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentObserverError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PaymentObserverError.ServiceConnectivity(
            FfiConverterString.read(from)
          );
        case 2:
          return new PaymentObserverError.Generic(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PaymentObserverError_Tags.ServiceConnectivity: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case PaymentObserverError_Tags.Generic: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that PaymentObserverError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PaymentObserverError_Tags.ServiceConnectivity: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case PaymentObserverError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * The status of a payment
 */
export enum PaymentStatus {
  /**
   * Payment is completed successfully
   */
  Completed,
  /**
   * Payment is in progress
   */
  Pending,
  /**
   * Payment has failed
   */
  Failed,
}

const FfiConverterTypePaymentStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentStatus.Completed;
        case 2:
          return PaymentStatus.Pending;
        case 3:
          return PaymentStatus.Failed;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentStatus.Completed:
          return ordinalConverter.write(1, into);
        case PaymentStatus.Pending:
          return ordinalConverter.write(2, into);
        case PaymentStatus.Failed:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The type of payment
 */
export enum PaymentType {
  /**
   * Payment sent from this wallet
   */
  Send,
  /**
   * Payment received to this wallet
   */
  Receive,
}

const FfiConverterTypePaymentType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PaymentType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return PaymentType.Send;
        case 2:
          return PaymentType.Receive;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case PaymentType.Send:
          return ordinalConverter.write(1, into);
        case PaymentType.Receive:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ProvisionalPaymentDetails
export enum ProvisionalPaymentDetails_Tags {
  Bitcoin = 'Bitcoin',
  Lightning = 'Lightning',
  Spark = 'Spark',
  Token = 'Token',
}
export const ProvisionalPaymentDetails = (() => {
  type Bitcoin__interface = {
    tag: ProvisionalPaymentDetails_Tags.Bitcoin;
    inner: Readonly<{ withdrawalAddress: string }>;
  };

  class Bitcoin_ extends UniffiEnum implements Bitcoin__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProvisionalPaymentDetails';
    readonly tag = ProvisionalPaymentDetails_Tags.Bitcoin;
    readonly inner: Readonly<{ withdrawalAddress: string }>;
    constructor(inner: {
      /**
       * Onchain Bitcoin address
       */ withdrawalAddress: string;
    }) {
      super('ProvisionalPaymentDetails', 'Bitcoin');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Onchain Bitcoin address
       */ withdrawalAddress: string;
    }): Bitcoin_ {
      return new Bitcoin_(inner);
    }

    static instanceOf(obj: any): obj is Bitcoin_ {
      return obj.tag === ProvisionalPaymentDetails_Tags.Bitcoin;
    }
  }

  type Lightning__interface = {
    tag: ProvisionalPaymentDetails_Tags.Lightning;
    inner: Readonly<{ invoice: string }>;
  };

  class Lightning_ extends UniffiEnum implements Lightning__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProvisionalPaymentDetails';
    readonly tag = ProvisionalPaymentDetails_Tags.Lightning;
    readonly inner: Readonly<{ invoice: string }>;
    constructor(inner: {
      /**
       * BOLT11 invoice
       */ invoice: string;
    }) {
      super('ProvisionalPaymentDetails', 'Lightning');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * BOLT11 invoice
       */ invoice: string;
    }): Lightning_ {
      return new Lightning_(inner);
    }

    static instanceOf(obj: any): obj is Lightning_ {
      return obj.tag === ProvisionalPaymentDetails_Tags.Lightning;
    }
  }

  type Spark__interface = {
    tag: ProvisionalPaymentDetails_Tags.Spark;
    inner: Readonly<{ payRequest: string }>;
  };

  class Spark_ extends UniffiEnum implements Spark__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProvisionalPaymentDetails';
    readonly tag = ProvisionalPaymentDetails_Tags.Spark;
    readonly inner: Readonly<{ payRequest: string }>;
    constructor(inner: {
      /**
       * Spark pay request being paid (either a Spark address or a Spark invoice)
       */ payRequest: string;
    }) {
      super('ProvisionalPaymentDetails', 'Spark');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Spark pay request being paid (either a Spark address or a Spark invoice)
       */ payRequest: string;
    }): Spark_ {
      return new Spark_(inner);
    }

    static instanceOf(obj: any): obj is Spark_ {
      return obj.tag === ProvisionalPaymentDetails_Tags.Spark;
    }
  }

  type Token__interface = {
    tag: ProvisionalPaymentDetails_Tags.Token;
    inner: Readonly<{ tokenId: string; payRequest: string }>;
  };

  class Token_ extends UniffiEnum implements Token__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ProvisionalPaymentDetails';
    readonly tag = ProvisionalPaymentDetails_Tags.Token;
    readonly inner: Readonly<{ tokenId: string; payRequest: string }>;
    constructor(inner: {
      /**
       * Token identifier
       */ tokenId: string;
      /**
       * Spark pay request being paid (either a Spark address or a Spark invoice)
       */ payRequest: string;
    }) {
      super('ProvisionalPaymentDetails', 'Token');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Token identifier
       */ tokenId: string;
      /**
       * Spark pay request being paid (either a Spark address or a Spark invoice)
       */ payRequest: string;
    }): Token_ {
      return new Token_(inner);
    }

    static instanceOf(obj: any): obj is Token_ {
      return obj.tag === ProvisionalPaymentDetails_Tags.Token;
    }
  }

  function instanceOf(obj: any): obj is ProvisionalPaymentDetails {
    return obj[uniffiTypeNameSymbol] === 'ProvisionalPaymentDetails';
  }

  return Object.freeze({
    instanceOf,
    Bitcoin: Bitcoin_,
    Lightning: Lightning_,
    Spark: Spark_,
    Token: Token_,
  });
})();

export type ProvisionalPaymentDetails = InstanceType<
  (typeof ProvisionalPaymentDetails)[keyof Omit<
    typeof ProvisionalPaymentDetails,
    'instanceOf'
  >]
>;

// FfiConverter for enum ProvisionalPaymentDetails
const FfiConverterTypeProvisionalPaymentDetails = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ProvisionalPaymentDetails;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ProvisionalPaymentDetails.Bitcoin({
            withdrawalAddress: FfiConverterString.read(from),
          });
        case 2:
          return new ProvisionalPaymentDetails.Lightning({
            invoice: FfiConverterString.read(from),
          });
        case 3:
          return new ProvisionalPaymentDetails.Spark({
            payRequest: FfiConverterString.read(from),
          });
        case 4:
          return new ProvisionalPaymentDetails.Token({
            tokenId: FfiConverterString.read(from),
            payRequest: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ProvisionalPaymentDetails_Tags.Bitcoin: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.withdrawalAddress, into);
          return;
        }
        case ProvisionalPaymentDetails_Tags.Lightning: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.invoice, into);
          return;
        }
        case ProvisionalPaymentDetails_Tags.Spark: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.payRequest, into);
          return;
        }
        case ProvisionalPaymentDetails_Tags.Token: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tokenId, into);
          FfiConverterString.write(inner.payRequest, into);
          return;
        }
        default:
          // Throwing from here means that ProvisionalPaymentDetails_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ProvisionalPaymentDetails_Tags.Bitcoin: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.withdrawalAddress);
          return size;
        }
        case ProvisionalPaymentDetails_Tags.Lightning: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.invoice);
          return size;
        }
        case ProvisionalPaymentDetails_Tags.Spark: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.payRequest);
          return size;
        }
        case ProvisionalPaymentDetails_Tags.Token: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.tokenId);
          size += FfiConverterString.allocationSize(inner.payRequest);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ReceivePaymentMethod
export enum ReceivePaymentMethod_Tags {
  SparkAddress = 'SparkAddress',
  SparkInvoice = 'SparkInvoice',
  BitcoinAddress = 'BitcoinAddress',
  Bolt11Invoice = 'Bolt11Invoice',
}
export const ReceivePaymentMethod = (() => {
  type SparkAddress__interface = {
    tag: ReceivePaymentMethod_Tags.SparkAddress;
  };

  class SparkAddress_ extends UniffiEnum implements SparkAddress__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceivePaymentMethod';
    readonly tag = ReceivePaymentMethod_Tags.SparkAddress;
    constructor() {
      super('ReceivePaymentMethod', 'SparkAddress');
    }

    static new(): SparkAddress_ {
      return new SparkAddress_();
    }

    static instanceOf(obj: any): obj is SparkAddress_ {
      return obj.tag === ReceivePaymentMethod_Tags.SparkAddress;
    }
  }

  type SparkInvoice__interface = {
    tag: ReceivePaymentMethod_Tags.SparkInvoice;
    inner: Readonly<{
      amount: U128 | undefined;
      tokenIdentifier: string | undefined;
      expiryTime: /*u64*/ bigint | undefined;
      description: string | undefined;
      senderPublicKey: string | undefined;
    }>;
  };

  class SparkInvoice_ extends UniffiEnum implements SparkInvoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceivePaymentMethod';
    readonly tag = ReceivePaymentMethod_Tags.SparkInvoice;
    readonly inner: Readonly<{
      amount: U128 | undefined;
      tokenIdentifier: string | undefined;
      expiryTime: /*u64*/ bigint | undefined;
      description: string | undefined;
      senderPublicKey: string | undefined;
    }>;
    constructor(inner: {
      /**
       * Amount to receive. Denominated in sats if token identifier is empty, otherwise in the token base units
       */ amount: U128 | undefined;
      /**
       * The presence of this field indicates that the payment is for a token
       * If empty, it is a Bitcoin payment
       */ tokenIdentifier: string | undefined;
      /**
       * The expiry time of the invoice in seconds since the Unix epoch
       */ expiryTime: /*u64*/ bigint | undefined;
      /**
       * A description to embed in the invoice.
       */ description: string | undefined;
      /**
       * If set, the invoice may only be fulfilled by a payer with this public key
       */ senderPublicKey: string | undefined;
    }) {
      super('ReceivePaymentMethod', 'SparkInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Amount to receive. Denominated in sats if token identifier is empty, otherwise in the token base units
       */ amount: U128 | undefined;
      /**
       * The presence of this field indicates that the payment is for a token
       * If empty, it is a Bitcoin payment
       */ tokenIdentifier: string | undefined;
      /**
       * The expiry time of the invoice in seconds since the Unix epoch
       */ expiryTime: /*u64*/ bigint | undefined;
      /**
       * A description to embed in the invoice.
       */ description: string | undefined;
      /**
       * If set, the invoice may only be fulfilled by a payer with this public key
       */ senderPublicKey: string | undefined;
    }): SparkInvoice_ {
      return new SparkInvoice_(inner);
    }

    static instanceOf(obj: any): obj is SparkInvoice_ {
      return obj.tag === ReceivePaymentMethod_Tags.SparkInvoice;
    }
  }

  type BitcoinAddress__interface = {
    tag: ReceivePaymentMethod_Tags.BitcoinAddress;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceivePaymentMethod';
    readonly tag = ReceivePaymentMethod_Tags.BitcoinAddress;
    constructor() {
      super('ReceivePaymentMethod', 'BitcoinAddress');
    }

    static new(): BitcoinAddress_ {
      return new BitcoinAddress_();
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === ReceivePaymentMethod_Tags.BitcoinAddress;
    }
  }

  type Bolt11Invoice__interface = {
    tag: ReceivePaymentMethod_Tags.Bolt11Invoice;
    inner: Readonly<{
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }>;
  };

  class Bolt11Invoice_ extends UniffiEnum implements Bolt11Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReceivePaymentMethod';
    readonly tag = ReceivePaymentMethod_Tags.Bolt11Invoice;
    readonly inner: Readonly<{
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }>;
    constructor(inner: {
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }) {
      super('ReceivePaymentMethod', 'Bolt11Invoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      description: string;
      amountSats: /*u64*/ bigint | undefined;
    }): Bolt11Invoice_ {
      return new Bolt11Invoice_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11Invoice_ {
      return obj.tag === ReceivePaymentMethod_Tags.Bolt11Invoice;
    }
  }

  function instanceOf(obj: any): obj is ReceivePaymentMethod {
    return obj[uniffiTypeNameSymbol] === 'ReceivePaymentMethod';
  }

  return Object.freeze({
    instanceOf,
    SparkAddress: SparkAddress_,
    SparkInvoice: SparkInvoice_,
    BitcoinAddress: BitcoinAddress_,
    Bolt11Invoice: Bolt11Invoice_,
  });
})();

export type ReceivePaymentMethod = InstanceType<
  (typeof ReceivePaymentMethod)[keyof Omit<
    typeof ReceivePaymentMethod,
    'instanceOf'
  >]
>;

// FfiConverter for enum ReceivePaymentMethod
const FfiConverterTypeReceivePaymentMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ReceivePaymentMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ReceivePaymentMethod.SparkAddress();
        case 2:
          return new ReceivePaymentMethod.SparkInvoice({
            amount: FfiConverterOptionalTypeu128.read(from),
            tokenIdentifier: FfiConverterOptionalString.read(from),
            expiryTime: FfiConverterOptionalUInt64.read(from),
            description: FfiConverterOptionalString.read(from),
            senderPublicKey: FfiConverterOptionalString.read(from),
          });
        case 3:
          return new ReceivePaymentMethod.BitcoinAddress();
        case 4:
          return new ReceivePaymentMethod.Bolt11Invoice({
            description: FfiConverterString.read(from),
            amountSats: FfiConverterOptionalUInt64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ReceivePaymentMethod_Tags.SparkAddress: {
          ordinalConverter.write(1, into);
          return;
        }
        case ReceivePaymentMethod_Tags.SparkInvoice: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalTypeu128.write(inner.amount, into);
          FfiConverterOptionalString.write(inner.tokenIdentifier, into);
          FfiConverterOptionalUInt64.write(inner.expiryTime, into);
          FfiConverterOptionalString.write(inner.description, into);
          FfiConverterOptionalString.write(inner.senderPublicKey, into);
          return;
        }
        case ReceivePaymentMethod_Tags.BitcoinAddress: {
          ordinalConverter.write(3, into);
          return;
        }
        case ReceivePaymentMethod_Tags.Bolt11Invoice: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.description, into);
          FfiConverterOptionalUInt64.write(inner.amountSats, into);
          return;
        }
        default:
          // Throwing from here means that ReceivePaymentMethod_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ReceivePaymentMethod_Tags.SparkAddress: {
          return ordinalConverter.allocationSize(1);
        }
        case ReceivePaymentMethod_Tags.SparkInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalTypeu128.allocationSize(inner.amount);
          size += FfiConverterOptionalString.allocationSize(
            inner.tokenIdentifier
          );
          size += FfiConverterOptionalUInt64.allocationSize(inner.expiryTime);
          size += FfiConverterOptionalString.allocationSize(inner.description);
          size += FfiConverterOptionalString.allocationSize(
            inner.senderPublicKey
          );
          return size;
        }
        case ReceivePaymentMethod_Tags.BitcoinAddress: {
          return ordinalConverter.allocationSize(3);
        }
        case ReceivePaymentMethod_Tags.Bolt11Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.description);
          size += FfiConverterOptionalUInt64.allocationSize(inner.amountSats);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: SdkError

// Enum: SdkError
export enum SdkError_Tags {
  SparkError = 'SparkError',
  InvalidUuid = 'InvalidUuid',
  InvalidInput = 'InvalidInput',
  NetworkError = 'NetworkError',
  StorageError = 'StorageError',
  ChainServiceError = 'ChainServiceError',
  DepositClaimFeeExceeded = 'DepositClaimFeeExceeded',
  MissingUtxo = 'MissingUtxo',
  LnurlError = 'LnurlError',
  Generic = 'Generic',
}
/**
 * Error type for the `BreezSdk`
 */
export const SdkError = (() => {
  type SparkError__interface = {
    tag: SdkError_Tags.SparkError;
    inner: Readonly<[string]>;
  };

  class SparkError_ extends UniffiError implements SparkError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.SparkError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'SparkError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): SparkError_ {
      return new SparkError_(v0);
    }

    static instanceOf(obj: any): obj is SparkError_ {
      return obj.tag === SdkError_Tags.SparkError;
    }

    static hasInner(obj: any): obj is SparkError_ {
      return SparkError_.instanceOf(obj);
    }

    static getInner(obj: SparkError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidUuid__interface = {
    tag: SdkError_Tags.InvalidUuid;
    inner: Readonly<[string]>;
  };

  class InvalidUuid_ extends UniffiError implements InvalidUuid__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.InvalidUuid;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'InvalidUuid');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidUuid_ {
      return new InvalidUuid_(v0);
    }

    static instanceOf(obj: any): obj is InvalidUuid_ {
      return obj.tag === SdkError_Tags.InvalidUuid;
    }

    static hasInner(obj: any): obj is InvalidUuid_ {
      return InvalidUuid_.instanceOf(obj);
    }

    static getInner(obj: InvalidUuid_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidInput__interface = {
    tag: SdkError_Tags.InvalidInput;
    inner: Readonly<[string]>;
  };

  /**
   * Invalid input error
   */
  class InvalidInput_ extends UniffiError implements InvalidInput__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.InvalidInput;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'InvalidInput');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidInput_ {
      return new InvalidInput_(v0);
    }

    static instanceOf(obj: any): obj is InvalidInput_ {
      return obj.tag === SdkError_Tags.InvalidInput;
    }

    static hasInner(obj: any): obj is InvalidInput_ {
      return InvalidInput_.instanceOf(obj);
    }

    static getInner(obj: InvalidInput_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type NetworkError__interface = {
    tag: SdkError_Tags.NetworkError;
    inner: Readonly<[string]>;
  };

  /**
   * Network error
   */
  class NetworkError_ extends UniffiError implements NetworkError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.NetworkError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'NetworkError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): NetworkError_ {
      return new NetworkError_(v0);
    }

    static instanceOf(obj: any): obj is NetworkError_ {
      return obj.tag === SdkError_Tags.NetworkError;
    }

    static hasInner(obj: any): obj is NetworkError_ {
      return NetworkError_.instanceOf(obj);
    }

    static getInner(obj: NetworkError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type StorageError__interface = {
    tag: SdkError_Tags.StorageError;
    inner: Readonly<[string]>;
  };

  /**
   * Storage error
   */
  class StorageError_ extends UniffiError implements StorageError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.StorageError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'StorageError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): StorageError_ {
      return new StorageError_(v0);
    }

    static instanceOf(obj: any): obj is StorageError_ {
      return obj.tag === SdkError_Tags.StorageError;
    }

    static hasInner(obj: any): obj is StorageError_ {
      return StorageError_.instanceOf(obj);
    }

    static getInner(obj: StorageError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type ChainServiceError__interface = {
    tag: SdkError_Tags.ChainServiceError;
    inner: Readonly<[string]>;
  };

  class ChainServiceError_
    extends UniffiError
    implements ChainServiceError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.ChainServiceError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'ChainServiceError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): ChainServiceError_ {
      return new ChainServiceError_(v0);
    }

    static instanceOf(obj: any): obj is ChainServiceError_ {
      return obj.tag === SdkError_Tags.ChainServiceError;
    }

    static hasInner(obj: any): obj is ChainServiceError_ {
      return ChainServiceError_.instanceOf(obj);
    }

    static getInner(obj: ChainServiceError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type DepositClaimFeeExceeded__interface = {
    tag: SdkError_Tags.DepositClaimFeeExceeded;
    inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee | undefined;
      actualFee: /*u64*/ bigint;
    }>;
  };

  class DepositClaimFeeExceeded_
    extends UniffiError
    implements DepositClaimFeeExceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.DepositClaimFeeExceeded;
    readonly inner: Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee | undefined;
      actualFee: /*u64*/ bigint;
    }>;
    constructor(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee | undefined;
      actualFee: /*u64*/ bigint;
    }) {
      super('SdkError', 'DepositClaimFeeExceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee | undefined;
      actualFee: /*u64*/ bigint;
    }): DepositClaimFeeExceeded_ {
      return new DepositClaimFeeExceeded_(inner);
    }

    static instanceOf(obj: any): obj is DepositClaimFeeExceeded_ {
      return obj.tag === SdkError_Tags.DepositClaimFeeExceeded;
    }

    static hasInner(obj: any): obj is DepositClaimFeeExceeded_ {
      return DepositClaimFeeExceeded_.instanceOf(obj);
    }

    static getInner(
      obj: DepositClaimFeeExceeded_
    ): Readonly<{
      tx: string;
      vout: /*u32*/ number;
      maxFee: Fee | undefined;
      actualFee: /*u64*/ bigint;
    }> {
      return obj.inner;
    }
  }

  type MissingUtxo__interface = {
    tag: SdkError_Tags.MissingUtxo;
    inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
  };

  class MissingUtxo_ extends UniffiError implements MissingUtxo__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.MissingUtxo;
    readonly inner: Readonly<{ tx: string; vout: /*u32*/ number }>;
    constructor(inner: { tx: string; vout: /*u32*/ number }) {
      super('SdkError', 'MissingUtxo');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { tx: string; vout: /*u32*/ number }): MissingUtxo_ {
      return new MissingUtxo_(inner);
    }

    static instanceOf(obj: any): obj is MissingUtxo_ {
      return obj.tag === SdkError_Tags.MissingUtxo;
    }

    static hasInner(obj: any): obj is MissingUtxo_ {
      return MissingUtxo_.instanceOf(obj);
    }

    static getInner(
      obj: MissingUtxo_
    ): Readonly<{ tx: string; vout: /*u32*/ number }> {
      return obj.inner;
    }
  }

  type LnurlError__interface = {
    tag: SdkError_Tags.LnurlError;
    inner: Readonly<[string]>;
  };

  class LnurlError_ extends UniffiError implements LnurlError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.LnurlError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'LnurlError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): LnurlError_ {
      return new LnurlError_(v0);
    }

    static instanceOf(obj: any): obj is LnurlError_ {
      return obj.tag === SdkError_Tags.LnurlError;
    }

    static hasInner(obj: any): obj is LnurlError_ {
      return LnurlError_.instanceOf(obj);
    }

    static getInner(obj: LnurlError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Generic__interface = {
    tag: SdkError_Tags.Generic;
    inner: Readonly<[string]>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkError';
    readonly tag = SdkError_Tags.Generic;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SdkError', 'Generic');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Generic_ {
      return new Generic_(v0);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === SdkError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is SdkError {
    return obj[uniffiTypeNameSymbol] === 'SdkError';
  }

  return Object.freeze({
    instanceOf,
    SparkError: SparkError_,
    InvalidUuid: InvalidUuid_,
    InvalidInput: InvalidInput_,
    NetworkError: NetworkError_,
    StorageError: StorageError_,
    ChainServiceError: ChainServiceError_,
    DepositClaimFeeExceeded: DepositClaimFeeExceeded_,
    MissingUtxo: MissingUtxo_,
    LnurlError: LnurlError_,
    Generic: Generic_,
  });
})();

/**
 * Error type for the `BreezSdk`
 */

export type SdkError = InstanceType<
  (typeof SdkError)[keyof Omit<typeof SdkError, 'instanceOf'>]
>;

// FfiConverter for enum SdkError
const FfiConverterTypeSdkError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SdkError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SdkError.SparkError(FfiConverterString.read(from));
        case 2:
          return new SdkError.InvalidUuid(FfiConverterString.read(from));
        case 3:
          return new SdkError.InvalidInput(FfiConverterString.read(from));
        case 4:
          return new SdkError.NetworkError(FfiConverterString.read(from));
        case 5:
          return new SdkError.StorageError(FfiConverterString.read(from));
        case 6:
          return new SdkError.ChainServiceError(FfiConverterString.read(from));
        case 7:
          return new SdkError.DepositClaimFeeExceeded({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
            maxFee: FfiConverterOptionalTypeFee.read(from),
            actualFee: FfiConverterUInt64.read(from),
          });
        case 8:
          return new SdkError.MissingUtxo({
            tx: FfiConverterString.read(from),
            vout: FfiConverterUInt32.read(from),
          });
        case 9:
          return new SdkError.LnurlError(FfiConverterString.read(from));
        case 10:
          return new SdkError.Generic(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SdkError_Tags.SparkError: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.InvalidUuid: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.InvalidInput: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.NetworkError: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.StorageError: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.ChainServiceError: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.DepositClaimFeeExceeded: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          FfiConverterOptionalTypeFee.write(inner.maxFee, into);
          FfiConverterUInt64.write(inner.actualFee, into);
          return;
        }
        case SdkError_Tags.MissingUtxo: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner.tx, into);
          FfiConverterUInt32.write(inner.vout, into);
          return;
        }
        case SdkError_Tags.LnurlError: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SdkError_Tags.Generic: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that SdkError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SdkError_Tags.SparkError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.InvalidUuid: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.InvalidInput: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.NetworkError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.StorageError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.ChainServiceError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.DepositClaimFeeExceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          size += FfiConverterOptionalTypeFee.allocationSize(inner.maxFee);
          size += FfiConverterUInt64.allocationSize(inner.actualFee);
          return size;
        }
        case SdkError_Tags.MissingUtxo: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner.tx);
          size += FfiConverterUInt32.allocationSize(inner.vout);
          return size;
        }
        case SdkError_Tags.LnurlError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SdkError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SdkEvent
export enum SdkEvent_Tags {
  Synced = 'Synced',
  DataSynced = 'DataSynced',
  UnclaimedDeposits = 'UnclaimedDeposits',
  ClaimedDeposits = 'ClaimedDeposits',
  PaymentSucceeded = 'PaymentSucceeded',
  PaymentPending = 'PaymentPending',
  PaymentFailed = 'PaymentFailed',
}
/**
 * Events emitted by the SDK
 */
export const SdkEvent = (() => {
  type Synced__interface = {
    tag: SdkEvent_Tags.Synced;
  };

  /**
   * Emitted when the wallet has been synchronized with the network
   */
  class Synced_ extends UniffiEnum implements Synced__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.Synced;
    constructor() {
      super('SdkEvent', 'Synced');
    }

    static new(): Synced_ {
      return new Synced_();
    }

    static instanceOf(obj: any): obj is Synced_ {
      return obj.tag === SdkEvent_Tags.Synced;
    }
  }

  type DataSynced__interface = {
    tag: SdkEvent_Tags.DataSynced;
    inner: Readonly<{ didPullNewRecords: boolean }>;
  };

  /**
   * Emitted when data was pushed and/or pulled to/from real-time sync storage.
   */
  class DataSynced_ extends UniffiEnum implements DataSynced__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.DataSynced;
    readonly inner: Readonly<{ didPullNewRecords: boolean }>;
    constructor(inner: {
      /**
       * Value indicating whether new data was pulled through real-time sync.
       */ didPullNewRecords: boolean;
    }) {
      super('SdkEvent', 'DataSynced');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Value indicating whether new data was pulled through real-time sync.
       */ didPullNewRecords: boolean;
    }): DataSynced_ {
      return new DataSynced_(inner);
    }

    static instanceOf(obj: any): obj is DataSynced_ {
      return obj.tag === SdkEvent_Tags.DataSynced;
    }
  }

  type UnclaimedDeposits__interface = {
    tag: SdkEvent_Tags.UnclaimedDeposits;
    inner: Readonly<{ unclaimedDeposits: Array<DepositInfo> }>;
  };

  /**
   * Emitted when the SDK was unable to claim deposits
   */
  class UnclaimedDeposits_
    extends UniffiEnum
    implements UnclaimedDeposits__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.UnclaimedDeposits;
    readonly inner: Readonly<{ unclaimedDeposits: Array<DepositInfo> }>;
    constructor(inner: { unclaimedDeposits: Array<DepositInfo> }) {
      super('SdkEvent', 'UnclaimedDeposits');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      unclaimedDeposits: Array<DepositInfo>;
    }): UnclaimedDeposits_ {
      return new UnclaimedDeposits_(inner);
    }

    static instanceOf(obj: any): obj is UnclaimedDeposits_ {
      return obj.tag === SdkEvent_Tags.UnclaimedDeposits;
    }
  }

  type ClaimedDeposits__interface = {
    tag: SdkEvent_Tags.ClaimedDeposits;
    inner: Readonly<{ claimedDeposits: Array<DepositInfo> }>;
  };

  class ClaimedDeposits_
    extends UniffiEnum
    implements ClaimedDeposits__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.ClaimedDeposits;
    readonly inner: Readonly<{ claimedDeposits: Array<DepositInfo> }>;
    constructor(inner: { claimedDeposits: Array<DepositInfo> }) {
      super('SdkEvent', 'ClaimedDeposits');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      claimedDeposits: Array<DepositInfo>;
    }): ClaimedDeposits_ {
      return new ClaimedDeposits_(inner);
    }

    static instanceOf(obj: any): obj is ClaimedDeposits_ {
      return obj.tag === SdkEvent_Tags.ClaimedDeposits;
    }
  }

  type PaymentSucceeded__interface = {
    tag: SdkEvent_Tags.PaymentSucceeded;
    inner: Readonly<{ payment: Payment }>;
  };

  class PaymentSucceeded_
    extends UniffiEnum
    implements PaymentSucceeded__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentSucceeded;
    readonly inner: Readonly<{ payment: Payment }>;
    constructor(inner: { payment: Payment }) {
      super('SdkEvent', 'PaymentSucceeded');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payment: Payment }): PaymentSucceeded_ {
      return new PaymentSucceeded_(inner);
    }

    static instanceOf(obj: any): obj is PaymentSucceeded_ {
      return obj.tag === SdkEvent_Tags.PaymentSucceeded;
    }
  }

  type PaymentPending__interface = {
    tag: SdkEvent_Tags.PaymentPending;
    inner: Readonly<{ payment: Payment }>;
  };

  class PaymentPending_
    extends UniffiEnum
    implements PaymentPending__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentPending;
    readonly inner: Readonly<{ payment: Payment }>;
    constructor(inner: { payment: Payment }) {
      super('SdkEvent', 'PaymentPending');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payment: Payment }): PaymentPending_ {
      return new PaymentPending_(inner);
    }

    static instanceOf(obj: any): obj is PaymentPending_ {
      return obj.tag === SdkEvent_Tags.PaymentPending;
    }
  }

  type PaymentFailed__interface = {
    tag: SdkEvent_Tags.PaymentFailed;
    inner: Readonly<{ payment: Payment }>;
  };

  class PaymentFailed_ extends UniffiEnum implements PaymentFailed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SdkEvent';
    readonly tag = SdkEvent_Tags.PaymentFailed;
    readonly inner: Readonly<{ payment: Payment }>;
    constructor(inner: { payment: Payment }) {
      super('SdkEvent', 'PaymentFailed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payment: Payment }): PaymentFailed_ {
      return new PaymentFailed_(inner);
    }

    static instanceOf(obj: any): obj is PaymentFailed_ {
      return obj.tag === SdkEvent_Tags.PaymentFailed;
    }
  }

  function instanceOf(obj: any): obj is SdkEvent {
    return obj[uniffiTypeNameSymbol] === 'SdkEvent';
  }

  return Object.freeze({
    instanceOf,
    Synced: Synced_,
    DataSynced: DataSynced_,
    UnclaimedDeposits: UnclaimedDeposits_,
    ClaimedDeposits: ClaimedDeposits_,
    PaymentSucceeded: PaymentSucceeded_,
    PaymentPending: PaymentPending_,
    PaymentFailed: PaymentFailed_,
  });
})();

/**
 * Events emitted by the SDK
 */

export type SdkEvent = InstanceType<
  (typeof SdkEvent)[keyof Omit<typeof SdkEvent, 'instanceOf'>]
>;

// FfiConverter for enum SdkEvent
const FfiConverterTypeSdkEvent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SdkEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SdkEvent.Synced();
        case 2:
          return new SdkEvent.DataSynced({
            didPullNewRecords: FfiConverterBool.read(from),
          });
        case 3:
          return new SdkEvent.UnclaimedDeposits({
            unclaimedDeposits: FfiConverterArrayTypeDepositInfo.read(from),
          });
        case 4:
          return new SdkEvent.ClaimedDeposits({
            claimedDeposits: FfiConverterArrayTypeDepositInfo.read(from),
          });
        case 5:
          return new SdkEvent.PaymentSucceeded({
            payment: FfiConverterTypePayment.read(from),
          });
        case 6:
          return new SdkEvent.PaymentPending({
            payment: FfiConverterTypePayment.read(from),
          });
        case 7:
          return new SdkEvent.PaymentFailed({
            payment: FfiConverterTypePayment.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SdkEvent_Tags.Synced: {
          ordinalConverter.write(1, into);
          return;
        }
        case SdkEvent_Tags.DataSynced: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.didPullNewRecords, into);
          return;
        }
        case SdkEvent_Tags.UnclaimedDeposits: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterArrayTypeDepositInfo.write(inner.unclaimedDeposits, into);
          return;
        }
        case SdkEvent_Tags.ClaimedDeposits: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterArrayTypeDepositInfo.write(inner.claimedDeposits, into);
          return;
        }
        case SdkEvent_Tags.PaymentSucceeded: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.payment, into);
          return;
        }
        case SdkEvent_Tags.PaymentPending: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.payment, into);
          return;
        }
        case SdkEvent_Tags.PaymentFailed: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypePayment.write(inner.payment, into);
          return;
        }
        default:
          // Throwing from here means that SdkEvent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SdkEvent_Tags.Synced: {
          return ordinalConverter.allocationSize(1);
        }
        case SdkEvent_Tags.DataSynced: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterBool.allocationSize(inner.didPullNewRecords);
          return size;
        }
        case SdkEvent_Tags.UnclaimedDeposits: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterArrayTypeDepositInfo.allocationSize(
            inner.unclaimedDeposits
          );
          return size;
        }
        case SdkEvent_Tags.ClaimedDeposits: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterArrayTypeDepositInfo.allocationSize(
            inner.claimedDeposits
          );
          return size;
        }
        case SdkEvent_Tags.PaymentSucceeded: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypePayment.allocationSize(inner.payment);
          return size;
        }
        case SdkEvent_Tags.PaymentPending: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypePayment.allocationSize(inner.payment);
          return size;
        }
        case SdkEvent_Tags.PaymentFailed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypePayment.allocationSize(inner.payment);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Seed
export enum Seed_Tags {
  Mnemonic = 'Mnemonic',
  Entropy = 'Entropy',
}
/**
 * Represents the seed for wallet generation, either as a mnemonic phrase with an optional
 * passphrase or as raw entropy bytes.
 */
export const Seed = (() => {
  type Mnemonic__interface = {
    tag: Seed_Tags.Mnemonic;
    inner: Readonly<{ mnemonic: string; passphrase: string | undefined }>;
  };

  /**
   * A BIP-39 mnemonic phrase with an optional passphrase.
   */
  class Mnemonic_ extends UniffiEnum implements Mnemonic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Seed';
    readonly tag = Seed_Tags.Mnemonic;
    readonly inner: Readonly<{
      mnemonic: string;
      passphrase: string | undefined;
    }>;
    constructor(inner: {
      /**
       * The mnemonic phrase. 12 or 24 words.
       */ mnemonic: string;
      /**
       * An optional passphrase for the mnemonic.
       */ passphrase: string | undefined;
    }) {
      super('Seed', 'Mnemonic');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The mnemonic phrase. 12 or 24 words.
       */ mnemonic: string;
      /**
       * An optional passphrase for the mnemonic.
       */ passphrase: string | undefined;
    }): Mnemonic_ {
      return new Mnemonic_(inner);
    }

    static instanceOf(obj: any): obj is Mnemonic_ {
      return obj.tag === Seed_Tags.Mnemonic;
    }
  }

  type Entropy__interface = {
    tag: Seed_Tags.Entropy;
    inner: Readonly<[ArrayBuffer]>;
  };

  /**
   * Raw entropy bytes.
   */
  class Entropy_ extends UniffiEnum implements Entropy__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Seed';
    readonly tag = Seed_Tags.Entropy;
    readonly inner: Readonly<[ArrayBuffer]>;
    constructor(v0: ArrayBuffer) {
      super('Seed', 'Entropy');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: ArrayBuffer): Entropy_ {
      return new Entropy_(v0);
    }

    static instanceOf(obj: any): obj is Entropy_ {
      return obj.tag === Seed_Tags.Entropy;
    }
  }

  function instanceOf(obj: any): obj is Seed {
    return obj[uniffiTypeNameSymbol] === 'Seed';
  }

  return Object.freeze({
    instanceOf,
    Mnemonic: Mnemonic_,
    Entropy: Entropy_,
  });
})();

/**
 * Represents the seed for wallet generation, either as a mnemonic phrase with an optional
 * passphrase or as raw entropy bytes.
 */

export type Seed = InstanceType<
  (typeof Seed)[keyof Omit<typeof Seed, 'instanceOf'>]
>;

// FfiConverter for enum Seed
const FfiConverterTypeSeed = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Seed;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Seed.Mnemonic({
            mnemonic: FfiConverterString.read(from),
            passphrase: FfiConverterOptionalString.read(from),
          });
        case 2:
          return new Seed.Entropy(FfiConverterArrayBuffer.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Seed_Tags.Mnemonic: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.mnemonic, into);
          FfiConverterOptionalString.write(inner.passphrase, into);
          return;
        }
        case Seed_Tags.Entropy: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayBuffer.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that Seed_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Seed_Tags.Mnemonic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.mnemonic);
          size += FfiConverterOptionalString.allocationSize(inner.passphrase);
          return size;
        }
        case Seed_Tags.Entropy: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayBuffer.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SendPaymentMethod
export enum SendPaymentMethod_Tags {
  BitcoinAddress = 'BitcoinAddress',
  Bolt11Invoice = 'Bolt11Invoice',
  SparkAddress = 'SparkAddress',
  SparkInvoice = 'SparkInvoice',
}
export const SendPaymentMethod = (() => {
  type BitcoinAddress__interface = {
    tag: SendPaymentMethod_Tags.BitcoinAddress;
    inner: Readonly<{
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }>;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentMethod';
    readonly tag = SendPaymentMethod_Tags.BitcoinAddress;
    readonly inner: Readonly<{
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }>;
    constructor(inner: {
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }) {
      super('SendPaymentMethod', 'BitcoinAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      address: BitcoinAddressDetails;
      feeQuote: SendOnchainFeeQuote;
    }): BitcoinAddress_ {
      return new BitcoinAddress_(inner);
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === SendPaymentMethod_Tags.BitcoinAddress;
    }
  }

  type Bolt11Invoice__interface = {
    tag: SendPaymentMethod_Tags.Bolt11Invoice;
    inner: Readonly<{
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }>;
  };

  class Bolt11Invoice_ extends UniffiEnum implements Bolt11Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentMethod';
    readonly tag = SendPaymentMethod_Tags.Bolt11Invoice;
    readonly inner: Readonly<{
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }>;
    constructor(inner: {
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }) {
      super('SendPaymentMethod', 'Bolt11Invoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      invoiceDetails: Bolt11InvoiceDetails;
      sparkTransferFeeSats: /*u64*/ bigint | undefined;
      lightningFeeSats: /*u64*/ bigint;
    }): Bolt11Invoice_ {
      return new Bolt11Invoice_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11Invoice_ {
      return obj.tag === SendPaymentMethod_Tags.Bolt11Invoice;
    }
  }

  type SparkAddress__interface = {
    tag: SendPaymentMethod_Tags.SparkAddress;
    inner: Readonly<{
      address: string;
      fee: U128;
      tokenIdentifier: string | undefined;
    }>;
  };

  class SparkAddress_ extends UniffiEnum implements SparkAddress__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentMethod';
    readonly tag = SendPaymentMethod_Tags.SparkAddress;
    readonly inner: Readonly<{
      address: string;
      fee: U128;
      tokenIdentifier: string | undefined;
    }>;
    constructor(inner: {
      address: string;
      /**
       * Fee to pay for the transaction
       * Denominated in sats if token identifier is empty, otherwise in the token base units
       */ fee: U128;
      /**
       * The presence of this field indicates that the payment is for a token
       * If empty, it is a Bitcoin payment
       */ tokenIdentifier: string | undefined;
    }) {
      super('SendPaymentMethod', 'SparkAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      address: string;
      /**
       * Fee to pay for the transaction
       * Denominated in sats if token identifier is empty, otherwise in the token base units
       */ fee: U128;
      /**
       * The presence of this field indicates that the payment is for a token
       * If empty, it is a Bitcoin payment
       */ tokenIdentifier: string | undefined;
    }): SparkAddress_ {
      return new SparkAddress_(inner);
    }

    static instanceOf(obj: any): obj is SparkAddress_ {
      return obj.tag === SendPaymentMethod_Tags.SparkAddress;
    }
  }

  type SparkInvoice__interface = {
    tag: SendPaymentMethod_Tags.SparkInvoice;
    inner: Readonly<{
      sparkInvoiceDetails: SparkInvoiceDetails;
      fee: U128;
      tokenIdentifier: string | undefined;
    }>;
  };

  class SparkInvoice_ extends UniffiEnum implements SparkInvoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentMethod';
    readonly tag = SendPaymentMethod_Tags.SparkInvoice;
    readonly inner: Readonly<{
      sparkInvoiceDetails: SparkInvoiceDetails;
      fee: U128;
      tokenIdentifier: string | undefined;
    }>;
    constructor(inner: {
      sparkInvoiceDetails: SparkInvoiceDetails;
      /**
       * Fee to pay for the transaction
       * Denominated in sats if token identifier is empty, otherwise in the token base units
       */ fee: U128;
      /**
       * The presence of this field indicates that the payment is for a token
       * If empty, it is a Bitcoin payment
       */ tokenIdentifier: string | undefined;
    }) {
      super('SendPaymentMethod', 'SparkInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      sparkInvoiceDetails: SparkInvoiceDetails;
      /**
       * Fee to pay for the transaction
       * Denominated in sats if token identifier is empty, otherwise in the token base units
       */ fee: U128;
      /**
       * The presence of this field indicates that the payment is for a token
       * If empty, it is a Bitcoin payment
       */ tokenIdentifier: string | undefined;
    }): SparkInvoice_ {
      return new SparkInvoice_(inner);
    }

    static instanceOf(obj: any): obj is SparkInvoice_ {
      return obj.tag === SendPaymentMethod_Tags.SparkInvoice;
    }
  }

  function instanceOf(obj: any): obj is SendPaymentMethod {
    return obj[uniffiTypeNameSymbol] === 'SendPaymentMethod';
  }

  return Object.freeze({
    instanceOf,
    BitcoinAddress: BitcoinAddress_,
    Bolt11Invoice: Bolt11Invoice_,
    SparkAddress: SparkAddress_,
    SparkInvoice: SparkInvoice_,
  });
})();

export type SendPaymentMethod = InstanceType<
  (typeof SendPaymentMethod)[keyof Omit<typeof SendPaymentMethod, 'instanceOf'>]
>;

// FfiConverter for enum SendPaymentMethod
const FfiConverterTypeSendPaymentMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SendPaymentMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SendPaymentMethod.BitcoinAddress({
            address: FfiConverterTypeBitcoinAddressDetails.read(from),
            feeQuote: FfiConverterTypeSendOnchainFeeQuote.read(from),
          });
        case 2:
          return new SendPaymentMethod.Bolt11Invoice({
            invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.read(from),
            sparkTransferFeeSats: FfiConverterOptionalUInt64.read(from),
            lightningFeeSats: FfiConverterUInt64.read(from),
          });
        case 3:
          return new SendPaymentMethod.SparkAddress({
            address: FfiConverterString.read(from),
            fee: FfiConverterTypeu128.read(from),
            tokenIdentifier: FfiConverterOptionalString.read(from),
          });
        case 4:
          return new SendPaymentMethod.SparkInvoice({
            sparkInvoiceDetails: FfiConverterTypeSparkInvoiceDetails.read(from),
            fee: FfiConverterTypeu128.read(from),
            tokenIdentifier: FfiConverterOptionalString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SendPaymentMethod_Tags.BitcoinAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeBitcoinAddressDetails.write(inner.address, into);
          FfiConverterTypeSendOnchainFeeQuote.write(inner.feeQuote, into);
          return;
        }
        case SendPaymentMethod_Tags.Bolt11Invoice: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeBolt11InvoiceDetails.write(
            inner.invoiceDetails,
            into
          );
          FfiConverterOptionalUInt64.write(inner.sparkTransferFeeSats, into);
          FfiConverterUInt64.write(inner.lightningFeeSats, into);
          return;
        }
        case SendPaymentMethod_Tags.SparkAddress: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.address, into);
          FfiConverterTypeu128.write(inner.fee, into);
          FfiConverterOptionalString.write(inner.tokenIdentifier, into);
          return;
        }
        case SendPaymentMethod_Tags.SparkInvoice: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeSparkInvoiceDetails.write(
            inner.sparkInvoiceDetails,
            into
          );
          FfiConverterTypeu128.write(inner.fee, into);
          FfiConverterOptionalString.write(inner.tokenIdentifier, into);
          return;
        }
        default:
          // Throwing from here means that SendPaymentMethod_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SendPaymentMethod_Tags.BitcoinAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeBitcoinAddressDetails.allocationSize(
            inner.address
          );
          size += FfiConverterTypeSendOnchainFeeQuote.allocationSize(
            inner.feeQuote
          );
          return size;
        }
        case SendPaymentMethod_Tags.Bolt11Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeBolt11InvoiceDetails.allocationSize(
            inner.invoiceDetails
          );
          size += FfiConverterOptionalUInt64.allocationSize(
            inner.sparkTransferFeeSats
          );
          size += FfiConverterUInt64.allocationSize(inner.lightningFeeSats);
          return size;
        }
        case SendPaymentMethod_Tags.SparkAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.address);
          size += FfiConverterTypeu128.allocationSize(inner.fee);
          size += FfiConverterOptionalString.allocationSize(
            inner.tokenIdentifier
          );
          return size;
        }
        case SendPaymentMethod_Tags.SparkInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeSparkInvoiceDetails.allocationSize(
            inner.sparkInvoiceDetails
          );
          size += FfiConverterTypeu128.allocationSize(inner.fee);
          size += FfiConverterOptionalString.allocationSize(
            inner.tokenIdentifier
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SendPaymentOptions
export enum SendPaymentOptions_Tags {
  BitcoinAddress = 'BitcoinAddress',
  Bolt11Invoice = 'Bolt11Invoice',
}
export const SendPaymentOptions = (() => {
  type BitcoinAddress__interface = {
    tag: SendPaymentOptions_Tags.BitcoinAddress;
    inner: Readonly<{ confirmationSpeed: OnchainConfirmationSpeed }>;
  };

  class BitcoinAddress_
    extends UniffiEnum
    implements BitcoinAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentOptions';
    readonly tag = SendPaymentOptions_Tags.BitcoinAddress;
    readonly inner: Readonly<{ confirmationSpeed: OnchainConfirmationSpeed }>;
    constructor(inner: { confirmationSpeed: OnchainConfirmationSpeed }) {
      super('SendPaymentOptions', 'BitcoinAddress');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      confirmationSpeed: OnchainConfirmationSpeed;
    }): BitcoinAddress_ {
      return new BitcoinAddress_(inner);
    }

    static instanceOf(obj: any): obj is BitcoinAddress_ {
      return obj.tag === SendPaymentOptions_Tags.BitcoinAddress;
    }
  }

  type Bolt11Invoice__interface = {
    tag: SendPaymentOptions_Tags.Bolt11Invoice;
    inner: Readonly<{
      preferSpark: boolean;
      completionTimeoutSecs: /*u32*/ number | undefined;
    }>;
  };

  class Bolt11Invoice_ extends UniffiEnum implements Bolt11Invoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendPaymentOptions';
    readonly tag = SendPaymentOptions_Tags.Bolt11Invoice;
    readonly inner: Readonly<{
      preferSpark: boolean;
      completionTimeoutSecs: /*u32*/ number | undefined;
    }>;
    constructor(inner: {
      preferSpark: boolean;
      /**
       * If set, the function will return the payment if it is still pending after this
       * number of seconds. If unset, the function will return immediately after initiating the payment.
       */ completionTimeoutSecs: /*u32*/ number | undefined;
    }) {
      super('SendPaymentOptions', 'Bolt11Invoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      preferSpark: boolean;
      /**
       * If set, the function will return the payment if it is still pending after this
       * number of seconds. If unset, the function will return immediately after initiating the payment.
       */ completionTimeoutSecs: /*u32*/ number | undefined;
    }): Bolt11Invoice_ {
      return new Bolt11Invoice_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11Invoice_ {
      return obj.tag === SendPaymentOptions_Tags.Bolt11Invoice;
    }
  }

  function instanceOf(obj: any): obj is SendPaymentOptions {
    return obj[uniffiTypeNameSymbol] === 'SendPaymentOptions';
  }

  return Object.freeze({
    instanceOf,
    BitcoinAddress: BitcoinAddress_,
    Bolt11Invoice: Bolt11Invoice_,
  });
})();

export type SendPaymentOptions = InstanceType<
  (typeof SendPaymentOptions)[keyof Omit<
    typeof SendPaymentOptions,
    'instanceOf'
  >]
>;

// FfiConverter for enum SendPaymentOptions
const FfiConverterTypeSendPaymentOptions = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SendPaymentOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SendPaymentOptions.BitcoinAddress({
            confirmationSpeed:
              FfiConverterTypeOnchainConfirmationSpeed.read(from),
          });
        case 2:
          return new SendPaymentOptions.Bolt11Invoice({
            preferSpark: FfiConverterBool.read(from),
            completionTimeoutSecs: FfiConverterOptionalUInt32.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SendPaymentOptions_Tags.BitcoinAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeOnchainConfirmationSpeed.write(
            inner.confirmationSpeed,
            into
          );
          return;
        }
        case SendPaymentOptions_Tags.Bolt11Invoice: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.preferSpark, into);
          FfiConverterOptionalUInt32.write(inner.completionTimeoutSecs, into);
          return;
        }
        default:
          // Throwing from here means that SendPaymentOptions_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SendPaymentOptions_Tags.BitcoinAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeOnchainConfirmationSpeed.allocationSize(
            inner.confirmationSpeed
          );
          return size;
        }
        case SendPaymentOptions_Tags.Bolt11Invoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterBool.allocationSize(inner.preferSpark);
          size += FfiConverterOptionalUInt32.allocationSize(
            inner.completionTimeoutSecs
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: ServiceConnectivityError

// Enum: ServiceConnectivityError
export enum ServiceConnectivityError_Tags {
  Builder = 'Builder',
  Redirect = 'Redirect',
  Status = 'Status',
  Timeout = 'Timeout',
  Request = 'Request',
  Connect = 'Connect',
  Body = 'Body',
  Decode = 'Decode',
  Json = 'Json',
  Other = 'Other',
}
export const ServiceConnectivityError = (() => {
  type Builder__interface = {
    tag: ServiceConnectivityError_Tags.Builder;
    inner: Readonly<[string]>;
  };

  class Builder_ extends UniffiError implements Builder__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ServiceConnectivityError';
    readonly tag = ServiceConnectivityError_Tags.Builder;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ServiceConnectivityError', 'Builder');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Builder_ {
      return new Builder_(v0);
    }

    static instanceOf(obj: any): obj is Builder_ {
      return obj.tag === ServiceConnectivityError_Tags.Builder;
    }

    static hasInner(obj: any): obj is Builder_ {
      return Builder_.instanceOf(obj);
    }

    static getInner(obj: Builder_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Redirect__interface = {
    tag: ServiceConnectivityError_Tags.Redirect;
    inner: Readonly<[string]>;
  };

  class Redirect_ extends UniffiError implements Redirect__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ServiceConnectivityError';
    readonly tag = ServiceConnectivityError_Tags.Redirect;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ServiceConnectivityError', 'Redirect');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Redirect_ {
      return new Redirect_(v0);
    }

    static instanceOf(obj: any): obj is Redirect_ {
      return obj.tag === ServiceConnectivityError_Tags.Redirect;
    }

    static hasInner(obj: any): obj is Redirect_ {
      return Redirect_.instanceOf(obj);
    }

    static getInner(obj: Redirect_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Status__interface = {
    tag: ServiceConnectivityError_Tags.Status;
    inner: Readonly<{ status: /*u16*/ number; body: string }>;
  };

  class Status_ extends UniffiError implements Status__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ServiceConnectivityError';
    readonly tag = ServiceConnectivityError_Tags.Status;
    readonly inner: Readonly<{ status: /*u16*/ number; body: string }>;
    constructor(inner: { status: /*u16*/ number; body: string }) {
      super('ServiceConnectivityError', 'Status');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { status: /*u16*/ number; body: string }): Status_ {
      return new Status_(inner);
    }

    static instanceOf(obj: any): obj is Status_ {
      return obj.tag === ServiceConnectivityError_Tags.Status;
    }

    static hasInner(obj: any): obj is Status_ {
      return Status_.instanceOf(obj);
    }

    static getInner(
      obj: Status_
    ): Readonly<{ status: /*u16*/ number; body: string }> {
      return obj.inner;
    }
  }

  type Timeout__interface = {
    tag: ServiceConnectivityError_Tags.Timeout;
    inner: Readonly<[string]>;
  };

  class Timeout_ extends UniffiError implements Timeout__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ServiceConnectivityError';
    readonly tag = ServiceConnectivityError_Tags.Timeout;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ServiceConnectivityError', 'Timeout');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Timeout_ {
      return new Timeout_(v0);
    }

    static instanceOf(obj: any): obj is Timeout_ {
      return obj.tag === ServiceConnectivityError_Tags.Timeout;
    }

    static hasInner(obj: any): obj is Timeout_ {
      return Timeout_.instanceOf(obj);
    }

    static getInner(obj: Timeout_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Request__interface = {
    tag: ServiceConnectivityError_Tags.Request;
    inner: Readonly<[string]>;
  };

  class Request_ extends UniffiError implements Request__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ServiceConnectivityError';
    readonly tag = ServiceConnectivityError_Tags.Request;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ServiceConnectivityError', 'Request');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Request_ {
      return new Request_(v0);
    }

    static instanceOf(obj: any): obj is Request_ {
      return obj.tag === ServiceConnectivityError_Tags.Request;
    }

    static hasInner(obj: any): obj is Request_ {
      return Request_.instanceOf(obj);
    }

    static getInner(obj: Request_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Connect__interface = {
    tag: ServiceConnectivityError_Tags.Connect;
    inner: Readonly<[string]>;
  };

  class Connect_ extends UniffiError implements Connect__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ServiceConnectivityError';
    readonly tag = ServiceConnectivityError_Tags.Connect;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ServiceConnectivityError', 'Connect');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Connect_ {
      return new Connect_(v0);
    }

    static instanceOf(obj: any): obj is Connect_ {
      return obj.tag === ServiceConnectivityError_Tags.Connect;
    }

    static hasInner(obj: any): obj is Connect_ {
      return Connect_.instanceOf(obj);
    }

    static getInner(obj: Connect_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Body__interface = {
    tag: ServiceConnectivityError_Tags.Body;
    inner: Readonly<[string]>;
  };

  class Body_ extends UniffiError implements Body__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ServiceConnectivityError';
    readonly tag = ServiceConnectivityError_Tags.Body;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ServiceConnectivityError', 'Body');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Body_ {
      return new Body_(v0);
    }

    static instanceOf(obj: any): obj is Body_ {
      return obj.tag === ServiceConnectivityError_Tags.Body;
    }

    static hasInner(obj: any): obj is Body_ {
      return Body_.instanceOf(obj);
    }

    static getInner(obj: Body_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Decode__interface = {
    tag: ServiceConnectivityError_Tags.Decode;
    inner: Readonly<[string]>;
  };

  class Decode_ extends UniffiError implements Decode__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ServiceConnectivityError';
    readonly tag = ServiceConnectivityError_Tags.Decode;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ServiceConnectivityError', 'Decode');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Decode_ {
      return new Decode_(v0);
    }

    static instanceOf(obj: any): obj is Decode_ {
      return obj.tag === ServiceConnectivityError_Tags.Decode;
    }

    static hasInner(obj: any): obj is Decode_ {
      return Decode_.instanceOf(obj);
    }

    static getInner(obj: Decode_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Json__interface = {
    tag: ServiceConnectivityError_Tags.Json;
    inner: Readonly<[string]>;
  };

  class Json_ extends UniffiError implements Json__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ServiceConnectivityError';
    readonly tag = ServiceConnectivityError_Tags.Json;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ServiceConnectivityError', 'Json');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Json_ {
      return new Json_(v0);
    }

    static instanceOf(obj: any): obj is Json_ {
      return obj.tag === ServiceConnectivityError_Tags.Json;
    }

    static hasInner(obj: any): obj is Json_ {
      return Json_.instanceOf(obj);
    }

    static getInner(obj: Json_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Other__interface = {
    tag: ServiceConnectivityError_Tags.Other;
    inner: Readonly<[string]>;
  };

  class Other_ extends UniffiError implements Other__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ServiceConnectivityError';
    readonly tag = ServiceConnectivityError_Tags.Other;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ServiceConnectivityError', 'Other');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Other_ {
      return new Other_(v0);
    }

    static instanceOf(obj: any): obj is Other_ {
      return obj.tag === ServiceConnectivityError_Tags.Other;
    }

    static hasInner(obj: any): obj is Other_ {
      return Other_.instanceOf(obj);
    }

    static getInner(obj: Other_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is ServiceConnectivityError {
    return obj[uniffiTypeNameSymbol] === 'ServiceConnectivityError';
  }

  return Object.freeze({
    instanceOf,
    Builder: Builder_,
    Redirect: Redirect_,
    Status: Status_,
    Timeout: Timeout_,
    Request: Request_,
    Connect: Connect_,
    Body: Body_,
    Decode: Decode_,
    Json: Json_,
    Other: Other_,
  });
})();

export type ServiceConnectivityError = InstanceType<
  (typeof ServiceConnectivityError)[keyof Omit<
    typeof ServiceConnectivityError,
    'instanceOf'
  >]
>;

// FfiConverter for enum ServiceConnectivityError
const FfiConverterTypeServiceConnectivityError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ServiceConnectivityError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ServiceConnectivityError.Builder(
            FfiConverterString.read(from)
          );
        case 2:
          return new ServiceConnectivityError.Redirect(
            FfiConverterString.read(from)
          );
        case 3:
          return new ServiceConnectivityError.Status({
            status: FfiConverterUInt16.read(from),
            body: FfiConverterString.read(from),
          });
        case 4:
          return new ServiceConnectivityError.Timeout(
            FfiConverterString.read(from)
          );
        case 5:
          return new ServiceConnectivityError.Request(
            FfiConverterString.read(from)
          );
        case 6:
          return new ServiceConnectivityError.Connect(
            FfiConverterString.read(from)
          );
        case 7:
          return new ServiceConnectivityError.Body(
            FfiConverterString.read(from)
          );
        case 8:
          return new ServiceConnectivityError.Decode(
            FfiConverterString.read(from)
          );
        case 9:
          return new ServiceConnectivityError.Json(
            FfiConverterString.read(from)
          );
        case 10:
          return new ServiceConnectivityError.Other(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ServiceConnectivityError_Tags.Builder: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ServiceConnectivityError_Tags.Redirect: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ServiceConnectivityError_Tags.Status: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterUInt16.write(inner.status, into);
          FfiConverterString.write(inner.body, into);
          return;
        }
        case ServiceConnectivityError_Tags.Timeout: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ServiceConnectivityError_Tags.Request: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ServiceConnectivityError_Tags.Connect: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ServiceConnectivityError_Tags.Body: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ServiceConnectivityError_Tags.Decode: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ServiceConnectivityError_Tags.Json: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ServiceConnectivityError_Tags.Other: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that ServiceConnectivityError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ServiceConnectivityError_Tags.Builder: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ServiceConnectivityError_Tags.Redirect: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ServiceConnectivityError_Tags.Status: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterUInt16.allocationSize(inner.status);
          size += FfiConverterString.allocationSize(inner.body);
          return size;
        }
        case ServiceConnectivityError_Tags.Timeout: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ServiceConnectivityError_Tags.Request: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ServiceConnectivityError_Tags.Connect: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ServiceConnectivityError_Tags.Body: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ServiceConnectivityError_Tags.Decode: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ServiceConnectivityError_Tags.Json: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ServiceConnectivityError_Tags.Other: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: StorageError

// Enum: StorageError
export enum StorageError_Tags {
  Implementation = 'Implementation',
  InitializationError = 'InitializationError',
  Serialization = 'Serialization',
}
/**
 * Errors that can occur during storage operations
 */
export const StorageError = (() => {
  type Implementation__interface = {
    tag: StorageError_Tags.Implementation;
    inner: Readonly<[string]>;
  };

  class Implementation_
    extends UniffiError
    implements Implementation__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StorageError';
    readonly tag = StorageError_Tags.Implementation;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('StorageError', 'Implementation');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Implementation_ {
      return new Implementation_(v0);
    }

    static instanceOf(obj: any): obj is Implementation_ {
      return obj.tag === StorageError_Tags.Implementation;
    }

    static hasInner(obj: any): obj is Implementation_ {
      return Implementation_.instanceOf(obj);
    }

    static getInner(obj: Implementation_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InitializationError__interface = {
    tag: StorageError_Tags.InitializationError;
    inner: Readonly<[string]>;
  };

  /**
   * Database initialization error
   */
  class InitializationError_
    extends UniffiError
    implements InitializationError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StorageError';
    readonly tag = StorageError_Tags.InitializationError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('StorageError', 'InitializationError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InitializationError_ {
      return new InitializationError_(v0);
    }

    static instanceOf(obj: any): obj is InitializationError_ {
      return obj.tag === StorageError_Tags.InitializationError;
    }

    static hasInner(obj: any): obj is InitializationError_ {
      return InitializationError_.instanceOf(obj);
    }

    static getInner(obj: InitializationError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Serialization__interface = {
    tag: StorageError_Tags.Serialization;
    inner: Readonly<[string]>;
  };

  class Serialization_ extends UniffiError implements Serialization__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StorageError';
    readonly tag = StorageError_Tags.Serialization;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('StorageError', 'Serialization');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Serialization_ {
      return new Serialization_(v0);
    }

    static instanceOf(obj: any): obj is Serialization_ {
      return obj.tag === StorageError_Tags.Serialization;
    }

    static hasInner(obj: any): obj is Serialization_ {
      return Serialization_.instanceOf(obj);
    }

    static getInner(obj: Serialization_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is StorageError {
    return obj[uniffiTypeNameSymbol] === 'StorageError';
  }

  return Object.freeze({
    instanceOf,
    Implementation: Implementation_,
    InitializationError: InitializationError_,
    Serialization: Serialization_,
  });
})();

/**
 * Errors that can occur during storage operations
 */

export type StorageError = InstanceType<
  (typeof StorageError)[keyof Omit<typeof StorageError, 'instanceOf'>]
>;

// FfiConverter for enum StorageError
const FfiConverterTypeStorageError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = StorageError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new StorageError.Implementation(FfiConverterString.read(from));
        case 2:
          return new StorageError.InitializationError(
            FfiConverterString.read(from)
          );
        case 3:
          return new StorageError.Serialization(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case StorageError_Tags.Implementation: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case StorageError_Tags.InitializationError: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case StorageError_Tags.Serialization: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that StorageError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case StorageError_Tags.Implementation: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case StorageError_Tags.InitializationError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case StorageError_Tags.Serialization: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SuccessAction
export enum SuccessAction_Tags {
  Aes = 'Aes',
  Message = 'Message',
  Url = 'Url',
}
/**
 * Supported success action types
 *
 * Receiving any other (unsupported) success action type will result in a failed parsing,
 * which will abort the LNURL-pay workflow, as per LUD-09.
 */
export const SuccessAction = (() => {
  type Aes__interface = {
    tag: SuccessAction_Tags.Aes;
    inner: Readonly<{ data: AesSuccessActionData }>;
  };

  /**
   * AES type, described in LUD-10
   */
  class Aes_ extends UniffiEnum implements Aes__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessAction';
    readonly tag = SuccessAction_Tags.Aes;
    readonly inner: Readonly<{ data: AesSuccessActionData }>;
    constructor(inner: { data: AesSuccessActionData }) {
      super('SuccessAction', 'Aes');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: AesSuccessActionData }): Aes_ {
      return new Aes_(inner);
    }

    static instanceOf(obj: any): obj is Aes_ {
      return obj.tag === SuccessAction_Tags.Aes;
    }
  }

  type Message__interface = {
    tag: SuccessAction_Tags.Message;
    inner: Readonly<{ data: MessageSuccessActionData }>;
  };

  /**
   * Message type, described in LUD-09
   */
  class Message_ extends UniffiEnum implements Message__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessAction';
    readonly tag = SuccessAction_Tags.Message;
    readonly inner: Readonly<{ data: MessageSuccessActionData }>;
    constructor(inner: { data: MessageSuccessActionData }) {
      super('SuccessAction', 'Message');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: MessageSuccessActionData }): Message_ {
      return new Message_(inner);
    }

    static instanceOf(obj: any): obj is Message_ {
      return obj.tag === SuccessAction_Tags.Message;
    }
  }

  type Url__interface = {
    tag: SuccessAction_Tags.Url;
    inner: Readonly<{ data: UrlSuccessActionData }>;
  };

  /**
   * URL type, described in LUD-09
   */
  class Url_ extends UniffiEnum implements Url__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessAction';
    readonly tag = SuccessAction_Tags.Url;
    readonly inner: Readonly<{ data: UrlSuccessActionData }>;
    constructor(inner: { data: UrlSuccessActionData }) {
      super('SuccessAction', 'Url');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: UrlSuccessActionData }): Url_ {
      return new Url_(inner);
    }

    static instanceOf(obj: any): obj is Url_ {
      return obj.tag === SuccessAction_Tags.Url;
    }
  }

  function instanceOf(obj: any): obj is SuccessAction {
    return obj[uniffiTypeNameSymbol] === 'SuccessAction';
  }

  return Object.freeze({
    instanceOf,
    Aes: Aes_,
    Message: Message_,
    Url: Url_,
  });
})();

/**
 * Supported success action types
 *
 * Receiving any other (unsupported) success action type will result in a failed parsing,
 * which will abort the LNURL-pay workflow, as per LUD-09.
 */

export type SuccessAction = InstanceType<
  (typeof SuccessAction)[keyof Omit<typeof SuccessAction, 'instanceOf'>]
>;

// FfiConverter for enum SuccessAction
const FfiConverterTypeSuccessAction = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SuccessAction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SuccessAction.Aes({
            data: FfiConverterTypeAesSuccessActionData.read(from),
          });
        case 2:
          return new SuccessAction.Message({
            data: FfiConverterTypeMessageSuccessActionData.read(from),
          });
        case 3:
          return new SuccessAction.Url({
            data: FfiConverterTypeUrlSuccessActionData.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SuccessAction_Tags.Aes: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeAesSuccessActionData.write(inner.data, into);
          return;
        }
        case SuccessAction_Tags.Message: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeMessageSuccessActionData.write(inner.data, into);
          return;
        }
        case SuccessAction_Tags.Url: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeUrlSuccessActionData.write(inner.data, into);
          return;
        }
        default:
          // Throwing from here means that SuccessAction_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SuccessAction_Tags.Aes: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeAesSuccessActionData.allocationSize(
            inner.data
          );
          return size;
        }
        case SuccessAction_Tags.Message: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeMessageSuccessActionData.allocationSize(
            inner.data
          );
          return size;
        }
        case SuccessAction_Tags.Url: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeUrlSuccessActionData.allocationSize(
            inner.data
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SuccessActionProcessed
export enum SuccessActionProcessed_Tags {
  Aes = 'Aes',
  Message = 'Message',
  Url = 'Url',
}
/**
 * [`SuccessAction`] where contents are ready to be consumed by the caller
 *
 * Contents are identical to [`SuccessAction`], except for AES where the ciphertext is decrypted.
 */
export const SuccessActionProcessed = (() => {
  type Aes__interface = {
    tag: SuccessActionProcessed_Tags.Aes;
    inner: Readonly<{ result: AesSuccessActionDataResult }>;
  };

  /**
   * See [`SuccessAction::Aes`] for received payload
   *
   * See [`AesSuccessActionDataDecrypted`] for decrypted payload
   */
  class Aes_ extends UniffiEnum implements Aes__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessActionProcessed';
    readonly tag = SuccessActionProcessed_Tags.Aes;
    readonly inner: Readonly<{ result: AesSuccessActionDataResult }>;
    constructor(inner: { result: AesSuccessActionDataResult }) {
      super('SuccessActionProcessed', 'Aes');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { result: AesSuccessActionDataResult }): Aes_ {
      return new Aes_(inner);
    }

    static instanceOf(obj: any): obj is Aes_ {
      return obj.tag === SuccessActionProcessed_Tags.Aes;
    }
  }

  type Message__interface = {
    tag: SuccessActionProcessed_Tags.Message;
    inner: Readonly<{ data: MessageSuccessActionData }>;
  };

  /**
   * See [`SuccessAction::Message`]
   */
  class Message_ extends UniffiEnum implements Message__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessActionProcessed';
    readonly tag = SuccessActionProcessed_Tags.Message;
    readonly inner: Readonly<{ data: MessageSuccessActionData }>;
    constructor(inner: { data: MessageSuccessActionData }) {
      super('SuccessActionProcessed', 'Message');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: MessageSuccessActionData }): Message_ {
      return new Message_(inner);
    }

    static instanceOf(obj: any): obj is Message_ {
      return obj.tag === SuccessActionProcessed_Tags.Message;
    }
  }

  type Url__interface = {
    tag: SuccessActionProcessed_Tags.Url;
    inner: Readonly<{ data: UrlSuccessActionData }>;
  };

  /**
   * See [`SuccessAction::Url`]
   */
  class Url_ extends UniffiEnum implements Url__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SuccessActionProcessed';
    readonly tag = SuccessActionProcessed_Tags.Url;
    readonly inner: Readonly<{ data: UrlSuccessActionData }>;
    constructor(inner: { data: UrlSuccessActionData }) {
      super('SuccessActionProcessed', 'Url');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { data: UrlSuccessActionData }): Url_ {
      return new Url_(inner);
    }

    static instanceOf(obj: any): obj is Url_ {
      return obj.tag === SuccessActionProcessed_Tags.Url;
    }
  }

  function instanceOf(obj: any): obj is SuccessActionProcessed {
    return obj[uniffiTypeNameSymbol] === 'SuccessActionProcessed';
  }

  return Object.freeze({
    instanceOf,
    Aes: Aes_,
    Message: Message_,
    Url: Url_,
  });
})();

/**
 * [`SuccessAction`] where contents are ready to be consumed by the caller
 *
 * Contents are identical to [`SuccessAction`], except for AES where the ciphertext is decrypted.
 */

export type SuccessActionProcessed = InstanceType<
  (typeof SuccessActionProcessed)[keyof Omit<
    typeof SuccessActionProcessed,
    'instanceOf'
  >]
>;

// FfiConverter for enum SuccessActionProcessed
const FfiConverterTypeSuccessActionProcessed = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SuccessActionProcessed;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SuccessActionProcessed.Aes({
            result: FfiConverterTypeAesSuccessActionDataResult.read(from),
          });
        case 2:
          return new SuccessActionProcessed.Message({
            data: FfiConverterTypeMessageSuccessActionData.read(from),
          });
        case 3:
          return new SuccessActionProcessed.Url({
            data: FfiConverterTypeUrlSuccessActionData.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SuccessActionProcessed_Tags.Aes: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeAesSuccessActionDataResult.write(inner.result, into);
          return;
        }
        case SuccessActionProcessed_Tags.Message: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeMessageSuccessActionData.write(inner.data, into);
          return;
        }
        case SuccessActionProcessed_Tags.Url: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeUrlSuccessActionData.write(inner.data, into);
          return;
        }
        default:
          // Throwing from here means that SuccessActionProcessed_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SuccessActionProcessed_Tags.Aes: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeAesSuccessActionDataResult.allocationSize(
            inner.result
          );
          return size;
        }
        case SuccessActionProcessed_Tags.Message: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeMessageSuccessActionData.allocationSize(
            inner.data
          );
          return size;
        }
        case SuccessActionProcessed_Tags.Url: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeUrlSuccessActionData.allocationSize(
            inner.data
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: SyncStorageError

// Enum: SyncStorageError
export enum SyncStorageError_Tags {
  Implementation = 'Implementation',
  InitializationError = 'InitializationError',
  Serialization = 'Serialization',
}
/**
 * Errors that can occur during storage operations
 */
export const SyncStorageError = (() => {
  type Implementation__interface = {
    tag: SyncStorageError_Tags.Implementation;
    inner: Readonly<[string]>;
  };

  class Implementation_
    extends UniffiError
    implements Implementation__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SyncStorageError';
    readonly tag = SyncStorageError_Tags.Implementation;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SyncStorageError', 'Implementation');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Implementation_ {
      return new Implementation_(v0);
    }

    static instanceOf(obj: any): obj is Implementation_ {
      return obj.tag === SyncStorageError_Tags.Implementation;
    }

    static hasInner(obj: any): obj is Implementation_ {
      return Implementation_.instanceOf(obj);
    }

    static getInner(obj: Implementation_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InitializationError__interface = {
    tag: SyncStorageError_Tags.InitializationError;
    inner: Readonly<[string]>;
  };

  /**
   * Database initialization error
   */
  class InitializationError_
    extends UniffiError
    implements InitializationError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SyncStorageError';
    readonly tag = SyncStorageError_Tags.InitializationError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SyncStorageError', 'InitializationError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InitializationError_ {
      return new InitializationError_(v0);
    }

    static instanceOf(obj: any): obj is InitializationError_ {
      return obj.tag === SyncStorageError_Tags.InitializationError;
    }

    static hasInner(obj: any): obj is InitializationError_ {
      return InitializationError_.instanceOf(obj);
    }

    static getInner(obj: InitializationError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Serialization__interface = {
    tag: SyncStorageError_Tags.Serialization;
    inner: Readonly<[string]>;
  };

  class Serialization_ extends UniffiError implements Serialization__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SyncStorageError';
    readonly tag = SyncStorageError_Tags.Serialization;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SyncStorageError', 'Serialization');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Serialization_ {
      return new Serialization_(v0);
    }

    static instanceOf(obj: any): obj is Serialization_ {
      return obj.tag === SyncStorageError_Tags.Serialization;
    }

    static hasInner(obj: any): obj is Serialization_ {
      return Serialization_.instanceOf(obj);
    }

    static getInner(obj: Serialization_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is SyncStorageError {
    return obj[uniffiTypeNameSymbol] === 'SyncStorageError';
  }

  return Object.freeze({
    instanceOf,
    Implementation: Implementation_,
    InitializationError: InitializationError_,
    Serialization: Serialization_,
  });
})();

/**
 * Errors that can occur during storage operations
 */

export type SyncStorageError = InstanceType<
  (typeof SyncStorageError)[keyof Omit<typeof SyncStorageError, 'instanceOf'>]
>;

// FfiConverter for enum SyncStorageError
const FfiConverterTypeSyncStorageError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SyncStorageError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SyncStorageError.Implementation(
            FfiConverterString.read(from)
          );
        case 2:
          return new SyncStorageError.InitializationError(
            FfiConverterString.read(from)
          );
        case 3:
          return new SyncStorageError.Serialization(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SyncStorageError_Tags.Implementation: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SyncStorageError_Tags.InitializationError: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SyncStorageError_Tags.Serialization: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that SyncStorageError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SyncStorageError_Tags.Implementation: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SyncStorageError_Tags.InitializationError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SyncStorageError_Tags.Serialization: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: UpdateDepositPayload
export enum UpdateDepositPayload_Tags {
  ClaimError = 'ClaimError',
  Refund = 'Refund',
}
export const UpdateDepositPayload = (() => {
  type ClaimError__interface = {
    tag: UpdateDepositPayload_Tags.ClaimError;
    inner: Readonly<{ error: DepositClaimError }>;
  };

  class ClaimError_ extends UniffiEnum implements ClaimError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'UpdateDepositPayload';
    readonly tag = UpdateDepositPayload_Tags.ClaimError;
    readonly inner: Readonly<{ error: DepositClaimError }>;
    constructor(inner: { error: DepositClaimError }) {
      super('UpdateDepositPayload', 'ClaimError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: DepositClaimError }): ClaimError_ {
      return new ClaimError_(inner);
    }

    static instanceOf(obj: any): obj is ClaimError_ {
      return obj.tag === UpdateDepositPayload_Tags.ClaimError;
    }
  }

  type Refund__interface = {
    tag: UpdateDepositPayload_Tags.Refund;
    inner: Readonly<{ refundTxid: string; refundTx: string }>;
  };

  class Refund_ extends UniffiEnum implements Refund__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'UpdateDepositPayload';
    readonly tag = UpdateDepositPayload_Tags.Refund;
    readonly inner: Readonly<{ refundTxid: string; refundTx: string }>;
    constructor(inner: { refundTxid: string; refundTx: string }) {
      super('UpdateDepositPayload', 'Refund');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { refundTxid: string; refundTx: string }): Refund_ {
      return new Refund_(inner);
    }

    static instanceOf(obj: any): obj is Refund_ {
      return obj.tag === UpdateDepositPayload_Tags.Refund;
    }
  }

  function instanceOf(obj: any): obj is UpdateDepositPayload {
    return obj[uniffiTypeNameSymbol] === 'UpdateDepositPayload';
  }

  return Object.freeze({
    instanceOf,
    ClaimError: ClaimError_,
    Refund: Refund_,
  });
})();

export type UpdateDepositPayload = InstanceType<
  (typeof UpdateDepositPayload)[keyof Omit<
    typeof UpdateDepositPayload,
    'instanceOf'
  >]
>;

// FfiConverter for enum UpdateDepositPayload
const FfiConverterTypeUpdateDepositPayload = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = UpdateDepositPayload;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new UpdateDepositPayload.ClaimError({
            error: FfiConverterTypeDepositClaimError.read(from),
          });
        case 2:
          return new UpdateDepositPayload.Refund({
            refundTxid: FfiConverterString.read(from),
            refundTx: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case UpdateDepositPayload_Tags.ClaimError: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeDepositClaimError.write(inner.error, into);
          return;
        }
        case UpdateDepositPayload_Tags.Refund: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.refundTxid, into);
          FfiConverterString.write(inner.refundTx, into);
          return;
        }
        default:
          // Throwing from here means that UpdateDepositPayload_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case UpdateDepositPayload_Tags.ClaimError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeDepositClaimError.allocationSize(inner.error);
          return size;
        }
        case UpdateDepositPayload_Tags.Refund: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.refundTxid);
          size += FfiConverterString.allocationSize(inner.refundTx);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: WaitForPaymentIdentifier
export enum WaitForPaymentIdentifier_Tags {
  PaymentId = 'PaymentId',
  PaymentRequest = 'PaymentRequest',
}
export const WaitForPaymentIdentifier = (() => {
  type PaymentId__interface = {
    tag: WaitForPaymentIdentifier_Tags.PaymentId;
    inner: Readonly<[string]>;
  };

  class PaymentId_ extends UniffiEnum implements PaymentId__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WaitForPaymentIdentifier';
    readonly tag = WaitForPaymentIdentifier_Tags.PaymentId;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('WaitForPaymentIdentifier', 'PaymentId');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): PaymentId_ {
      return new PaymentId_(v0);
    }

    static instanceOf(obj: any): obj is PaymentId_ {
      return obj.tag === WaitForPaymentIdentifier_Tags.PaymentId;
    }
  }

  type PaymentRequest__interface = {
    tag: WaitForPaymentIdentifier_Tags.PaymentRequest;
    inner: Readonly<[string]>;
  };

  class PaymentRequest_
    extends UniffiEnum
    implements PaymentRequest__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WaitForPaymentIdentifier';
    readonly tag = WaitForPaymentIdentifier_Tags.PaymentRequest;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('WaitForPaymentIdentifier', 'PaymentRequest');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): PaymentRequest_ {
      return new PaymentRequest_(v0);
    }

    static instanceOf(obj: any): obj is PaymentRequest_ {
      return obj.tag === WaitForPaymentIdentifier_Tags.PaymentRequest;
    }
  }

  function instanceOf(obj: any): obj is WaitForPaymentIdentifier {
    return obj[uniffiTypeNameSymbol] === 'WaitForPaymentIdentifier';
  }

  return Object.freeze({
    instanceOf,
    PaymentId: PaymentId_,
    PaymentRequest: PaymentRequest_,
  });
})();

export type WaitForPaymentIdentifier = InstanceType<
  (typeof WaitForPaymentIdentifier)[keyof Omit<
    typeof WaitForPaymentIdentifier,
    'instanceOf'
  >]
>;

// FfiConverter for enum WaitForPaymentIdentifier
const FfiConverterTypeWaitForPaymentIdentifier = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = WaitForPaymentIdentifier;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new WaitForPaymentIdentifier.PaymentId(
            FfiConverterString.read(from)
          );
        case 2:
          return new WaitForPaymentIdentifier.PaymentRequest(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case WaitForPaymentIdentifier_Tags.PaymentId: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case WaitForPaymentIdentifier_Tags.PaymentRequest: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that WaitForPaymentIdentifier_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case WaitForPaymentIdentifier_Tags.PaymentId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case WaitForPaymentIdentifier_Tags.PaymentRequest: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<string, TokenBalance>
const FfiConverterMapStringTypeTokenBalance = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeTokenBalance
);

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString
);

export interface BitcoinChainService {
  getAddressUtxos(
    address: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Array<Utxo>>;
  getTransactionStatus(
    txid: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<TxStatus>;
  getTransactionHex(
    txid: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  broadcastTransaction(
    tx: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

export class BitcoinChainServiceImpl
  extends UniffiAbstractObject
  implements BitcoinChainService
{
  readonly [uniffiTypeNameSymbol] = 'BitcoinChainServiceImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeBitcoinChainServiceImplObjectFactory.bless(pointer);
  }

  public async getAddressUtxos(
    address: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<Utxo>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(address)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeUtxo.lift.bind(
          FfiConverterArrayTypeUtxo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getTransactionStatus(
    txid: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<TxStatus> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeTxStatus.lift.bind(
          FfiConverterTypeTxStatus
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getTransactionHex(
    txid: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async broadcastTransaction(
    tx: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
            uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(tx)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeChainServiceError.lift.bind(
          FfiConverterTypeChainServiceError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeBitcoinChainServiceImplObjectFactory.pointer(this);
      uniffiTypeBitcoinChainServiceImplObjectFactory.freePointer(pointer);
      uniffiTypeBitcoinChainServiceImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is BitcoinChainServiceImpl {
    return uniffiTypeBitcoinChainServiceImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeBitcoinChainServiceImplObjectFactory: UniffiObjectFactory<BitcoinChainService> =
  {
    create(pointer: UnsafeMutableRawPointer): BitcoinChainService {
      const instance = Object.create(BitcoinChainServiceImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'BitcoinChainServiceImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_bitcoinchainservice_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: BitcoinChainService): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: BitcoinChainService): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is BitcoinChainService {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'BitcoinChainServiceImpl'
      );
    },
  };
// FfiConverter for BitcoinChainService
const FfiConverterTypeBitcoinChainService = new FfiConverterObjectWithCallbacks(
  uniffiTypeBitcoinChainServiceImplObjectFactory
);

// Add a vtavble for the callbacks that go in BitcoinChainService.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceBitcoinChainService: {
  vtable: UniffiVTableCallbackInterfaceBitcoinChainService;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    getAddressUtxos: (
      uniffiHandle: bigint,
      address: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<Utxo>> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.getAddressUtxos(
          FfiConverterString.lift(address),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: Array<Utxo>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypeUtxo.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getTransactionStatus: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<TxStatus> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.getTransactionStatus(
          FfiConverterString.lift(txid),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: TxStatus) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterTypeTxStatus.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getTransactionHex: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<string> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.getTransactionHex(
          FfiConverterString.lift(txid),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: string) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterString.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    broadcastTransaction: (
      uniffiHandle: bigint,
      tx: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback =
          FfiConverterTypeBitcoinChainService.lift(uniffiHandle);
        return await jsCallback.broadcastTransaction(
          FfiConverterString.lift(tx),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ChainServiceError.instanceOf,
        /*lowerError:*/ FfiConverterTypeChainServiceError.lower.bind(
          FfiConverterTypeChainServiceError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // BitcoinChainService: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeBitcoinChainService.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(
      uniffiCallbackInterfaceBitcoinChainService.vtable
    );
  },
};

/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
export interface BreezSdkInterface {
  /**
   * Registers a listener to receive SDK events
   *
   * # Arguments
   *
   * * `listener` - An implementation of the `EventListener` trait
   *
   * # Returns
   *
   * A unique identifier for the listener, which can be used to remove it later
   */
  addEventListener(
    listener: EventListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string>;
  checkLightningAddressAvailable(
    req: CheckLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Verifies a message signature against the provided public key. The message
   * is SHA256 hashed before verification. The signature can be hex encoded
   * in either DER or compact format.
   */
  checkMessage(
    request: CheckMessageRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<CheckMessageResponse>;
  claimDeposit(
    request: ClaimDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ClaimDepositResponse>;
  deleteLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Stops the SDK's background tasks
   *
   * This method stops the background tasks started by the `start()` method.
   * It should be called before your application terminates to ensure proper cleanup.
   *
   * # Returns
   *
   * Result containing either success or an `SdkError` if the background task couldn't be stopped
   */
  disconnect(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
  /**
   * Returns the balance of the wallet in satoshis
   */
  getInfo(
    request: GetInfoRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<GetInfoResponse>;
  getLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<LightningAddressInfo | undefined>;
  getPayment(
    request: GetPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<GetPaymentResponse>;
  /**
   * Returns the metadata for the given token identifiers.
   *
   * Results are not guaranteed to be in the same order as the input token identifiers.
   *
   * If the metadata is not found locally in cache, it will be queried from
   * the Spark network and then cached.
   */
  getTokensMetadata(
    request: GetTokensMetadataRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<GetTokensMetadataResponse>;
  /**
   * Returns the user settings for the wallet.
   *
   * Some settings are fetched from the Spark network so network requests are performed.
   */
  getUserSettings(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<UserSettings>;
  /**
   * List fiat currencies for which there is a known exchange rate,
   * sorted by the canonical name of the currency.
   */
  listFiatCurrencies(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<ListFiatCurrenciesResponse>;
  /**
   * List the latest rates of fiat currencies, sorted by name.
   */
  listFiatRates(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<ListFiatRatesResponse>;
  /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
  listPayments(
    request: ListPaymentsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ListPaymentsResponse>;
  listUnclaimedDeposits(
    request: ListUnclaimedDepositsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ListUnclaimedDepositsResponse>;
  lnurlPay(
    request: LnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<LnurlPayResponse>;
  /**
   * Performs an LNURL withdraw operation for the amount of satoshis to
   * withdraw and the LNURL withdraw request details. The LNURL withdraw request
   * details can be obtained from calling [`BreezSdk::parse`].
   *
   * The method generates a Lightning invoice for the withdraw amount, stores
   * the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
   * invoice.
   *
   * If the `completion_timeout_secs` parameter is provided and greater than 0, the
   * method will wait for the payment to be completed within that period. If the
   * withdraw is completed within the timeout, the `payment` field in the response
   * will be set with the payment details. If the `completion_timeout_secs`
   * parameter is not provided or set to 0, the method will not wait for the payment
   * to be completed. If the withdraw is not completed within the
   * timeout, the `payment` field will be empty.
   *
   * # Arguments
   *
   * * `request` - The LNURL withdraw request
   *
   * # Returns
   *
   * Result containing either:
   * * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
   * * `SdkError` - If there was an error during the withdraw process
   */
  lnurlWithdraw(
    request: LnurlWithdrawRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<LnurlWithdrawResponse>;
  parse(
    input: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<InputType>;
  prepareLnurlPay(
    request: PrepareLnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<PrepareLnurlPayResponse>;
  prepareSendPayment(
    request: PrepareSendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<PrepareSendPaymentResponse>;
  receivePayment(
    request: ReceivePaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ReceivePaymentResponse>;
  refundDeposit(
    request: RefundDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RefundDepositResponse>;
  registerLightningAddress(
    request: RegisterLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<LightningAddressInfo>;
  /**
   * Removes a previously registered event listener
   *
   * # Arguments
   *
   * * `id` - The listener ID returned from `add_event_listener`
   *
   * # Returns
   *
   * `true` if the listener was found and removed, `false` otherwise
   */
  removeEventListener(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean>;
  sendPayment(
    request: SendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendPaymentResponse>;
  /**
   * Signs a message with the wallet's identity key. The message is SHA256
   * hashed before signing. The returned signature will be hex encoded in
   * DER format by default, or compact format if specified.
   */
  signMessage(
    request: SignMessageRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SignMessageResponse>;
  /**
   * Synchronizes the wallet with the Spark network
   */
  syncWallet(
    request: SyncWalletRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SyncWalletResponse>;
  /**
   * Updates the user settings for the wallet.
   *
   * Some settings are updated on the Spark network so network requests may be performed.
   */
  updateUserSettings(
    request: UpdateUserSettingsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  waitForPayment(
    request: WaitForPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<WaitForPaymentResponse>;
}

/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
export class BreezSdk
  extends UniffiAbstractObject
  implements BreezSdkInterface
{
  readonly [uniffiTypeNameSymbol] = 'BreezSdk';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeBreezSdkObjectFactory.bless(pointer);
  }

  /**
   * Registers a listener to receive SDK events
   *
   * # Arguments
   *
   * * `listener` - An implementation of the `EventListener` trait
   *
   * # Returns
   *
   * A unique identifier for the listener, which can be used to remove it later
   */
  public async addEventListener(
    listener: EventListener,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeEventListener.lower(listener)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async checkLightningAddressAvailable(
    req: CheckLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeCheckLightningAddressRequest.lower(req)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Verifies a message signature against the provided public key. The message
   * is SHA256 hashed before verification. The signature can be hex encoded
   * in either DER or compact format.
   */
  public async checkMessage(
    request: CheckMessageRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<CheckMessageResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeCheckMessageRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeCheckMessageResponse.lift.bind(
          FfiConverterTypeCheckMessageResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async claimDeposit(
    request: ClaimDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ClaimDepositResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeClaimDepositRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeClaimDepositResponse.lift.bind(
          FfiConverterTypeClaimDepositResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async deleteLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Stops the SDK's background tasks
   *
   * This method stops the background tasks started by the `start()` method.
   * It should be called before your application terminates to ensure proper cleanup.
   *
   * # Returns
   *
   * Result containing either success or an `SdkError` if the background task couldn't be stopped
   */
  public async disconnect(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the balance of the wallet in satoshis
   */
  public async getInfo(
    request: GetInfoRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<GetInfoResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeGetInfoRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeGetInfoResponse.lift.bind(
          FfiConverterTypeGetInfoResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getLightningAddress(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<LightningAddressInfo | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeLightningAddressInfo.lift.bind(
          FfiConverterOptionalTypeLightningAddressInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getPayment(
    request: GetPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<GetPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeGetPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeGetPaymentResponse.lift.bind(
          FfiConverterTypeGetPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the metadata for the given token identifiers.
   *
   * Results are not guaranteed to be in the same order as the input token identifiers.
   *
   * If the metadata is not found locally in cache, it will be queried from
   * the Spark network and then cached.
   */
  public async getTokensMetadata(
    request: GetTokensMetadataRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<GetTokensMetadataResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeGetTokensMetadataRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeGetTokensMetadataResponse.lift.bind(
          FfiConverterTypeGetTokensMetadataResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Returns the user settings for the wallet.
   *
   * Some settings are fetched from the Spark network so network requests are performed.
   */
  public async getUserSettings(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<UserSettings> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeUserSettings.lift.bind(
          FfiConverterTypeUserSettings
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * List fiat currencies for which there is a known exchange rate,
   * sorted by the canonical name of the currency.
   */
  public async listFiatCurrencies(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<ListFiatCurrenciesResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeListFiatCurrenciesResponse.lift.bind(
          FfiConverterTypeListFiatCurrenciesResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * List the latest rates of fiat currencies, sorted by name.
   */
  public async listFiatRates(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<ListFiatRatesResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeListFiatRatesResponse.lift.bind(
          FfiConverterTypeListFiatRatesResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
  public async listPayments(
    request: ListPaymentsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ListPaymentsResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeListPaymentsRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeListPaymentsResponse.lift.bind(
          FfiConverterTypeListPaymentsResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async listUnclaimedDeposits(
    request: ListUnclaimedDepositsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ListUnclaimedDepositsResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeListUnclaimedDepositsRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeListUnclaimedDepositsResponse.lift.bind(
          FfiConverterTypeListUnclaimedDepositsResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async lnurlPay(
    request: LnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<LnurlPayResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeLnurlPayRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeLnurlPayResponse.lift.bind(
          FfiConverterTypeLnurlPayResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Performs an LNURL withdraw operation for the amount of satoshis to
   * withdraw and the LNURL withdraw request details. The LNURL withdraw request
   * details can be obtained from calling [`BreezSdk::parse`].
   *
   * The method generates a Lightning invoice for the withdraw amount, stores
   * the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
   * invoice.
   *
   * If the `completion_timeout_secs` parameter is provided and greater than 0, the
   * method will wait for the payment to be completed within that period. If the
   * withdraw is completed within the timeout, the `payment` field in the response
   * will be set with the payment details. If the `completion_timeout_secs`
   * parameter is not provided or set to 0, the method will not wait for the payment
   * to be completed. If the withdraw is not completed within the
   * timeout, the `payment` field will be empty.
   *
   * # Arguments
   *
   * * `request` - The LNURL withdraw request
   *
   * # Returns
   *
   * Result containing either:
   * * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
   * * `SdkError` - If there was an error during the withdraw process
   */
  public async lnurlWithdraw(
    request: LnurlWithdrawRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<LnurlWithdrawResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeLnurlWithdrawRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeLnurlWithdrawResponse.lift.bind(
          FfiConverterTypeLnurlWithdrawResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async parse(
    input: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<InputType> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_parse(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterString.lower(input)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeInputType.lift.bind(
          FfiConverterTypeInputType
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async prepareLnurlPay(
    request: PrepareLnurlPayRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<PrepareLnurlPayResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareLnurlPayRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePrepareLnurlPayResponse.lift.bind(
          FfiConverterTypePrepareLnurlPayResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async prepareSendPayment(
    request: PrepareSendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<PrepareSendPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypePrepareSendPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePrepareSendPaymentResponse.lift.bind(
          FfiConverterTypePrepareSendPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async receivePayment(
    request: ReceivePaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ReceivePaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeReceivePaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeReceivePaymentResponse.lift.bind(
          FfiConverterTypeReceivePaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async refundDeposit(
    request: RefundDepositRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RefundDepositResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeRefundDepositRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRefundDepositResponse.lift.bind(
          FfiConverterTypeRefundDepositResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async registerLightningAddress(
    request: RegisterLightningAddressRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<LightningAddressInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeRegisterLightningAddressRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeLightningAddressInfo.lift.bind(
          FfiConverterTypeLightningAddressInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Removes a previously registered event listener
   *
   * # Arguments
   *
   * * `id` - The listener ID returned from `add_event_listener`
   *
   * # Returns
   *
   * `true` if the listener was found and removed, `false` otherwise
   */
  public async removeEventListener(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterString.lower(id)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async sendPayment(
    request: SendPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeSendPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendPaymentResponse.lift.bind(
          FfiConverterTypeSendPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Signs a message with the wallet's identity key. The message is SHA256
   * hashed before signing. The returned signature will be hex encoded in
   * DER format by default, or compact format if specified.
   */
  public async signMessage(
    request: SignMessageRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SignMessageResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeSignMessageRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSignMessageResponse.lift.bind(
          FfiConverterTypeSignMessageResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Synchronizes the wallet with the Spark network
   */
  public async syncWallet(
    request: SyncWalletRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SyncWalletResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeSyncWalletRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSyncWalletResponse.lift.bind(
          FfiConverterTypeSyncWalletResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Updates the user settings for the wallet.
   *
   * Some settings are updated on the Spark network so network requests may be performed.
   */
  public async updateUserSettings(
    request: UpdateUserSettingsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeUpdateUserSettingsRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async waitForPayment(
    request: WaitForPaymentRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<WaitForPaymentResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_wait_for_payment(
            uniffiTypeBreezSdkObjectFactory.clonePointer(this),
            FfiConverterTypeWaitForPaymentRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeWaitForPaymentResponse.lift.bind(
          FfiConverterTypeWaitForPaymentResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeBreezSdkObjectFactory.pointer(this);
      uniffiTypeBreezSdkObjectFactory.freePointer(pointer);
      uniffiTypeBreezSdkObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is BreezSdk {
    return uniffiTypeBreezSdkObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeBreezSdkObjectFactory: UniffiObjectFactory<BreezSdkInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): BreezSdkInterface {
      const instance = Object.create(BreezSdk.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'BreezSdk';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_breezsdk_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: BreezSdkInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: BreezSdkInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_breezsdk(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_breezsdk(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is BreezSdkInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'BreezSdk'
      );
    },
  };
// FfiConverter for BreezSdkInterface
const FfiConverterTypeBreezSdk = new FfiConverterObject(
  uniffiTypeBreezSdkObjectFactory
);

/**
 * Trait covering fiat-related functionality
 */
export interface FiatService {
  /**
   * List all supported fiat currencies for which there is a known exchange rate.
   */
  fetchFiatCurrencies(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<FiatCurrency>>;
  /**
   * Get the live rates from the server.
   */
  fetchFiatRates(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<Rate>>;
}

/**
 * Trait covering fiat-related functionality
 */
export class FiatServiceImpl
  extends UniffiAbstractObject
  implements FiatService
{
  readonly [uniffiTypeNameSymbol] = 'FiatServiceImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFiatServiceImplObjectFactory.bless(pointer);
  }

  /**
   * List all supported fiat currencies for which there is a known exchange rate.
   */
  public async fetchFiatCurrencies(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<FiatCurrency>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies(
            uniffiTypeFiatServiceImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeFiatCurrency.lift.bind(
          FfiConverterArrayTypeFiatCurrency
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeServiceConnectivityError.lift.bind(
          FfiConverterTypeServiceConnectivityError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the live rates from the server.
   */
  public async fetchFiatRates(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<Rate>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates(
            uniffiTypeFiatServiceImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeRate.lift.bind(
          FfiConverterArrayTypeRate
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeServiceConnectivityError.lift.bind(
          FfiConverterTypeServiceConnectivityError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFiatServiceImplObjectFactory.pointer(this);
      uniffiTypeFiatServiceImplObjectFactory.freePointer(pointer);
      uniffiTypeFiatServiceImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FiatServiceImpl {
    return uniffiTypeFiatServiceImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFiatServiceImplObjectFactory: UniffiObjectFactory<FiatService> =
  {
    create(pointer: UnsafeMutableRawPointer): FiatService {
      const instance = Object.create(FiatServiceImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'FiatServiceImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_fiatservice_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: FiatService): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: FiatService): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_fiatservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_fiatservice(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is FiatService {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'FiatServiceImpl'
      );
    },
  };
// FfiConverter for FiatService
const FfiConverterTypeFiatService = new FfiConverterObjectWithCallbacks(
  uniffiTypeFiatServiceImplObjectFactory
);

// Add a vtavble for the callbacks that go in FiatService.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFiatService: {
  vtable: UniffiVTableCallbackInterfaceFiatService;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    fetchFiatCurrencies: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<FiatCurrency>> => {
        const jsCallback = FfiConverterTypeFiatService.lift(uniffiHandle);
        return await jsCallback.fetchFiatCurrencies({ signal });
      };
      const uniffiHandleSuccess = (returnValue: Array<FiatCurrency>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypeFiatCurrency.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ServiceConnectivityError.instanceOf,
        /*lowerError:*/ FfiConverterTypeServiceConnectivityError.lower.bind(
          FfiConverterTypeServiceConnectivityError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    fetchFiatRates: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<Rate>> => {
        const jsCallback = FfiConverterTypeFiatService.lift(uniffiHandle);
        return await jsCallback.fetchFiatRates({ signal });
      };
      const uniffiHandleSuccess = (returnValue: Array<Rate>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypeRate.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ServiceConnectivityError.instanceOf,
        /*lowerError:*/ FfiConverterTypeServiceConnectivityError.lower.bind(
          FfiConverterTypeServiceConnectivityError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FiatService: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFiatService.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice(
      uniffiCallbackInterfaceFiatService.vtable
    );
  },
};

/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */
export interface PaymentObserver {
  /**
   * Called before Lightning, Spark or onchain Bitcoin payments are made
   */
  beforeSend(
    payments: Array<ProvisionalPayment>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */
export class PaymentObserverImpl
  extends UniffiAbstractObject
  implements PaymentObserver
{
  readonly [uniffiTypeNameSymbol] = 'PaymentObserverImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypePaymentObserverImplObjectFactory.bless(pointer);
  }

  /**
   * Called before Lightning, Spark or onchain Bitcoin payments are made
   */
  public async beforeSend(
    payments: Array<ProvisionalPayment>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(
            uniffiTypePaymentObserverImplObjectFactory.clonePointer(this),
            FfiConverterArrayTypeProvisionalPayment.lower(payments)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypePaymentObserverError.lift.bind(
          FfiConverterTypePaymentObserverError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypePaymentObserverImplObjectFactory.pointer(this);
      uniffiTypePaymentObserverImplObjectFactory.freePointer(pointer);
      uniffiTypePaymentObserverImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is PaymentObserverImpl {
    return uniffiTypePaymentObserverImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypePaymentObserverImplObjectFactory: UniffiObjectFactory<PaymentObserver> =
  {
    create(pointer: UnsafeMutableRawPointer): PaymentObserver {
      const instance = Object.create(PaymentObserverImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'PaymentObserverImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_paymentobserver_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: PaymentObserver): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: PaymentObserver): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_paymentobserver(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_paymentobserver(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is PaymentObserver {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'PaymentObserverImpl'
      );
    },
  };
// FfiConverter for PaymentObserver
const FfiConverterTypePaymentObserver = new FfiConverterObjectWithCallbacks(
  uniffiTypePaymentObserverImplObjectFactory
);

// Add a vtavble for the callbacks that go in PaymentObserver.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePaymentObserver: {
  vtable: UniffiVTableCallbackInterfacePaymentObserver;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    beforeSend: (
      uniffiHandle: bigint,
      payments: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypePaymentObserver.lift(uniffiHandle);
        return await jsCallback.beforeSend(
          FfiConverterArrayTypeProvisionalPayment.lift(payments),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ PaymentObserverError.instanceOf,
        /*lowerError:*/ FfiConverterTypePaymentObserverError.lower.bind(
          FfiConverterTypePaymentObserverError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // PaymentObserver: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypePaymentObserver.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(
      uniffiCallbackInterfacePaymentObserver.vtable
    );
  },
};

export interface RestClient {
  /**
   * Makes a GET request and logs on DEBUG.
   * ### Arguments
   * - `url`: the URL on which GET will be called
   * - `headers`: optional headers that will be set on the request
   */
  getRequest(
    url: string,
    headers: Map<string, string> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RestResponse>;
  /**
   * Makes a POST request, and logs on DEBUG.
   * ### Arguments
   * - `url`: the URL on which POST will be called
   * - `headers`: the optional POST headers
   * - `body`: the optional POST body
   */
  postRequest(
    url: string,
    headers: Map<string, string> | undefined,
    body: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RestResponse>;
  /**
   * Makes a DELETE request, and logs on DEBUG.
   * ### Arguments
   * - `url`: the URL on which DELETE will be called
   * - `headers`: the optional DELETE headers
   * - `body`: the optional DELETE body
   */
  deleteRequest(
    url: string,
    headers: Map<string, string> | undefined,
    body: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RestResponse>;
}

export class RestClientImpl extends UniffiAbstractObject implements RestClient {
  readonly [uniffiTypeNameSymbol] = 'RestClientImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRestClientImplObjectFactory.bless(pointer);
  }

  /**
   * Makes a GET request and logs on DEBUG.
   * ### Arguments
   * - `url`: the URL on which GET will be called
   * - `headers`: optional headers that will be set on the request
   */
  public async getRequest(
    url: string,
    headers: Map<string, string> | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RestResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_restclient_get_request(
            uniffiTypeRestClientImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterOptionalMapStringString.lower(headers)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRestResponse.lift.bind(
          FfiConverterTypeRestResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeServiceConnectivityError.lift.bind(
          FfiConverterTypeServiceConnectivityError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Makes a POST request, and logs on DEBUG.
   * ### Arguments
   * - `url`: the URL on which POST will be called
   * - `headers`: the optional POST headers
   * - `body`: the optional POST body
   */
  public async postRequest(
    url: string,
    headers: Map<string, string> | undefined,
    body: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RestResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_restclient_post_request(
            uniffiTypeRestClientImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterOptionalMapStringString.lower(headers),
            FfiConverterOptionalString.lower(body)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRestResponse.lift.bind(
          FfiConverterTypeRestResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeServiceConnectivityError.lift.bind(
          FfiConverterTypeServiceConnectivityError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Makes a DELETE request, and logs on DEBUG.
   * ### Arguments
   * - `url`: the URL on which DELETE will be called
   * - `headers`: the optional DELETE headers
   * - `body`: the optional DELETE body
   */
  public async deleteRequest(
    url: string,
    headers: Map<string, string> | undefined,
    body: string | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RestResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_restclient_delete_request(
            uniffiTypeRestClientImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterOptionalMapStringString.lower(headers),
            FfiConverterOptionalString.lower(body)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeRestResponse.lift.bind(
          FfiConverterTypeRestResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeServiceConnectivityError.lift.bind(
          FfiConverterTypeServiceConnectivityError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRestClientImplObjectFactory.pointer(this);
      uniffiTypeRestClientImplObjectFactory.freePointer(pointer);
      uniffiTypeRestClientImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RestClientImpl {
    return uniffiTypeRestClientImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRestClientImplObjectFactory: UniffiObjectFactory<RestClient> = {
  create(pointer: UnsafeMutableRawPointer): RestClient {
    const instance = Object.create(RestClientImpl.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'RestClientImpl';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_restclient_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: RestClient): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: RestClient): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_restclient(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_restclient(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is RestClient {
    return (
      obj[destructorGuardSymbol] &&
      obj[uniffiTypeNameSymbol] === 'RestClientImpl'
    );
  },
};
// FfiConverter for RestClient
const FfiConverterTypeRestClient = new FfiConverterObjectWithCallbacks(
  uniffiTypeRestClientImplObjectFactory
);

// Add a vtavble for the callbacks that go in RestClient.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRestClient: {
  vtable: UniffiVTableCallbackInterfaceRestClient;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    getRequest: (
      uniffiHandle: bigint,
      url: Uint8Array,
      headers: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<RestResponse> => {
        const jsCallback = FfiConverterTypeRestClient.lift(uniffiHandle);
        return await jsCallback.getRequest(
          FfiConverterString.lift(url),
          FfiConverterOptionalMapStringString.lift(headers),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: RestResponse) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterTypeRestResponse.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ServiceConnectivityError.instanceOf,
        /*lowerError:*/ FfiConverterTypeServiceConnectivityError.lower.bind(
          FfiConverterTypeServiceConnectivityError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    postRequest: (
      uniffiHandle: bigint,
      url: Uint8Array,
      headers: Uint8Array,
      body: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<RestResponse> => {
        const jsCallback = FfiConverterTypeRestClient.lift(uniffiHandle);
        return await jsCallback.postRequest(
          FfiConverterString.lift(url),
          FfiConverterOptionalMapStringString.lift(headers),
          FfiConverterOptionalString.lift(body),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: RestResponse) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterTypeRestResponse.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ServiceConnectivityError.instanceOf,
        /*lowerError:*/ FfiConverterTypeServiceConnectivityError.lower.bind(
          FfiConverterTypeServiceConnectivityError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    deleteRequest: (
      uniffiHandle: bigint,
      url: Uint8Array,
      headers: Uint8Array,
      body: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<RestResponse> => {
        const jsCallback = FfiConverterTypeRestClient.lift(uniffiHandle);
        return await jsCallback.deleteRequest(
          FfiConverterString.lift(url),
          FfiConverterOptionalMapStringString.lift(headers),
          FfiConverterOptionalString.lift(body),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: RestResponse) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterTypeRestResponse.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ ServiceConnectivityError.instanceOf,
        /*lowerError:*/ FfiConverterTypeServiceConnectivityError.lower.bind(
          FfiConverterTypeServiceConnectivityError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RestClient: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRestClient.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient(
      uniffiCallbackInterfaceRestClient.vtable
    );
  },
};

/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
export interface SdkBuilderInterface {
  /**
   * Builds the `BreezSdk` instance with the configured components.
   */
  build(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<BreezSdkInterface>;
  /**
   * Sets the chain service to be used by the SDK.
   * Arguments:
   * - `chain_service`: The chain service to be used.
   */
  withChainService(
    chainService: BitcoinChainService,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the root storage directory to initialize the default storage with.
   * This initializes both storage and real-time sync storage with the
   * default implementations.
   * Arguments:
   * - `storage_dir`: The data directory for storage.
   */
  withDefaultStorage(
    storageDir: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the fiat service to be used by the SDK.
   * Arguments:
   * - `fiat_service`: The fiat service to be used.
   */
  withFiatService(
    fiatService: FiatService,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the key set type to be used by the SDK.
   * Arguments:
   * - `key_set_type`: The key set type which determines the derivation path.
   * - `use_address_index`: Controls the structure of the BIP derivation path.
   */
  withKeySet(
    keySetType: KeySetType,
    useAddressIndex: boolean,
    accountNumber: /*u32*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  withLnurlClient(
    lnurlClient: RestClient,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the payment observer to be used by the SDK.
   * Arguments:
   * - `payment_observer`: The payment observer to be used.
   */
  withPaymentObserver(
    paymentObserver: PaymentObserver,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the real-time sync storage implementation to be used by the SDK.
   * Arguments:
   * - `storage`: The sync storage implementation to be used.
   */
  withRealTimeSyncStorage(
    storage: SyncStorage,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the REST chain service to be used by the SDK.
   * Arguments:
   * - `url`: The base URL of the REST API.
   * - `credentials`: Optional credentials for basic authentication.
   */
  withRestChainService(
    url: string,
    credentials: Credentials | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  /**
   * Sets the storage implementation to be used by the SDK.
   * Arguments:
   * - `storage`: The storage implementation to be used.
   */
  withStorage(
    storage: Storage,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
}

/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
export class SdkBuilder
  extends UniffiAbstractObject
  implements SdkBuilderInterface
{
  readonly [uniffiTypeNameSymbol] = 'SdkBuilder';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Creates a new `SdkBuilder` with the provided configuration.
   * Arguments:
   * - `config`: The configuration to be used.
   * - `seed`: The seed for wallet generation.
   */
  constructor(config: Config, seed: Seed) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
          FfiConverterTypeConfig.lower(config),
          FfiConverterTypeSeed.lower(seed),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSdkBuilderObjectFactory.bless(pointer);
  }

  /**
   * Builds the `BreezSdk` instance with the configured components.
   */
  public async build(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<BreezSdkInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeBreezSdk.lift.bind(
          FfiConverterTypeBreezSdk
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSdkError.lift.bind(
          FfiConverterTypeSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the chain service to be used by the SDK.
   * Arguments:
   * - `chain_service`: The chain service to be used.
   */
  public async withChainService(
    chainService: BitcoinChainService,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeBitcoinChainService.lower(chainService)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the root storage directory to initialize the default storage with.
   * This initializes both storage and real-time sync storage with the
   * default implementations.
   * Arguments:
   * - `storage_dir`: The data directory for storage.
   */
  public async withDefaultStorage(
    storageDir: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(storageDir)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the fiat service to be used by the SDK.
   * Arguments:
   * - `fiat_service`: The fiat service to be used.
   */
  public async withFiatService(
    fiatService: FiatService,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeFiatService.lower(fiatService)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the key set type to be used by the SDK.
   * Arguments:
   * - `key_set_type`: The key set type which determines the derivation path.
   * - `use_address_index`: Controls the structure of the BIP derivation path.
   */
  public async withKeySet(
    keySetType: KeySetType,
    useAddressIndex: boolean,
    accountNumber: /*u32*/ number | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeKeySetType.lower(keySetType),
            FfiConverterBool.lower(useAddressIndex),
            FfiConverterOptionalUInt32.lower(accountNumber)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async withLnurlClient(
    lnurlClient: RestClient,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeRestClient.lower(lnurlClient)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the payment observer to be used by the SDK.
   * Arguments:
   * - `payment_observer`: The payment observer to be used.
   */
  public async withPaymentObserver(
    paymentObserver: PaymentObserver,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypePaymentObserver.lower(paymentObserver)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the real-time sync storage implementation to be used by the SDK.
   * Arguments:
   * - `storage`: The sync storage implementation to be used.
   */
  public async withRealTimeSyncStorage(
    storage: SyncStorage,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeSyncStorage.lower(storage)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the REST chain service to be used by the SDK.
   * Arguments:
   * - `url`: The base URL of the REST API.
   * - `credentials`: Optional credentials for basic authentication.
   */
  public async withRestChainService(
    url: string,
    credentials: Credentials | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterOptionalTypeCredentials.lower(credentials)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sets the storage implementation to be used by the SDK.
   * Arguments:
   * - `storage`: The storage implementation to be used.
   */
  public async withStorage(
    storage: Storage,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(
            uniffiTypeSdkBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeStorage.lower(storage)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSdkBuilderObjectFactory.pointer(this);
      uniffiTypeSdkBuilderObjectFactory.freePointer(pointer);
      uniffiTypeSdkBuilderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SdkBuilder {
    return uniffiTypeSdkBuilderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSdkBuilderObjectFactory: UniffiObjectFactory<SdkBuilderInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SdkBuilderInterface {
      const instance = Object.create(SdkBuilder.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SdkBuilder';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_sdkbuilder_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SdkBuilderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SdkBuilderInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_sdkbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_sdkbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SdkBuilderInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'SdkBuilder'
      );
    },
  };
// FfiConverter for SdkBuilderInterface
const FfiConverterTypeSdkBuilder = new FfiConverterObject(
  uniffiTypeSdkBuilderObjectFactory
);

/**
 * Trait for persistent storage
 */
export interface Storage {
  deleteCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  getCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string | undefined>;
  setCachedItem(
    key: string,
    value: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Lists payments with optional filters and pagination
   *
   * # Arguments
   *
   * * `list_payments_request` - The request to list payments
   *
   * # Returns
   *
   * A vector of payments or a `StorageError`
   */
  listPayments(
    request: ListPaymentsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Array<Payment>>;
  /**
   * Inserts a payment into storage
   *
   * # Arguments
   *
   * * `payment` - The payment to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  insertPayment(
    payment: Payment,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Inserts payment metadata into storage
   *
   * # Arguments
   *
   * * `payment_id` - The ID of the payment
   * * `metadata` - The metadata to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  setPaymentMetadata(
    paymentId: string,
    metadata: PaymentMetadata,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Gets a payment by its ID
   * # Arguments
   *
   * * `id` - The ID of the payment to retrieve
   *
   * # Returns
   *
   * The payment if found or None if not found
   */
  getPaymentById(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Payment>;
  /**
   * Gets a payment by its invoice
   * # Arguments
   *
   * * `invoice` - The invoice of the payment to retrieve
   * # Returns
   *
   * The payment if found or None if not found
   */
  getPaymentByInvoice(
    invoice: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Payment | undefined>;
  /**
   * Add a deposit to storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `amount_sats` - The amount of the deposit in sats
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  addDeposit(
    txid: string,
    vout: /*u32*/ number,
    amountSats: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Removes an unclaimed deposit from storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  deleteDeposit(
    txid: string,
    vout: /*u32*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Lists all unclaimed deposits from storage
   * # Returns
   *
   * A vector of `DepositInfo` or a `StorageError`
   */
  listDeposits(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<Array<DepositInfo>>;
  /**
   * Updates or inserts unclaimed deposit details
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `payload` - The payload for the update
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  updateDeposit(
    txid: string,
    vout: /*u32*/ number,
    payload: UpdateDepositPayload,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

/**
 * Trait for persistent storage
 */
export class StorageImpl extends UniffiAbstractObject implements Storage {
  readonly [uniffiTypeNameSymbol] = 'StorageImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeStorageImplObjectFactory.bless(pointer);
  }

  public async deleteCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getCachedItem(
    key: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(key)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalString.lift.bind(
          FfiConverterOptionalString
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async setCachedItem(
    key: string,
    value: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterString.lower(value)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Lists payments with optional filters and pagination
   *
   * # Arguments
   *
   * * `list_payments_request` - The request to list payments
   *
   * # Returns
   *
   * A vector of payments or a `StorageError`
   */
  public async listPayments(
    request: ListPaymentsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<Payment>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_payments(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterTypeListPaymentsRequest.lower(request)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypePayment.lift.bind(
          FfiConverterArrayTypePayment
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Inserts a payment into storage
   *
   * # Arguments
   *
   * * `payment` - The payment to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async insertPayment(
    payment: Payment,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterTypePayment.lower(payment)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Inserts payment metadata into storage
   *
   * # Arguments
   *
   * * `payment_id` - The ID of the payment
   * * `metadata` - The metadata to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async setPaymentMetadata(
    paymentId: string,
    metadata: PaymentMetadata,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(paymentId),
            FfiConverterTypePaymentMetadata.lower(metadata)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Gets a payment by its ID
   * # Arguments
   *
   * * `id` - The ID of the payment to retrieve
   *
   * # Returns
   *
   * The payment if found or None if not found
   */
  public async getPaymentById(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Payment> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(id)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePayment.lift.bind(
          FfiConverterTypePayment
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Gets a payment by its invoice
   * # Arguments
   *
   * * `invoice` - The invoice of the payment to retrieve
   * # Returns
   *
   * The payment if found or None if not found
   */
  public async getPaymentByInvoice(
    invoice: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Payment | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(invoice)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypePayment.lift.bind(
          FfiConverterOptionalTypePayment
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Add a deposit to storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `amount_sats` - The amount of the deposit in sats
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async addDeposit(
    txid: string,
    vout: /*u32*/ number,
    amountSats: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid),
            FfiConverterUInt32.lower(vout),
            FfiConverterUInt64.lower(amountSats)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Removes an unclaimed deposit from storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async deleteDeposit(
    txid: string,
    vout: /*u32*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid),
            FfiConverterUInt32.lower(vout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Lists all unclaimed deposits from storage
   * # Returns
   *
   * A vector of `DepositInfo` or a `StorageError`
   */
  public async listDeposits(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Array<DepositInfo>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
            uniffiTypeStorageImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeDepositInfo.lift.bind(
          FfiConverterArrayTypeDepositInfo
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Updates or inserts unclaimed deposit details
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `payload` - The payload for the update
   *
   * # Returns
   *
   * Success or a `StorageError`
   */
  public async updateDeposit(
    txid: string,
    vout: /*u32*/ number,
    payload: UpdateDepositPayload,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
            uniffiTypeStorageImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(txid),
            FfiConverterUInt32.lower(vout),
            FfiConverterTypeUpdateDepositPayload.lower(payload)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeStorageError.lift.bind(
          FfiConverterTypeStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeStorageImplObjectFactory.pointer(this);
      uniffiTypeStorageImplObjectFactory.freePointer(pointer);
      uniffiTypeStorageImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is StorageImpl {
    return uniffiTypeStorageImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeStorageImplObjectFactory: UniffiObjectFactory<Storage> = {
  create(pointer: UnsafeMutableRawPointer): Storage {
    const instance = Object.create(StorageImpl.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'StorageImpl';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_storage_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: Storage): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: Storage): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_storage(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_storage(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is Storage {
    return (
      obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'StorageImpl'
    );
  },
};
// FfiConverter for Storage
const FfiConverterTypeStorage = new FfiConverterObjectWithCallbacks(
  uniffiTypeStorageImplObjectFactory
);

// Add a vtavble for the callbacks that go in Storage.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceStorage: {
  vtable: UniffiVTableCallbackInterfaceStorage;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    deleteCachedItem: (
      uniffiHandle: bigint,
      key: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.deleteCachedItem(FfiConverterString.lift(key), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getCachedItem: (
      uniffiHandle: bigint,
      key: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<string | undefined> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.getCachedItem(FfiConverterString.lift(key), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: string | undefined) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterOptionalString.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    setCachedItem: (
      uniffiHandle: bigint,
      key: Uint8Array,
      value: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.setCachedItem(
          FfiConverterString.lift(key),
          FfiConverterString.lift(value),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    listPayments: (
      uniffiHandle: bigint,
      request: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<Payment>> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.listPayments(
          FfiConverterTypeListPaymentsRequest.lift(request),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: Array<Payment>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypePayment.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    insertPayment: (
      uniffiHandle: bigint,
      payment: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.insertPayment(
          FfiConverterTypePayment.lift(payment),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    setPaymentMetadata: (
      uniffiHandle: bigint,
      paymentId: Uint8Array,
      metadata: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.setPaymentMetadata(
          FfiConverterString.lift(paymentId),
          FfiConverterTypePaymentMetadata.lift(metadata),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getPaymentById: (
      uniffiHandle: bigint,
      id: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<Payment> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.getPaymentById(FfiConverterString.lift(id), {
          signal,
        });
      };
      const uniffiHandleSuccess = (returnValue: Payment) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterTypePayment.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getPaymentByInvoice: (
      uniffiHandle: bigint,
      invoice: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Payment | undefined> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.getPaymentByInvoice(
          FfiConverterString.lift(invoice),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: Payment | undefined) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterOptionalTypePayment.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    addDeposit: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      vout: number,
      amountSats: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.addDeposit(
          FfiConverterString.lift(txid),
          FfiConverterUInt32.lift(vout),
          FfiConverterUInt64.lift(amountSats),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    deleteDeposit: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      vout: number,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.deleteDeposit(
          FfiConverterString.lift(txid),
          FfiConverterUInt32.lift(vout),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    listDeposits: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<DepositInfo>> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.listDeposits({ signal });
      };
      const uniffiHandleSuccess = (returnValue: Array<DepositInfo>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypeDepositInfo.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    updateDeposit: (
      uniffiHandle: bigint,
      txid: Uint8Array,
      vout: number,
      payload: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeStorage.lift(uniffiHandle);
        return await jsCallback.updateDeposit(
          FfiConverterString.lift(txid),
          FfiConverterUInt32.lift(vout),
          FfiConverterTypeUpdateDepositPayload.lift(payload),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ StorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeStorageError.lower.bind(
          FfiConverterTypeStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Storage: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeStorage.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(
      uniffiCallbackInterfaceStorage.vtable
    );
  },
};

export interface SyncStorage {
  addOutgoingChange(
    record: UnversionedRecordChange,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise</*u64*/ bigint>;
  completeOutgoingSync(
    record: Record,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  getPendingOutgoingChanges(
    limit: /*u32*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Array<OutgoingChange>>;
  /**
   * Get the revision number of the last synchronized record
   */
  getLastRevision(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise</*u64*/ bigint>;
  /**
   * Insert incoming records from remote sync
   */
  insertIncomingRecords(
    records: Array<Record>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Delete an incoming record after it has been processed
   */
  deleteIncomingRecord(
    record: Record,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Update revision numbers of pending outgoing records to be higher than the given revision
   */
  rebasePendingOutgoingRecords(
    revision: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Get incoming records that need to be processed, up to the specified limit
   */
  getIncomingRecords(
    limit: /*u32*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Array<IncomingChange>>;
  /**
   * Get the latest outgoing record if any exists
   */
  getLatestOutgoingChange(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<OutgoingChange | undefined>;
  /**
   * Update the sync state record from an incoming record
   */
  updateRecordFromIncoming(
    record: Record,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
}

export class SyncStorageImpl
  extends UniffiAbstractObject
  implements SyncStorage
{
  readonly [uniffiTypeNameSymbol] = 'SyncStorageImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSyncStorageImplObjectFactory.bless(pointer);
  }

  public async addOutgoingChange(
    record: UnversionedRecordChange,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise</*u64*/ bigint> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_add_outgoing_change(
            uniffiTypeSyncStorageImplObjectFactory.clonePointer(this),
            FfiConverterTypeUnversionedRecordChange.lower(record)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_u64,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_u64,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_u64,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_u64,
        /*liftFunc:*/ FfiConverterUInt64.lift.bind(FfiConverterUInt64),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSyncStorageError.lift.bind(
          FfiConverterTypeSyncStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async completeOutgoingSync(
    record: Record,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_complete_outgoing_sync(
            uniffiTypeSyncStorageImplObjectFactory.clonePointer(this),
            FfiConverterTypeRecord.lower(record)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSyncStorageError.lift.bind(
          FfiConverterTypeSyncStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getPendingOutgoingChanges(
    limit: /*u32*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<OutgoingChange>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_get_pending_outgoing_changes(
            uniffiTypeSyncStorageImplObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(limit)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeOutgoingChange.lift.bind(
          FfiConverterArrayTypeOutgoingChange
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSyncStorageError.lift.bind(
          FfiConverterTypeSyncStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the revision number of the last synchronized record
   */
  public async getLastRevision(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise</*u64*/ bigint> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_get_last_revision(
            uniffiTypeSyncStorageImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_u64,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_u64,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_u64,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_u64,
        /*liftFunc:*/ FfiConverterUInt64.lift.bind(FfiConverterUInt64),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSyncStorageError.lift.bind(
          FfiConverterTypeSyncStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Insert incoming records from remote sync
   */
  public async insertIncomingRecords(
    records: Array<Record>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_insert_incoming_records(
            uniffiTypeSyncStorageImplObjectFactory.clonePointer(this),
            FfiConverterArrayTypeRecord.lower(records)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSyncStorageError.lift.bind(
          FfiConverterTypeSyncStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Delete an incoming record after it has been processed
   */
  public async deleteIncomingRecord(
    record: Record,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_delete_incoming_record(
            uniffiTypeSyncStorageImplObjectFactory.clonePointer(this),
            FfiConverterTypeRecord.lower(record)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSyncStorageError.lift.bind(
          FfiConverterTypeSyncStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Update revision numbers of pending outgoing records to be higher than the given revision
   */
  public async rebasePendingOutgoingRecords(
    revision: /*u64*/ bigint,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_rebase_pending_outgoing_records(
            uniffiTypeSyncStorageImplObjectFactory.clonePointer(this),
            FfiConverterUInt64.lower(revision)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSyncStorageError.lift.bind(
          FfiConverterTypeSyncStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get incoming records that need to be processed, up to the specified limit
   */
  public async getIncomingRecords(
    limit: /*u32*/ number,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<IncomingChange>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_get_incoming_records(
            uniffiTypeSyncStorageImplObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(limit)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeIncomingChange.lift.bind(
          FfiConverterArrayTypeIncomingChange
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSyncStorageError.lift.bind(
          FfiConverterTypeSyncStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get the latest outgoing record if any exists
   */
  public async getLatestOutgoingChange(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<OutgoingChange | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_get_latest_outgoing_change(
            uniffiTypeSyncStorageImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeOutgoingChange.lift.bind(
          FfiConverterOptionalTypeOutgoingChange
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSyncStorageError.lift.bind(
          FfiConverterTypeSyncStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Update the sync state record from an incoming record
   */
  public async updateRecordFromIncoming(
    record: Record,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_update_record_from_incoming(
            uniffiTypeSyncStorageImplObjectFactory.clonePointer(this),
            FfiConverterTypeRecord.lower(record)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_breez_sdk_spark_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeSyncStorageError.lift.bind(
          FfiConverterTypeSyncStorageError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSyncStorageImplObjectFactory.pointer(this);
      uniffiTypeSyncStorageImplObjectFactory.freePointer(pointer);
      uniffiTypeSyncStorageImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SyncStorageImpl {
    return uniffiTypeSyncStorageImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSyncStorageImplObjectFactory: UniffiObjectFactory<SyncStorage> =
  {
    create(pointer: UnsafeMutableRawPointer): SyncStorage {
      const instance = Object.create(SyncStorageImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SyncStorageImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_syncstorage_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SyncStorage): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SyncStorage): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_syncstorage(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_syncstorage(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SyncStorage {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SyncStorageImpl'
      );
    },
  };
// FfiConverter for SyncStorage
const FfiConverterTypeSyncStorage = new FfiConverterObjectWithCallbacks(
  uniffiTypeSyncStorageImplObjectFactory
);

// Add a vtavble for the callbacks that go in SyncStorage.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSyncStorage: {
  vtable: UniffiVTableCallbackInterfaceSyncStorage;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    addOutgoingChange: (
      uniffiHandle: bigint,
      record: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteU64,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise</*u64*/ bigint> => {
        const jsCallback = FfiConverterTypeSyncStorage.lift(uniffiHandle);
        return await jsCallback.addOutgoingChange(
          FfiConverterTypeUnversionedRecordChange.lift(record),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: /*u64*/ bigint) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructU64 */ {
            returnValue: FfiConverterUInt64.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructU64 */ {
            returnValue: 0n,
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SyncStorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSyncStorageError.lower.bind(
          FfiConverterTypeSyncStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    completeOutgoingSync: (
      uniffiHandle: bigint,
      record: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeSyncStorage.lift(uniffiHandle);
        return await jsCallback.completeOutgoingSync(
          FfiConverterTypeRecord.lift(record),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SyncStorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSyncStorageError.lower.bind(
          FfiConverterTypeSyncStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getPendingOutgoingChanges: (
      uniffiHandle: bigint,
      limit: number,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<OutgoingChange>> => {
        const jsCallback = FfiConverterTypeSyncStorage.lift(uniffiHandle);
        return await jsCallback.getPendingOutgoingChanges(
          FfiConverterUInt32.lift(limit),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: Array<OutgoingChange>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypeOutgoingChange.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SyncStorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSyncStorageError.lower.bind(
          FfiConverterTypeSyncStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getLastRevision: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteU64,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise</*u64*/ bigint> => {
        const jsCallback = FfiConverterTypeSyncStorage.lift(uniffiHandle);
        return await jsCallback.getLastRevision({ signal });
      };
      const uniffiHandleSuccess = (returnValue: /*u64*/ bigint) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructU64 */ {
            returnValue: FfiConverterUInt64.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructU64 */ {
            returnValue: 0n,
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SyncStorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSyncStorageError.lower.bind(
          FfiConverterTypeSyncStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    insertIncomingRecords: (
      uniffiHandle: bigint,
      records: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeSyncStorage.lift(uniffiHandle);
        return await jsCallback.insertIncomingRecords(
          FfiConverterArrayTypeRecord.lift(records),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SyncStorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSyncStorageError.lower.bind(
          FfiConverterTypeSyncStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    deleteIncomingRecord: (
      uniffiHandle: bigint,
      record: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeSyncStorage.lift(uniffiHandle);
        return await jsCallback.deleteIncomingRecord(
          FfiConverterTypeRecord.lift(record),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SyncStorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSyncStorageError.lower.bind(
          FfiConverterTypeSyncStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    rebasePendingOutgoingRecords: (
      uniffiHandle: bigint,
      revision: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeSyncStorage.lift(uniffiHandle);
        return await jsCallback.rebasePendingOutgoingRecords(
          FfiConverterUInt64.lift(revision),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SyncStorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSyncStorageError.lower.bind(
          FfiConverterTypeSyncStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getIncomingRecords: (
      uniffiHandle: bigint,
      limit: number,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<Array<IncomingChange>> => {
        const jsCallback = FfiConverterTypeSyncStorage.lift(uniffiHandle);
        return await jsCallback.getIncomingRecords(
          FfiConverterUInt32.lift(limit),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: Array<IncomingChange>) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayTypeIncomingChange.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SyncStorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSyncStorageError.lower.bind(
          FfiConverterTypeSyncStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    getLatestOutgoingChange: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<OutgoingChange | undefined> => {
        const jsCallback = FfiConverterTypeSyncStorage.lift(uniffiHandle);
        return await jsCallback.getLatestOutgoingChange({ signal });
      };
      const uniffiHandleSuccess = (returnValue: OutgoingChange | undefined) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue:
              FfiConverterOptionalTypeOutgoingChange.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SyncStorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSyncStorageError.lower.bind(
          FfiConverterTypeSyncStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    updateRecordFromIncoming: (
      uniffiHandle: bigint,
      record: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeSyncStorage.lift(uniffiHandle);
        return await jsCallback.updateRecordFromIncoming(
          FfiConverterTypeRecord.lift(record),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ SyncStorageError.instanceOf,
        /*lowerError:*/ FfiConverterTypeSyncStorageError.lower.bind(
          FfiConverterTypeSyncStorageError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // SyncStorage: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeSyncStorage.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_syncstorage(
      uniffiCallbackInterfaceSyncStorage.vtable
    );
  },
};

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for Logger | undefined
const FfiConverterOptionalTypeLogger = new FfiConverterOptional(
  FfiConverterTypeLogger
);

// FfiConverter for Credentials | undefined
const FfiConverterOptionalTypeCredentials = new FfiConverterOptional(
  FfiConverterTypeCredentials
);

// FfiConverter for LightningAddressInfo | undefined
const FfiConverterOptionalTypeLightningAddressInfo = new FfiConverterOptional(
  FfiConverterTypeLightningAddressInfo
);

// FfiConverter for LnurlPayInfo | undefined
const FfiConverterOptionalTypeLnurlPayInfo = new FfiConverterOptional(
  FfiConverterTypeLnurlPayInfo
);

// FfiConverter for LnurlWithdrawInfo | undefined
const FfiConverterOptionalTypeLnurlWithdrawInfo = new FfiConverterOptional(
  FfiConverterTypeLnurlWithdrawInfo
);

// FfiConverter for OutgoingChange | undefined
const FfiConverterOptionalTypeOutgoingChange = new FfiConverterOptional(
  FfiConverterTypeOutgoingChange
);

// FfiConverter for Payment | undefined
const FfiConverterOptionalTypePayment = new FfiConverterOptional(
  FfiConverterTypePayment
);

// FfiConverter for Record | undefined
const FfiConverterOptionalTypeRecord = new FfiConverterOptional(
  FfiConverterTypeRecord
);

// FfiConverter for SparkInvoicePaymentDetails | undefined
const FfiConverterOptionalTypeSparkInvoicePaymentDetails =
  new FfiConverterOptional(FfiConverterTypeSparkInvoicePaymentDetails);

// FfiConverter for Symbol | undefined
const FfiConverterOptionalTypeSymbol = new FfiConverterOptional(
  FfiConverterTypeSymbol
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for Array<Bip21Extra>
const FfiConverterArrayTypeBip21Extra = new FfiConverterArray(
  FfiConverterTypeBip21Extra
);

// FfiConverter for Array<Bolt11RouteHint>
const FfiConverterArrayTypeBolt11RouteHint = new FfiConverterArray(
  FfiConverterTypeBolt11RouteHint
);

// FfiConverter for Array<Bolt11RouteHintHop>
const FfiConverterArrayTypeBolt11RouteHintHop = new FfiConverterArray(
  FfiConverterTypeBolt11RouteHintHop
);

// FfiConverter for Array<Bolt12OfferBlindedPath>
const FfiConverterArrayTypeBolt12OfferBlindedPath = new FfiConverterArray(
  FfiConverterTypeBolt12OfferBlindedPath
);

// FfiConverter for Array<DepositInfo>
const FfiConverterArrayTypeDepositInfo = new FfiConverterArray(
  FfiConverterTypeDepositInfo
);

// FfiConverter for Array<ExternalInputParser>
const FfiConverterArrayTypeExternalInputParser = new FfiConverterArray(
  FfiConverterTypeExternalInputParser
);

// FfiConverter for Array<FiatCurrency>
const FfiConverterArrayTypeFiatCurrency = new FfiConverterArray(
  FfiConverterTypeFiatCurrency
);

// FfiConverter for Array<IncomingChange>
const FfiConverterArrayTypeIncomingChange = new FfiConverterArray(
  FfiConverterTypeIncomingChange
);

// FfiConverter for Array<LocaleOverrides>
const FfiConverterArrayTypeLocaleOverrides = new FfiConverterArray(
  FfiConverterTypeLocaleOverrides
);

// FfiConverter for Array<LocalizedName>
const FfiConverterArrayTypeLocalizedName = new FfiConverterArray(
  FfiConverterTypeLocalizedName
);

// FfiConverter for Array<OutgoingChange>
const FfiConverterArrayTypeOutgoingChange = new FfiConverterArray(
  FfiConverterTypeOutgoingChange
);

// FfiConverter for Array<Payment>
const FfiConverterArrayTypePayment = new FfiConverterArray(
  FfiConverterTypePayment
);

// FfiConverter for Array<ProvisionalPayment>
const FfiConverterArrayTypeProvisionalPayment = new FfiConverterArray(
  FfiConverterTypeProvisionalPayment
);

// FfiConverter for Array<Rate>
const FfiConverterArrayTypeRate = new FfiConverterArray(FfiConverterTypeRate);

// FfiConverter for Array<Record>
const FfiConverterArrayTypeRecord = new FfiConverterArray(
  FfiConverterTypeRecord
);

// FfiConverter for Array<TokenMetadata>
const FfiConverterArrayTypeTokenMetadata = new FfiConverterArray(
  FfiConverterTypeTokenMetadata
);

// FfiConverter for Array<Utxo>
const FfiConverterArrayTypeUtxo = new FfiConverterArray(FfiConverterTypeUtxo);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for U128 | undefined
const FfiConverterOptionalTypeu128 = new FfiConverterOptional(
  FfiConverterTypeu128
);

// FfiConverter for Amount | undefined
const FfiConverterOptionalTypeAmount = new FfiConverterOptional(
  FfiConverterTypeAmount
);

// FfiConverter for AssetFilter | undefined
const FfiConverterOptionalTypeAssetFilter = new FfiConverterOptional(
  FfiConverterTypeAssetFilter
);

// FfiConverter for DepositClaimError | undefined
const FfiConverterOptionalTypeDepositClaimError = new FfiConverterOptional(
  FfiConverterTypeDepositClaimError
);

// FfiConverter for Fee | undefined
const FfiConverterOptionalTypeFee = new FfiConverterOptional(
  FfiConverterTypeFee
);

// FfiConverter for PaymentDetails | undefined
const FfiConverterOptionalTypePaymentDetails = new FfiConverterOptional(
  FfiConverterTypePaymentDetails
);

// FfiConverter for SendPaymentOptions | undefined
const FfiConverterOptionalTypeSendPaymentOptions = new FfiConverterOptional(
  FfiConverterTypeSendPaymentOptions
);

// FfiConverter for SuccessAction | undefined
const FfiConverterOptionalTypeSuccessAction = new FfiConverterOptional(
  FfiConverterTypeSuccessAction
);

// FfiConverter for SuccessActionProcessed | undefined
const FfiConverterOptionalTypeSuccessActionProcessed = new FfiConverterOptional(
  FfiConverterTypeSuccessActionProcessed
);

// FfiConverter for Map<string, string> | undefined
const FfiConverterOptionalMapStringString = new FfiConverterOptional(
  FfiConverterMapStringString
);

// FfiConverter for Array<ExternalInputParser> | undefined
const FfiConverterOptionalArrayTypeExternalInputParser =
  new FfiConverterOptional(FfiConverterArrayTypeExternalInputParser);

// FfiConverter for Array<InputType>
const FfiConverterArrayTypeInputType = new FfiConverterArray(
  FfiConverterTypeInputType
);

// FfiConverter for Array<PaymentStatus>
const FfiConverterArrayTypePaymentStatus = new FfiConverterArray(
  FfiConverterTypePaymentStatus
);

// FfiConverter for Array<PaymentType>
const FfiConverterArrayTypePaymentType = new FfiConverterArray(
  FfiConverterTypePaymentType
);

// FfiConverter for Array<PaymentStatus> | undefined
const FfiConverterOptionalArrayTypePaymentStatus = new FfiConverterOptional(
  FfiConverterArrayTypePaymentStatus
);

// FfiConverter for Array<PaymentType> | undefined
const FfiConverterOptionalArrayTypePaymentType = new FfiConverterOptional(
  FfiConverterArrayTypePaymentType
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 26;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_breez_sdk_spark_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_connect() !== 40345
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_default_config() !==
    62194
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_default_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_init_logging() !==
    8518
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_func_init_logging'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos() !==
    20959
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status() !==
    23018
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex() !==
    59376
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction() !==
    65179
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener() !==
    37737
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available() !==
    31624
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message() !==
    4385
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit() !==
    43529
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address() !==
    44132
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect() !==
    330
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info() !==
    6771
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address() !==
    36552
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment() !==
    11540
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata() !==
    40125
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings() !==
    38537
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies() !==
    63366
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates() !==
    5904
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments() !==
    16156
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits() !==
    22486
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay() !==
    10147
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw() !==
    45652
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_parse() !==
    14285
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay() !==
    37691
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment() !==
    34185
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment() !==
    36984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit() !==
    33646
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address() !==
    530
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener() !==
    41066
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment() !==
    54349
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message() !==
    57563
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet() !==
    30368
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings() !==
    1721
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_wait_for_payment() !==
    64922
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_breezsdk_wait_for_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies() !==
    19092
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates() !==
    11512
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send() !==
    30686
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_restclient_get_request() !==
    8260
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_restclient_get_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_restclient_post_request() !==
    24889
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_restclient_post_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_restclient_delete_request() !==
    51072
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_restclient_delete_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build() !==
    8126
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service() !==
    2848
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage() !==
    14543
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service() !==
    37854
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set() !==
    42926
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client() !==
    51060
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer() !==
    21617
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage() !==
    20579
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service() !==
    56288
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage() !==
    59400
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item() !==
    6883
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item() !==
    30248
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item() !==
    7970
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_list_payments() !==
    19728
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_list_payments'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_insert_payment() !==
    28075
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_insert_payment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata() !==
    45500
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id() !==
    35394
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice() !==
    57075
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_add_deposit() !==
    60240
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_add_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit() !==
    60586
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_list_deposits() !==
    54118
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_list_deposits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_update_deposit() !==
    39803
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_storage_update_deposit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_change() !==
    19087
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_change'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_outgoing_sync() !==
    20071
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_outgoing_sync'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_outgoing_changes() !==
    23473
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_outgoing_changes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_revision() !==
    36887
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_revision'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_incoming_records() !==
    41782
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_incoming_records'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_incoming_record() !==
    23002
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_incoming_record'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_pending_outgoing_records() !==
    61508
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_pending_outgoing_records'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_records() !==
    53552
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_records'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_outgoing_change() !==
    16326
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_outgoing_change'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_from_incoming() !==
    9986
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_from_incoming'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new() !==
    65435
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event() !==
    24807
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_logger_log() !==
    11839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_breez_sdk_spark_checksum_method_logger_log'
    );
  }

  uniffiCallbackInterfaceEventListener.register();
  uniffiCallbackInterfaceLogger.register();
  uniffiCallbackInterfaceBitcoinChainService.register();
  uniffiCallbackInterfaceFiatService.register();
  uniffiCallbackInterfacePaymentObserver.register();
  uniffiCallbackInterfaceRestClient.register();
  uniffiCallbackInterfaceStorage.register();
  uniffiCallbackInterfaceSyncStorage.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAesSuccessActionData,
    FfiConverterTypeAesSuccessActionDataDecrypted,
    FfiConverterTypeAesSuccessActionDataResult,
    FfiConverterTypeAmount,
    FfiConverterTypeAssetFilter,
    FfiConverterTypeBip21Details,
    FfiConverterTypeBip21Extra,
    FfiConverterTypeBitcoinAddressDetails,
    FfiConverterTypeBitcoinChainService,
    FfiConverterTypeBitcoinNetwork,
    FfiConverterTypeBolt11Invoice,
    FfiConverterTypeBolt11InvoiceDetails,
    FfiConverterTypeBolt11RouteHint,
    FfiConverterTypeBolt11RouteHintHop,
    FfiConverterTypeBolt12Invoice,
    FfiConverterTypeBolt12InvoiceDetails,
    FfiConverterTypeBolt12InvoiceRequestDetails,
    FfiConverterTypeBolt12Offer,
    FfiConverterTypeBolt12OfferBlindedPath,
    FfiConverterTypeBolt12OfferDetails,
    FfiConverterTypeBreezSdk,
    FfiConverterTypeCheckLightningAddressRequest,
    FfiConverterTypeCheckMessageRequest,
    FfiConverterTypeCheckMessageResponse,
    FfiConverterTypeClaimDepositRequest,
    FfiConverterTypeClaimDepositResponse,
    FfiConverterTypeConfig,
    FfiConverterTypeConnectRequest,
    FfiConverterTypeCredentials,
    FfiConverterTypeCurrencyInfo,
    FfiConverterTypeDepositClaimError,
    FfiConverterTypeDepositInfo,
    FfiConverterTypeExternalInputParser,
    FfiConverterTypeFee,
    FfiConverterTypeFiatCurrency,
    FfiConverterTypeFiatService,
    FfiConverterTypeGetInfoRequest,
    FfiConverterTypeGetInfoResponse,
    FfiConverterTypeGetPaymentRequest,
    FfiConverterTypeGetPaymentResponse,
    FfiConverterTypeGetTokensMetadataRequest,
    FfiConverterTypeGetTokensMetadataResponse,
    FfiConverterTypeIncomingChange,
    FfiConverterTypeInputType,
    FfiConverterTypeKeySetType,
    FfiConverterTypeLightningAddressDetails,
    FfiConverterTypeLightningAddressInfo,
    FfiConverterTypeListFiatCurrenciesResponse,
    FfiConverterTypeListFiatRatesResponse,
    FfiConverterTypeListPaymentsRequest,
    FfiConverterTypeListPaymentsResponse,
    FfiConverterTypeListUnclaimedDepositsRequest,
    FfiConverterTypeListUnclaimedDepositsResponse,
    FfiConverterTypeLnurlAuthRequestDetails,
    FfiConverterTypeLnurlPayInfo,
    FfiConverterTypeLnurlPayRequest,
    FfiConverterTypeLnurlPayRequestDetails,
    FfiConverterTypeLnurlPayResponse,
    FfiConverterTypeLnurlWithdrawInfo,
    FfiConverterTypeLnurlWithdrawRequest,
    FfiConverterTypeLnurlWithdrawRequestDetails,
    FfiConverterTypeLnurlWithdrawResponse,
    FfiConverterTypeLocaleOverrides,
    FfiConverterTypeLocalizedName,
    FfiConverterTypeLogEntry,
    FfiConverterTypeMessageSuccessActionData,
    FfiConverterTypeNetwork,
    FfiConverterTypeOnchainConfirmationSpeed,
    FfiConverterTypeOutgoingChange,
    FfiConverterTypePayment,
    FfiConverterTypePaymentDetails,
    FfiConverterTypePaymentMetadata,
    FfiConverterTypePaymentMethod,
    FfiConverterTypePaymentObserver,
    FfiConverterTypePaymentRequestSource,
    FfiConverterTypePaymentStatus,
    FfiConverterTypePaymentType,
    FfiConverterTypePrepareLnurlPayRequest,
    FfiConverterTypePrepareLnurlPayResponse,
    FfiConverterTypePrepareSendPaymentRequest,
    FfiConverterTypePrepareSendPaymentResponse,
    FfiConverterTypeProvisionalPayment,
    FfiConverterTypeProvisionalPaymentDetails,
    FfiConverterTypeRate,
    FfiConverterTypeReceivePaymentMethod,
    FfiConverterTypeReceivePaymentRequest,
    FfiConverterTypeReceivePaymentResponse,
    FfiConverterTypeRecord,
    FfiConverterTypeRecordChange,
    FfiConverterTypeRecordId,
    FfiConverterTypeRefundDepositRequest,
    FfiConverterTypeRefundDepositResponse,
    FfiConverterTypeRegisterLightningAddressRequest,
    FfiConverterTypeRestClient,
    FfiConverterTypeRestResponse,
    FfiConverterTypeSdkBuilder,
    FfiConverterTypeSdkEvent,
    FfiConverterTypeSeed,
    FfiConverterTypeSendOnchainFeeQuote,
    FfiConverterTypeSendOnchainSpeedFeeQuote,
    FfiConverterTypeSendPaymentMethod,
    FfiConverterTypeSendPaymentOptions,
    FfiConverterTypeSendPaymentRequest,
    FfiConverterTypeSendPaymentResponse,
    FfiConverterTypeSignMessageRequest,
    FfiConverterTypeSignMessageResponse,
    FfiConverterTypeSilentPaymentAddressDetails,
    FfiConverterTypeSparkAddressDetails,
    FfiConverterTypeSparkInvoiceDetails,
    FfiConverterTypeSparkInvoicePaymentDetails,
    FfiConverterTypeStorage,
    FfiConverterTypeSuccessAction,
    FfiConverterTypeSuccessActionProcessed,
    FfiConverterTypeSymbol,
    FfiConverterTypeSyncStorage,
    FfiConverterTypeSyncWalletRequest,
    FfiConverterTypeSyncWalletResponse,
    FfiConverterTypeTokenBalance,
    FfiConverterTypeTokenMetadata,
    FfiConverterTypeTxStatus,
    FfiConverterTypeUnversionedRecordChange,
    FfiConverterTypeUpdateDepositPayload,
    FfiConverterTypeUpdateUserSettingsRequest,
    FfiConverterTypeUrlSuccessActionData,
    FfiConverterTypeUserSettings,
    FfiConverterTypeUtxo,
    FfiConverterTypeWaitForPaymentIdentifier,
    FfiConverterTypeWaitForPaymentRequest,
    FfiConverterTypeWaitForPaymentResponse,
    FfiConverterTypeu128,
  },
});
