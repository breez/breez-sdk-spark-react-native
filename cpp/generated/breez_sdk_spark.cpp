// This file was autogenerated by some hot garbage in the
// `uniffi-bindgen-react-native` crate. Trust me, you don't want to mess with
// it!
#include "breez_sdk_spark.hpp"

#include "UniffiJsiTypes.h"
#include <iostream>
#include <map>
#include <stdexcept>
#include <thread>
#include <utility>

namespace react = facebook::react;
namespace jsi = facebook::jsi;

// Calling into Rust.
extern "C" {
typedef void (*UniffiRustFutureContinuationCallback)(uint64_t data,
                                                     int8_t poll_result);
typedef void (*UniffiForeignFutureFree)(uint64_t handle);
typedef void (*UniffiCallbackInterfaceFree)(uint64_t handle);
typedef struct UniffiForeignFuture {
  uint64_t handle;
  UniffiForeignFutureFree free;
} UniffiForeignFuture;
typedef struct UniffiForeignFutureStructU8 {
  uint8_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU8;
typedef void (*UniffiForeignFutureCompleteU8)(
    uint64_t callback_data, UniffiForeignFutureStructU8 result);
typedef struct UniffiForeignFutureStructI8 {
  int8_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI8;
typedef void (*UniffiForeignFutureCompleteI8)(
    uint64_t callback_data, UniffiForeignFutureStructI8 result);
typedef struct UniffiForeignFutureStructU16 {
  uint16_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU16;
typedef void (*UniffiForeignFutureCompleteU16)(
    uint64_t callback_data, UniffiForeignFutureStructU16 result);
typedef struct UniffiForeignFutureStructI16 {
  int16_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI16;
typedef void (*UniffiForeignFutureCompleteI16)(
    uint64_t callback_data, UniffiForeignFutureStructI16 result);
typedef struct UniffiForeignFutureStructU32 {
  uint32_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU32;
typedef void (*UniffiForeignFutureCompleteU32)(
    uint64_t callback_data, UniffiForeignFutureStructU32 result);
typedef struct UniffiForeignFutureStructI32 {
  int32_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI32;
typedef void (*UniffiForeignFutureCompleteI32)(
    uint64_t callback_data, UniffiForeignFutureStructI32 result);
typedef struct UniffiForeignFutureStructU64 {
  uint64_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU64;
typedef void (*UniffiForeignFutureCompleteU64)(
    uint64_t callback_data, UniffiForeignFutureStructU64 result);
typedef struct UniffiForeignFutureStructI64 {
  int64_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI64;
typedef void (*UniffiForeignFutureCompleteI64)(
    uint64_t callback_data, UniffiForeignFutureStructI64 result);
typedef struct UniffiForeignFutureStructF32 {
  float return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructF32;
typedef void (*UniffiForeignFutureCompleteF32)(
    uint64_t callback_data, UniffiForeignFutureStructF32 result);
typedef struct UniffiForeignFutureStructF64 {
  double return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructF64;
typedef void (*UniffiForeignFutureCompleteF64)(
    uint64_t callback_data, UniffiForeignFutureStructF64 result);
typedef struct UniffiForeignFutureStructPointer {
  void *return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructPointer;
typedef void (*UniffiForeignFutureCompletePointer)(
    uint64_t callback_data, UniffiForeignFutureStructPointer result);
typedef struct UniffiForeignFutureStructRustBuffer {
  RustBuffer return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructRustBuffer;
typedef void (*UniffiForeignFutureCompleteRustBuffer)(
    uint64_t callback_data, UniffiForeignFutureStructRustBuffer result);
typedef struct UniffiForeignFutureStructVoid {
  RustCallStatus call_status;
} UniffiForeignFutureStructVoid;
typedef void (*UniffiForeignFutureCompleteVoid)(
    uint64_t callback_data, UniffiForeignFutureStructVoid result);
typedef void (*UniffiCallbackInterfaceEventListenerMethod0)(
    uint64_t uniffi_handle, RustBuffer event,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceLoggerMethod0)(
    uint64_t uniffi_handle, RustBuffer l, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceBitcoinChainServiceMethod0)(
    uint64_t uniffi_handle, RustBuffer address,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceBitcoinChainServiceMethod1)(
    uint64_t uniffi_handle, RustBuffer txid,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceBitcoinChainServiceMethod2)(
    uint64_t uniffi_handle, RustBuffer txid,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceBitcoinChainServiceMethod3)(
    uint64_t uniffi_handle, RustBuffer tx,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceBitcoinChainServiceMethod4)(
    uint64_t uniffi_handle,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod0)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod1)(
    uint64_t uniffi_handle, RustBuffer path,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod2)(
    uint64_t uniffi_handle, RustBuffer message, RustBuffer path,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod3)(
    uint64_t uniffi_handle, RustBuffer message, RustBuffer path,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod4)(
    uint64_t uniffi_handle, RustBuffer message, RustBuffer path,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod5)(
    uint64_t uniffi_handle, RustBuffer message, RustBuffer path,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod6)(
    uint64_t uniffi_handle, RustBuffer hash, RustBuffer path,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod7)(
    uint64_t uniffi_handle,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod8)(
    uint64_t uniffi_handle, RustBuffer id,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod9)(
    uint64_t uniffi_handle,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod10)(
    uint64_t uniffi_handle, uint32_t index,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod11)(
    uint64_t uniffi_handle, uint32_t index,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod12)(
    uint64_t uniffi_handle, uint32_t index,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod13)(
    uint64_t uniffi_handle, RustBuffer signing_key, RustBuffer new_signing_key,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod14)(
    uint64_t uniffi_handle, RustBuffer secret, uint32_t threshold,
    uint32_t num_shares,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod15)(
    uint64_t uniffi_handle, RustBuffer private_key,
    RustBuffer receiver_public_key,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod16)(
    uint64_t uniffi_handle, RustBuffer private_key,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod17)(
    uint64_t uniffi_handle, RustBuffer request,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceExternalSignerMethod18)(
    uint64_t uniffi_handle, RustBuffer request,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceFiatServiceMethod0)(
    uint64_t uniffi_handle,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceFiatServiceMethod1)(
    uint64_t uniffi_handle,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfacePaymentObserverMethod0)(
    uint64_t uniffi_handle, RustBuffer payments,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceRestClientMethod0)(
    uint64_t uniffi_handle, RustBuffer url, RustBuffer headers,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceRestClientMethod1)(
    uint64_t uniffi_handle, RustBuffer url, RustBuffer headers, RustBuffer body,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceRestClientMethod2)(
    uint64_t uniffi_handle, RustBuffer url, RustBuffer headers, RustBuffer body,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod0)(
    uint64_t uniffi_handle, RustBuffer key,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod1)(
    uint64_t uniffi_handle, RustBuffer key,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod2)(
    uint64_t uniffi_handle, RustBuffer key, RustBuffer value,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod3)(
    uint64_t uniffi_handle, RustBuffer request,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod4)(
    uint64_t uniffi_handle, RustBuffer payment,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod5)(
    uint64_t uniffi_handle, RustBuffer payment_id, RustBuffer metadata,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod6)(
    uint64_t uniffi_handle, RustBuffer id,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod7)(
    uint64_t uniffi_handle, RustBuffer invoice,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod8)(
    uint64_t uniffi_handle, RustBuffer txid, uint32_t vout,
    uint64_t amount_sats,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod9)(
    uint64_t uniffi_handle, RustBuffer txid, uint32_t vout,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod10)(
    uint64_t uniffi_handle,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod11)(
    uint64_t uniffi_handle, RustBuffer txid, uint32_t vout, RustBuffer payload,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceStorageMethod12)(
    uint64_t uniffi_handle, RustBuffer metadata,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceSyncStorageMethod0)(
    uint64_t uniffi_handle, RustBuffer record,
    UniffiForeignFutureCompleteU64 uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceSyncStorageMethod1)(
    uint64_t uniffi_handle, RustBuffer record,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceSyncStorageMethod2)(
    uint64_t uniffi_handle, uint32_t limit,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceSyncStorageMethod3)(
    uint64_t uniffi_handle,
    UniffiForeignFutureCompleteU64 uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceSyncStorageMethod4)(
    uint64_t uniffi_handle, RustBuffer records,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceSyncStorageMethod5)(
    uint64_t uniffi_handle, RustBuffer record,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceSyncStorageMethod6)(
    uint64_t uniffi_handle, uint64_t revision,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceSyncStorageMethod7)(
    uint64_t uniffi_handle, uint32_t limit,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceSyncStorageMethod8)(
    uint64_t uniffi_handle,
    UniffiForeignFutureCompleteRustBuffer uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef void (*UniffiCallbackInterfaceSyncStorageMethod9)(
    uint64_t uniffi_handle, RustBuffer record,
    UniffiForeignFutureCompleteVoid uniffi_future_callback,
    uint64_t uniffi_callback_data, UniffiForeignFuture *uniffi_out_return);
typedef struct UniffiVTableCallbackInterfaceEventListener {
  UniffiCallbackInterfaceEventListenerMethod0 on_event;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceEventListener;
typedef struct UniffiVTableCallbackInterfaceLogger {
  UniffiCallbackInterfaceLoggerMethod0 log;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceLogger;
typedef struct UniffiVTableCallbackInterfaceBitcoinChainService {
  UniffiCallbackInterfaceBitcoinChainServiceMethod0 get_address_utxos;
  UniffiCallbackInterfaceBitcoinChainServiceMethod1 get_transaction_status;
  UniffiCallbackInterfaceBitcoinChainServiceMethod2 get_transaction_hex;
  UniffiCallbackInterfaceBitcoinChainServiceMethod3 broadcast_transaction;
  UniffiCallbackInterfaceBitcoinChainServiceMethod4 recommended_fees;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceBitcoinChainService;
typedef struct UniffiVTableCallbackInterfaceExternalSigner {
  UniffiCallbackInterfaceExternalSignerMethod0 identity_public_key;
  UniffiCallbackInterfaceExternalSignerMethod1 derive_public_key;
  UniffiCallbackInterfaceExternalSignerMethod2 sign_ecdsa;
  UniffiCallbackInterfaceExternalSignerMethod3 sign_ecdsa_recoverable;
  UniffiCallbackInterfaceExternalSignerMethod4 ecies_encrypt;
  UniffiCallbackInterfaceExternalSignerMethod5 ecies_decrypt;
  UniffiCallbackInterfaceExternalSignerMethod6 sign_hash_schnorr;
  UniffiCallbackInterfaceExternalSignerMethod7
      generate_frost_signing_commitments;
  UniffiCallbackInterfaceExternalSignerMethod8 get_public_key_for_node;
  UniffiCallbackInterfaceExternalSignerMethod9 generate_random_key;
  UniffiCallbackInterfaceExternalSignerMethod10
      get_static_deposit_private_key_source;
  UniffiCallbackInterfaceExternalSignerMethod11 get_static_deposit_private_key;
  UniffiCallbackInterfaceExternalSignerMethod12 get_static_deposit_public_key;
  UniffiCallbackInterfaceExternalSignerMethod13 subtract_private_keys;
  UniffiCallbackInterfaceExternalSignerMethod14 split_secret;
  UniffiCallbackInterfaceExternalSignerMethod15
      encrypt_private_key_for_receiver;
  UniffiCallbackInterfaceExternalSignerMethod16
      get_public_key_from_private_key_source;
  UniffiCallbackInterfaceExternalSignerMethod17 sign_frost;
  UniffiCallbackInterfaceExternalSignerMethod18 aggregate_frost_signatures;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceExternalSigner;
typedef struct UniffiVTableCallbackInterfaceFiatService {
  UniffiCallbackInterfaceFiatServiceMethod0 fetch_fiat_currencies;
  UniffiCallbackInterfaceFiatServiceMethod1 fetch_fiat_rates;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceFiatService;
typedef struct UniffiVTableCallbackInterfacePaymentObserver {
  UniffiCallbackInterfacePaymentObserverMethod0 before_send;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfacePaymentObserver;
typedef struct UniffiVTableCallbackInterfaceRestClient {
  UniffiCallbackInterfaceRestClientMethod0 get_request;
  UniffiCallbackInterfaceRestClientMethod1 post_request;
  UniffiCallbackInterfaceRestClientMethod2 delete_request;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceRestClient;
typedef struct UniffiVTableCallbackInterfaceStorage {
  UniffiCallbackInterfaceStorageMethod0 delete_cached_item;
  UniffiCallbackInterfaceStorageMethod1 get_cached_item;
  UniffiCallbackInterfaceStorageMethod2 set_cached_item;
  UniffiCallbackInterfaceStorageMethod3 list_payments;
  UniffiCallbackInterfaceStorageMethod4 insert_payment;
  UniffiCallbackInterfaceStorageMethod5 set_payment_metadata;
  UniffiCallbackInterfaceStorageMethod6 get_payment_by_id;
  UniffiCallbackInterfaceStorageMethod7 get_payment_by_invoice;
  UniffiCallbackInterfaceStorageMethod8 add_deposit;
  UniffiCallbackInterfaceStorageMethod9 delete_deposit;
  UniffiCallbackInterfaceStorageMethod10 list_deposits;
  UniffiCallbackInterfaceStorageMethod11 update_deposit;
  UniffiCallbackInterfaceStorageMethod12 set_lnurl_metadata;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceStorage;
typedef struct UniffiVTableCallbackInterfaceSyncStorage {
  UniffiCallbackInterfaceSyncStorageMethod0 add_outgoing_change;
  UniffiCallbackInterfaceSyncStorageMethod1 complete_outgoing_sync;
  UniffiCallbackInterfaceSyncStorageMethod2 get_pending_outgoing_changes;
  UniffiCallbackInterfaceSyncStorageMethod3 get_last_revision;
  UniffiCallbackInterfaceSyncStorageMethod4 insert_incoming_records;
  UniffiCallbackInterfaceSyncStorageMethod5 delete_incoming_record;
  UniffiCallbackInterfaceSyncStorageMethod6 rebase_pending_outgoing_records;
  UniffiCallbackInterfaceSyncStorageMethod7 get_incoming_records;
  UniffiCallbackInterfaceSyncStorageMethod8 get_latest_outgoing_change;
  UniffiCallbackInterfaceSyncStorageMethod9 update_record_from_incoming;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceSyncStorage;
void *uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(
    UniffiVTableCallbackInterfaceBitcoinChainService *vtable);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
    void *ptr, RustBuffer address);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(
    void *ptr, RustBuffer txid);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
    void *ptr, RustBuffer txid);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
    void *ptr, RustBuffer tx);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_fees(
    void *ptr);
void *uniffi_breez_sdk_spark_fn_clone_breezsdk(void *ptr,
                                               RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_free_breezsdk(void *ptr,
                                             RustCallStatus *uniffi_out_err);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(void *ptr,
                                                             uint64_t listener);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_cancel_leaf_optimization(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
    void *ptr, RustBuffer req);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(void *ptr,
                                                        RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(void *ptr,
                                                        RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment(
    void *ptr, RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_fetch_conversion_limits(
    void *ptr, RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(void *ptr,
                                                   RustBuffer request);
RustBuffer
uniffi_breez_sdk_spark_fn_method_breezsdk_get_leaf_optimization_progress(
    void *ptr, RustCallStatus *uniffi_out_err);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(void *ptr,
                                                      RustBuffer request);
void *uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer(
    void *ptr, RustCallStatus *uniffi_out_err);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(
    void *ptr, RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(void *ptr,
                                                        RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
    void *ptr, RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(void *ptr,
                                                    RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(void *ptr,
                                                         RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_parse(void *ptr, RustBuffer input);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(void *ptr,
                                                            RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
    void *ptr, RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(void *ptr,
                                                          RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(void *ptr,
                                                         RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
    void *ptr, RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(void *ptr,
                                                                RustBuffer id);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(void *ptr,
                                                       RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(void *ptr,
                                                       RustBuffer request);
void uniffi_breez_sdk_spark_fn_method_breezsdk_start_leaf_optimization(
    void *ptr, RustCallStatus *uniffi_out_err);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(void *ptr,
                                                      RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings(
    void *ptr, RustBuffer request);
void *
uniffi_breez_sdk_spark_fn_clone_externalsigner(void *ptr,
                                               RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_free_externalsigner(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_init_callback_vtable_externalsigner(
    UniffiVTableCallbackInterfaceExternalSigner *vtable);
RustBuffer uniffi_breez_sdk_spark_fn_method_externalsigner_identity_public_key(
    void *ptr, RustCallStatus *uniffi_out_err);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_derive_public_key(
    void *ptr, RustBuffer path);
/*handle*/ uint64_t uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa(
    void *ptr, RustBuffer message, RustBuffer path);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa_recoverable(
    void *ptr, RustBuffer message, RustBuffer path);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_encrypt(
    void *ptr, RustBuffer message, RustBuffer path);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_decrypt(
    void *ptr, RustBuffer message, RustBuffer path);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_sign_hash_schnorr(
    void *ptr, RustBuffer hash, RustBuffer path);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_generate_frost_signing_commitments(
    void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_for_node(
    void *ptr, RustBuffer id);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_key(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key_source(
    void *ptr, uint32_t index);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key(
    void *ptr, uint32_t index);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_public_key(
    void *ptr, uint32_t index);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_subtract_private_keys(
    void *ptr, RustBuffer signing_key, RustBuffer new_signing_key);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_split_secret(
    void *ptr, RustBuffer secret, uint32_t threshold, uint32_t num_shares);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_private_key_for_receiver(
    void *ptr, RustBuffer private_key, RustBuffer receiver_public_key);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_from_private_key_source(
    void *ptr, RustBuffer private_key);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_sign_frost(void *ptr,
                                                           RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_externalsigner_aggregate_frost_signatures(
    void *ptr, RustBuffer request);
void *
uniffi_breez_sdk_spark_fn_clone_fiatservice(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_free_fiatservice(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice(
    UniffiVTableCallbackInterfaceFiatService *vtable);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates(void *ptr);
void *
uniffi_breez_sdk_spark_fn_clone_paymentobserver(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_free_paymentobserver(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(
    UniffiVTableCallbackInterfacePaymentObserver *vtable);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(
    void *ptr, RustBuffer payments);
void *
uniffi_breez_sdk_spark_fn_clone_restclient(void *ptr,
                                           RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_free_restclient(void *ptr,
                                               RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient(
    UniffiVTableCallbackInterfaceRestClient *vtable);
/*handle*/ uint64_t uniffi_breez_sdk_spark_fn_method_restclient_get_request(
    void *ptr, RustBuffer url, RustBuffer headers);
/*handle*/ uint64_t uniffi_breez_sdk_spark_fn_method_restclient_post_request(
    void *ptr, RustBuffer url, RustBuffer headers, RustBuffer body);
/*handle*/ uint64_t uniffi_breez_sdk_spark_fn_method_restclient_delete_request(
    void *ptr, RustBuffer url, RustBuffer headers, RustBuffer body);
void *
uniffi_breez_sdk_spark_fn_clone_sdkbuilder(void *ptr,
                                           RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_free_sdkbuilder(void *ptr,
                                               RustCallStatus *uniffi_out_err);
void *uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
    RustBuffer config, RustBuffer seed, RustCallStatus *uniffi_out_err);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
    void *ptr, void *chain_service);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(
    void *ptr, RustBuffer storage_dir);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(
    void *ptr, void *fiat_service);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(void *ptr,
                                                         RustBuffer config);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
    void *ptr, void *lnurl_client);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(
    void *ptr, void *payment_observer);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage(
    void *ptr, void *storage);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
    void *ptr, RustBuffer url, RustBuffer api_type, RustBuffer credentials);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(void *ptr,
                                                         void *storage);
void *uniffi_breez_sdk_spark_fn_clone_storage(void *ptr,
                                              RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_free_storage(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(
    UniffiVTableCallbackInterfaceStorage *vtable);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(void *ptr,
                                                            RustBuffer key);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(void *ptr,
                                                         RustBuffer key);
/*handle*/ uint64_t uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
    void *ptr, RustBuffer key, RustBuffer value);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_storage_list_payments(void *ptr,
                                                       RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_storage_insert_payment(void *ptr,
                                                        RustBuffer payment);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
    void *ptr, RustBuffer payment_id, RustBuffer metadata);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(void *ptr,
                                                           RustBuffer id);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(
    void *ptr, RustBuffer invoice);
/*handle*/ uint64_t uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
    void *ptr, RustBuffer txid, uint32_t vout, uint64_t amount_sats);
/*handle*/ uint64_t uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
    void *ptr, RustBuffer txid, uint32_t vout);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_storage_list_deposits(void *ptr);
/*handle*/ uint64_t uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
    void *ptr, RustBuffer txid, uint32_t vout, RustBuffer payload);
/*handle*/ uint64_t uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata(
    void *ptr, RustBuffer metadata);
void *
uniffi_breez_sdk_spark_fn_clone_syncstorage(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_free_syncstorage(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_init_callback_vtable_syncstorage(
    UniffiVTableCallbackInterfaceSyncStorage *vtable);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_syncstorage_add_outgoing_change(
    void *ptr, RustBuffer record);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_syncstorage_complete_outgoing_sync(
    void *ptr, RustBuffer record);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_syncstorage_get_pending_outgoing_changes(
    void *ptr, uint32_t limit);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_syncstorage_get_last_revision(void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_syncstorage_insert_incoming_records(
    void *ptr, RustBuffer records);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_syncstorage_delete_incoming_record(
    void *ptr, RustBuffer record);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_syncstorage_rebase_pending_outgoing_records(
    void *ptr, uint64_t revision);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_syncstorage_get_incoming_records(
    void *ptr, uint32_t limit);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_syncstorage_get_latest_outgoing_change(
    void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_syncstorage_update_record_from_incoming(
    void *ptr, RustBuffer record);
void *
uniffi_breez_sdk_spark_fn_clone_tokenissuer(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_free_tokenissuer(void *ptr,
                                                RustCallStatus *uniffi_out_err);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token(
    void *ptr, RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_token(
    void *ptr, RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_token(
    void *ptr, RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_balance(
    void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_metadata(
    void *ptr);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token(
    void *ptr, RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_token(
    void *ptr, RustBuffer request);
void uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(
    UniffiVTableCallbackInterfaceEventListener *vtable);
void uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(
    UniffiVTableCallbackInterfaceLogger *vtable);
/*handle*/ uint64_t uniffi_breez_sdk_spark_fn_func_connect(RustBuffer request);
/*handle*/ uint64_t
uniffi_breez_sdk_spark_fn_func_connect_with_signer(RustBuffer request);
RustBuffer
uniffi_breez_sdk_spark_fn_func_default_config(RustBuffer network,
                                              RustCallStatus *uniffi_out_err);
void *uniffi_breez_sdk_spark_fn_func_default_external_signer(
    RustBuffer mnemonic, RustBuffer passphrase, RustBuffer network,
    RustBuffer key_set_config, RustCallStatus *uniffi_out_err);
void uniffi_breez_sdk_spark_fn_func_init_logging(
    RustBuffer log_dir, RustBuffer app_logger, RustBuffer log_filter,
    RustCallStatus *uniffi_out_err);
RustBuffer ffi_breez_sdk_spark_rustbuffer_alloc(uint64_t size,
                                                RustCallStatus *uniffi_out_err);
RustBuffer
ffi_breez_sdk_spark_rustbuffer_from_bytes(ForeignBytes bytes,
                                          RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rustbuffer_free(RustBuffer buf,
                                         RustCallStatus *uniffi_out_err);
RustBuffer
ffi_breez_sdk_spark_rustbuffer_reserve(RustBuffer buf, uint64_t additional,
                                       RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_u8(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_u8(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_u8(
    /*handle*/ uint64_t handle);
uint8_t ffi_breez_sdk_spark_rust_future_complete_u8(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_i8(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_i8(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_i8(
    /*handle*/ uint64_t handle);
int8_t ffi_breez_sdk_spark_rust_future_complete_i8(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_u16(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_u16(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_u16(
    /*handle*/ uint64_t handle);
uint16_t ffi_breez_sdk_spark_rust_future_complete_u16(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_i16(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_i16(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_i16(
    /*handle*/ uint64_t handle);
int16_t ffi_breez_sdk_spark_rust_future_complete_i16(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_u32(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_u32(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_u32(
    /*handle*/ uint64_t handle);
uint32_t ffi_breez_sdk_spark_rust_future_complete_u32(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_i32(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_i32(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_i32(
    /*handle*/ uint64_t handle);
int32_t ffi_breez_sdk_spark_rust_future_complete_i32(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_u64(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_u64(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_u64(
    /*handle*/ uint64_t handle);
uint64_t ffi_breez_sdk_spark_rust_future_complete_u64(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_i64(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_i64(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_i64(
    /*handle*/ uint64_t handle);
int64_t ffi_breez_sdk_spark_rust_future_complete_i64(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_f32(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_f32(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_f32(
    /*handle*/ uint64_t handle);
float ffi_breez_sdk_spark_rust_future_complete_f32(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_f64(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_f64(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_f64(
    /*handle*/ uint64_t handle);
double ffi_breez_sdk_spark_rust_future_complete_f64(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_pointer(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_pointer(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_pointer(
    /*handle*/ uint64_t handle);
void *ffi_breez_sdk_spark_rust_future_complete_pointer(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_rust_buffer(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_rust_buffer(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_rust_buffer(
    /*handle*/ uint64_t handle);
RustBuffer ffi_breez_sdk_spark_rust_future_complete_rust_buffer(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_breez_sdk_spark_rust_future_poll_void(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_breez_sdk_spark_rust_future_cancel_void(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_free_void(
    /*handle*/ uint64_t handle);
void ffi_breez_sdk_spark_rust_future_complete_void(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
uint16_t uniffi_breez_sdk_spark_checksum_func_connect();
uint16_t uniffi_breez_sdk_spark_checksum_func_connect_with_signer();
uint16_t uniffi_breez_sdk_spark_checksum_func_default_config();
uint16_t uniffi_breez_sdk_spark_checksum_func_default_external_signer();
uint16_t uniffi_breez_sdk_spark_checksum_func_init_logging();
uint16_t
uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos();
uint16_t
uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status();
uint16_t
uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex();
uint16_t
uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction();
uint16_t
uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener();
uint16_t
uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_optimization();
uint16_t
uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment();
uint16_t
uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect();
uint16_t
uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_conversion_limits();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info();
uint16_t
uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_optimization_progress();
uint16_t
uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments();
uint16_t
uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_parse();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit();
uint16_t
uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address();
uint16_t
uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message();
uint16_t
uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_optimization();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet();
uint16_t uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_public_key();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_public_key();
uint16_t uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_recoverable();
uint16_t uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_encrypt();
uint16_t uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_decrypt();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_schnorr();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_frost_signing_commitments();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_for_node();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_key();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key_source();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_public_key();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_private_keys();
uint16_t uniffi_breez_sdk_spark_checksum_method_externalsigner_split_secret();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_private_key_for_receiver();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_from_private_key_source();
uint16_t uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_frost();
uint16_t
uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_frost_signatures();
uint16_t
uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies();
uint16_t uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates();
uint16_t uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send();
uint16_t uniffi_breez_sdk_spark_checksum_method_restclient_get_request();
uint16_t uniffi_breez_sdk_spark_checksum_method_restclient_post_request();
uint16_t uniffi_breez_sdk_spark_checksum_method_restclient_delete_request();
uint16_t uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build();
uint16_t uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service();
uint16_t
uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage();
uint16_t uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service();
uint16_t uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set();
uint16_t uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client();
uint16_t
uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer();
uint16_t
uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage();
uint16_t
uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service();
uint16_t uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_list_payments();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_insert_payment();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id();
uint16_t
uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_add_deposit();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_list_deposits();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_update_deposit();
uint16_t uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata();
uint16_t
uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_change();
uint16_t
uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_outgoing_sync();
uint16_t
uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_outgoing_changes();
uint16_t uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_revision();
uint16_t
uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_incoming_records();
uint16_t
uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_incoming_record();
uint16_t
uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_pending_outgoing_records();
uint16_t
uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_records();
uint16_t
uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_outgoing_change();
uint16_t
uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_from_incoming();
uint16_t uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token();
uint16_t
uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token();
uint16_t
uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token();
uint16_t
uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance();
uint16_t
uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata();
uint16_t uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token();
uint16_t
uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token();
uint16_t uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new();
uint16_t uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event();
uint16_t uniffi_breez_sdk_spark_checksum_method_logger_log();
uint32_t ffi_breez_sdk_spark_uniffi_contract_version();
}

namespace uniffi::breez_sdk_spark {
template <typename T> struct Bridging;

using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <typename T> struct Bridging<ReferenceHolder<T>> {
  static jsi::Value jsNew(jsi::Runtime &rt) {
    auto holder = jsi::Object(rt);
    return holder;
  }
  static T fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
                  const jsi::Value &value) {
    auto obj = value.asObject(rt);
    if (obj.hasProperty(rt, "pointee")) {
      auto pointee = obj.getProperty(rt, "pointee");
      return uniffi::breez_sdk_spark::Bridging<T>::fromJs(rt, callInvoker,
                                                          pointee);
    }
    throw jsi::JSError(rt,
                       "Expected ReferenceHolder to have a pointee property. "
                       "This is likely a bug in uniffi-bindgen-react-native");
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<RustBuffer> {
  static RustBuffer rustbuffer_alloc(int32_t size) {
    RustCallStatus status = {UNIFFI_CALL_STATUS_OK};
    return ffi_breez_sdk_spark_rustbuffer_alloc(size, &status);
  }

  static void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = {UNIFFI_CALL_STATUS_OK};
    ffi_breez_sdk_spark_rustbuffer_free(buf, &status);
  }

  static RustBuffer rustbuffer_from_bytes(ForeignBytes bytes) {
    RustCallStatus status = {UNIFFI_CALL_STATUS_OK};
    return ffi_breez_sdk_spark_rustbuffer_from_bytes(bytes, &status);
  }

  static RustBuffer fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker>,
                           const jsi::Value &value) {
    try {
      auto buffer =
          uniffi_jsi::Bridging<jsi::ArrayBuffer>::value_to_arraybuffer(rt,
                                                                       value);
      auto bytes = ForeignBytes{
          .len = static_cast<int32_t>(buffer.length(rt)),
          .data = buffer.data(rt),
      };

      // This buffer is constructed from foreign bytes. Rust scaffolding copies
      // the bytes, to make the RustBuffer.
      auto buf = rustbuffer_from_bytes(bytes);
      // Once it leaves this function, the buffer is immediately passed back
      // into Rust, where it's used to deserialize into the Rust versions of the
      // arguments. At that point, the copy is destroyed.
      return buf;
    } catch (const std::logic_error &e) {
      throw jsi::JSError(rt, e.what());
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker>,
                         RustBuffer buf) {
    // We need to make a copy of the bytes from Rust's memory space into
    // Javascripts memory space. We need to do this because the two languages
    // manages memory very differently: a garbage collector needs to track all
    // the memory at runtime, Rust is doing it all closer to compile time.
    uint8_t *bytes = new uint8_t[buf.len];
    std::memcpy(bytes, buf.data, buf.len);

    // Construct an ArrayBuffer with copy of the bytes from the RustBuffer.
    auto payload = std::make_shared<uniffi_jsi::CMutableBuffer>(
        uniffi_jsi::CMutableBuffer((uint8_t *)bytes, buf.len));
    auto arrayBuffer = jsi::ArrayBuffer(rt, payload);

    // Once we have a Javascript version, we no longer need the Rust version, so
    // we can call into Rust to tell it it's okay to free that memory.
    rustbuffer_free(buf);

    // Finally, return the ArrayBuffer.
    return uniffi_jsi::Bridging<jsi::ArrayBuffer>::arraybuffer_to_value(
        rt, arrayBuffer);
    ;
  }
};

} // namespace uniffi::breez_sdk_spark

namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<RustCallStatus> {
  static jsi::Value jsSuccess(jsi::Runtime &rt) {
    auto statusObject = jsi::Object(rt);
    statusObject.setProperty(rt, "code", jsi::Value(rt, UNIFFI_CALL_STATUS_OK));
    return statusObject;
  }
  static RustCallStatus rustSuccess(jsi::Runtime &rt) {
    return {UNIFFI_CALL_STATUS_OK};
  }
  static void copyIntoJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         const RustCallStatus status,
                         const jsi::Value &jsStatus) {
    auto statusObject = jsStatus.asObject(rt);
    if (status.error_buf.data != nullptr) {
      auto rbuf = Bridging<RustBuffer>::toJs(rt, callInvoker, status.error_buf);
      statusObject.setProperty(rt, "errorBuf", rbuf);
    }
    if (status.code != UNIFFI_CALL_STATUS_OK) {
      auto code =
          uniffi_jsi::Bridging<uint8_t>::toJs(rt, callInvoker, status.code);
      statusObject.setProperty(rt, "code", code);
    }
  }

  static RustCallStatus fromJs(jsi::Runtime &rt,
                               std::shared_ptr<CallInvoker> invoker,
                               const jsi::Value &jsStatus) {
    RustCallStatus status;
    auto statusObject = jsStatus.asObject(rt);
    if (statusObject.hasProperty(rt, "errorBuf")) {
      auto rbuf = statusObject.getProperty(rt, "errorBuf");
      status.error_buf = Bridging<RustBuffer>::fromJs(rt, invoker, rbuf);
    }
    if (statusObject.hasProperty(rt, "code")) {
      auto code = statusObject.getProperty(rt, "code");
      status.code = uniffi_jsi::Bridging<uint8_t>::fromJs(rt, invoker, code);
    }
    return status;
  }

  static void copyFromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> invoker,
                         const jsi::Value &jsStatus, RustCallStatus *status) {
    auto statusObject = jsStatus.asObject(rt);
    if (statusObject.hasProperty(rt, "errorBuf")) {
      auto rbuf = statusObject.getProperty(rt, "errorBuf");
      status->error_buf = Bridging<RustBuffer>::fromJs(rt, invoker, rbuf);
    }
    if (statusObject.hasProperty(rt, "code")) {
      auto code = statusObject.getProperty(rt, "code");
      status->code = uniffi_jsi::Bridging<uint8_t>::fromJs(rt, invoker, code);
    }
  }
};

} // namespace uniffi::breez_sdk_spark
// In other uniffi bindings, it is assumed that the foreign language holds on
// to the vtable, which the Rust just gets a pointer to.
// Here, we need to hold on to them, but also be able to clear them at just the
// right time so we can support hot-reloading.
namespace uniffi::breez_sdk_spark::registry {
template <typename T> class VTableHolder {
public:
  T vtable;
  VTableHolder(T v) : vtable(v) {}
};

// Mutex to bind the storage and setting of vtable together.
// We declare it here, but the lock is taken by callers of the putTable
// method who are also sending a pointer to Rust.
static std::mutex vtableMutex;

// Registry to hold all vtables so they persist even when JS objects are GC'd.
// The only reason this exists is to prevent a dangling pointer in the
// Rust machinery: i.e. we don't need to access or write to this registry
// after startup.
// Registry to hold all vtables so they persist even when JS objects are GC'd.
// Maps string identifiers to vtable holders using type erasure
static std::unordered_map<std::string, std::shared_ptr<void>> vtableRegistry;

// Add a vtable to the registry with an identifier
template <typename T>
static T *putTable(std::string_view identifier, T vtable) {
  auto holder = std::make_shared<VTableHolder<T>>(vtable);
  // Store the raw pointer to the vtable before type erasure
  T *rawPtr = &(holder->vtable);
  // Store the holder using type erasure with the string identifier
  vtableRegistry[std::string(identifier)] = std::shared_ptr<void>(holder);
  return rawPtr;
}

// Clear the registry.
//
// Conceptually, this is called after teardown of the module (i.e. after
// teardown of the jsi::Runtime). However, because Rust is dropping callbacks
// because the Runtime is being torn down, we must keep the registry intact
// until after the runtime goes away.
//
// Therefore, in practice we should call this when the next runtime is
// being stood up.
static void clearRegistry() {
  std::lock_guard<std::mutex> lock(vtableMutex);
  vtableRegistry.clear();
}
} // namespace uniffi::breez_sdk_spark::registry

// This calls into Rust.
// Implementation of callback function calling from Rust to JS
// RustFutureContinuationCallback

// Callback function:
// uniffi::breez_sdk_spark::cb::rustfuturecontinuationcallback::UniffiRustFutureContinuationCallback
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::rustfuturecontinuationcallback {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, int8_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue, uint64_t rs_data,
                 int8_t rs_pollResult) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_data = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_data);
  auto js_pollResult =
      uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, rs_pollResult);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_data, js_pollResult);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiRustFutureContinuationCallback: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_data, int8_t rs_pollResult) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_data, rs_pollResult);
}

static UniffiRustFutureContinuationCallback
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::rustfuturecontinuationcallback
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_data,
                                               int8_t rs_pollResult) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_data,
         rs_pollResult](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_data, rs_pollResult);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::rustfuturecontinuationcallback
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureFree, passed from Rust to JS as part of async callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureFree> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureFree rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureFree"), 1,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureFree func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
  // Implementation of free callback function CallbackInterfaceFree

// Callback function:
// uniffi::breez_sdk_spark::st::foreignfuture::foreignfuture::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::st::foreignfuture::foreignfuture::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_spark::st::foreignfuture::foreignfuture::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::st::foreignfuture::foreignfuture::free

// Callback function:
// uniffi::breez_sdk_spark::st::vtablecallbackinterfaceeventlistener::vtablecallbackinterfaceeventlistener::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::st::vtablecallbackinterfaceeventlistener::
    vtablecallbackinterfaceeventlistener::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_spark::st::vtablecallbackinterfaceeventlistener::vtablecallbackinterfaceeventlistener::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::st::vtablecallbackinterfaceeventlistener::vtablecallbackinterfaceeventlistener::free

// Callback function:
// uniffi::breez_sdk_spark::st::vtablecallbackinterfacelogger::vtablecallbackinterfacelogger::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::st::vtablecallbackinterfacelogger::
    vtablecallbackinterfacelogger::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_spark::st::vtablecallbackinterfacelogger::vtablecallbackinterfacelogger::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::st::vtablecallbackinterfacelogger::vtablecallbackinterfacelogger::free

// Callback function:
// uniffi::breez_sdk_spark::st::vtablecallbackinterfacebitcoinchainservice::vtablecallbackinterfacebitcoinchainservice::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::st::
    vtablecallbackinterfacebitcoinchainservice::
        vtablecallbackinterfacebitcoinchainservice::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_spark::st::vtablecallbackinterfacebitcoinchainservice::vtablecallbackinterfacebitcoinchainservice::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::st::vtablecallbackinterfacebitcoinchainservice::vtablecallbackinterfacebitcoinchainservice::free

// Callback function:
// uniffi::breez_sdk_spark::st::vtablecallbackinterfaceexternalsigner::vtablecallbackinterfaceexternalsigner::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::st::vtablecallbackinterfaceexternalsigner::
    vtablecallbackinterfaceexternalsigner::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_spark::st::vtablecallbackinterfaceexternalsigner::vtablecallbackinterfaceexternalsigner::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::st::vtablecallbackinterfaceexternalsigner::vtablecallbackinterfaceexternalsigner::free

// Callback function:
// uniffi::breez_sdk_spark::st::vtablecallbackinterfacefiatservice::vtablecallbackinterfacefiatservice::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::st::vtablecallbackinterfacefiatservice::
    vtablecallbackinterfacefiatservice::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_spark::st::vtablecallbackinterfacefiatservice::vtablecallbackinterfacefiatservice::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::st::vtablecallbackinterfacefiatservice::vtablecallbackinterfacefiatservice::free

// Callback function:
// uniffi::breez_sdk_spark::st::vtablecallbackinterfacepaymentobserver::vtablecallbackinterfacepaymentobserver::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::st::vtablecallbackinterfacepaymentobserver::
    vtablecallbackinterfacepaymentobserver::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_spark::st::vtablecallbackinterfacepaymentobserver::vtablecallbackinterfacepaymentobserver::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::st::vtablecallbackinterfacepaymentobserver::vtablecallbackinterfacepaymentobserver::free

// Callback function:
// uniffi::breez_sdk_spark::st::vtablecallbackinterfacerestclient::vtablecallbackinterfacerestclient::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::st::vtablecallbackinterfacerestclient::
    vtablecallbackinterfacerestclient::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_spark::st::vtablecallbackinterfacerestclient::vtablecallbackinterfacerestclient::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::st::vtablecallbackinterfacerestclient::vtablecallbackinterfacerestclient::free

// Callback function:
// uniffi::breez_sdk_spark::st::vtablecallbackinterfacestorage::vtablecallbackinterfacestorage::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::st::vtablecallbackinterfacestorage::
    vtablecallbackinterfacestorage::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_spark::st::vtablecallbackinterfacestorage::vtablecallbackinterfacestorage::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::st::vtablecallbackinterfacestorage::vtablecallbackinterfacestorage::free

// Callback function:
// uniffi::breez_sdk_spark::st::vtablecallbackinterfacesyncstorage::vtablecallbackinterfacesyncstorage::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::st::vtablecallbackinterfacesyncstorage::
    vtablecallbackinterfacesyncstorage::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::breez_sdk_spark::st::vtablecallbackinterfacesyncstorage::vtablecallbackinterfacesyncstorage::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::st::vtablecallbackinterfacesyncstorage::vtablecallbackinterfacesyncstorage::free
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFuture> {
  static UniffiForeignFuture fromJs(jsi::Runtime &rt,
                                    std::shared_ptr<CallInvoker> callInvoker,
                                    const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFuture");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFuture rsObject;

    // Create the vtable from the js callbacks.
    rsObject.handle = uniffi_jsi::Bridging<uint64_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "handle"));
    rsObject.free = uniffi::breez_sdk_spark::st::foreignfuture::foreignfuture::
        free::makeCallbackFunction(rt, callInvoker,
                                   jsObject.getProperty(rt, "free"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU8> {
  static UniffiForeignFutureStructU8
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU8");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU8 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint8_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU8, passed from Rust to JS as part of async callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU8> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU8 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU8"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU8 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureStructU8>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI8> {
  static UniffiForeignFutureStructI8
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI8");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI8 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int8_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI8, passed from Rust to JS as part of async callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI8> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI8 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI8"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI8 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureStructI8>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU16> {
  static UniffiForeignFutureStructU16
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU16");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU16 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint16_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU16, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU16> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU16 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU16"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU16 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(
        uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
        uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureStructU16>::fromJs(
            rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI16> {
  static UniffiForeignFutureStructI16
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI16");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI16 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int16_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI16, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI16> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI16 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI16"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI16 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(
        uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
        uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureStructI16>::fromJs(
            rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU32> {
  static UniffiForeignFutureStructU32
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint32_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU32, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU32> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU32 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU32"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(
        uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
        uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureStructU32>::fromJs(
            rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI32> {
  static UniffiForeignFutureStructI32
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int32_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI32, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI32> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI32 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI32"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(
        uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
        uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureStructI32>::fromJs(
            rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU64> {
  static UniffiForeignFutureStructU64
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint64_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU64, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU64> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU64 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU64"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(
        uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
        uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureStructU64>::fromJs(
            rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI64> {
  static UniffiForeignFutureStructI64
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int64_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI64, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI64> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI64 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI64"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(
        uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
        uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureStructI64>::fromJs(
            rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructF32> {
  static UniffiForeignFutureStructF32
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructF32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructF32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<float>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteF32, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteF32> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteF32 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteF32"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteF32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(
        uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
        uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureStructF32>::fromJs(
            rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructF64> {
  static UniffiForeignFutureStructF64
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructF64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructF64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<double>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteF64, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteF64> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteF64 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteF64"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteF64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(
        uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
        uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureStructF64>::fromJs(
            rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructPointer> {
  static UniffiForeignFutureStructPointer
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiForeignFutureStructPointer");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructPointer rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<void *>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompletePointer, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompletePointer> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompletePointer rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompletePointer"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompletePointer func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_spark::Bridging<
             UniffiForeignFutureStructPointer>::fromJs(rt, callInvoker,
                                                       args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructRustBuffer> {
  static UniffiForeignFutureStructRustBuffer
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiForeignFutureStructRustBuffer");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructRustBuffer rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value =
        uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteRustBuffer, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteRustBuffer> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteRustBuffer rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteRustBuffer"),
        2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteRustBuffer func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_spark::Bridging<
             UniffiForeignFutureStructRustBuffer>::fromJs(rt, callInvoker,
                                                          args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructVoid> {
  static UniffiForeignFutureStructVoid
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiForeignFutureStructVoid");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructVoid rsObject;

    // Create the vtable from the js callbacks.
    rsObject.call_status =
        uniffi::breez_sdk_spark::Bridging<RustCallStatus>::fromJs(
            rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteVoid, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::breez_sdk_spark {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteVoid> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteVoid rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteVoid"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteVoid func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::breez_sdk_spark::Bridging<
             UniffiForeignFutureStructVoid>::fromJs(rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::breez_sdk_spark
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceEventListenerMethod0

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceeventlistenermethod0::UniffiCallbackInterfaceEventListenerMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceeventlistenermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_event,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_event = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_event);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_event,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceEventListenerMethod0: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_event,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_event, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceEventListenerMethod0
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceeventlistenermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_event,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_event,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_event,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceeventlistenermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceLoggerMethod0

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceloggermethod0::UniffiCallbackInterfaceLoggerMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceloggermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, void *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_l,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_l = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_l);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_l);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceLoggerMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_l,
                     void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_l, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceLoggerMethod0
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceloggermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_l,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_l, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_l,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfaceloggermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceBitcoinChainServiceMethod0

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod0::UniffiCallbackInterfaceBitcoinChainServiceMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::
    callbackinterfacebitcoinchainservicemethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_address,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_address = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_address);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_address,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback "
                 "UniffiCallbackInterfaceBitcoinChainServiceMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_address,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_address, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceBitcoinChainServiceMethod0
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_address,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_address,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_address,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceBitcoinChainServiceMethod1

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod1::UniffiCallbackInterfaceBitcoinChainServiceMethod1
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::
    callbackinterfacebitcoinchainservicemethod1 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_txid,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_txid = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_txid);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_txid,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback "
                 "UniffiCallbackInterfaceBitcoinChainServiceMethod1: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_txid,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_txid, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceBitcoinChainServiceMethod1
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod1
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_txid,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_txid,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_txid,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod1
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceBitcoinChainServiceMethod2

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod2::UniffiCallbackInterfaceBitcoinChainServiceMethod2
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::
    callbackinterfacebitcoinchainservicemethod2 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_txid,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_txid = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_txid);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_txid,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback "
                 "UniffiCallbackInterfaceBitcoinChainServiceMethod2: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_txid,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_txid, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceBitcoinChainServiceMethod2
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod2
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_txid,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_txid,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_txid,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod2
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceBitcoinChainServiceMethod3

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod3::UniffiCallbackInterfaceBitcoinChainServiceMethod3
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::
    callbackinterfacebitcoinchainservicemethod3 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_tx,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_tx = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_tx);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_tx,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback "
                 "UniffiCallbackInterfaceBitcoinChainServiceMethod3: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_tx,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_tx, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceBitcoinChainServiceMethod3
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod3
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_tx,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_tx,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_tx,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod3
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceBitcoinChainServiceMethod4

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod4::UniffiCallbackInterfaceBitcoinChainServiceMethod4
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::
    callbackinterfacebitcoinchainservicemethod4 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, UniffiForeignFutureCompleteRustBuffer,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_uniffiFutureCallback,
                                js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback "
                 "UniffiCallbackInterfaceBitcoinChainServiceMethod4: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiFutureCallback, rs_uniffiCallbackData,
           rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceBitcoinChainServiceMethod4
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod4
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiFutureCallback,
         rs_uniffiCallbackData, rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod4
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod0

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod0::UniffiCallbackInterfaceExternalSignerMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::breez_sdk_spark::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod0: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceExternalSignerMethod0
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod1

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod1::UniffiCallbackInterfaceExternalSignerMethod1
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod1 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_path = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_path);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_path,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod1: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_path,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_path, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod1
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod1
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_path,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_path,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod1
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod2

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod2::UniffiCallbackInterfaceExternalSignerMethod2
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod2 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_message,
                 RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_message = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_message);
  auto js_path = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_path);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_message, js_path,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod2: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_message, RustBuffer rs_path,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_message, rs_path, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod2
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod2
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_message,
                 RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_message, rs_path,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_message,
               rs_path, rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod2
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod3

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod3::UniffiCallbackInterfaceExternalSignerMethod3
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod3 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_message,
                 RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_message = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_message);
  auto js_path = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_path);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_message, js_path,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod3: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_message, RustBuffer rs_path,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_message, rs_path, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod3
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod3
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_message,
                 RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_message, rs_path,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_message,
               rs_path, rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod3
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod4

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod4::UniffiCallbackInterfaceExternalSignerMethod4
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod4 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_message,
                 RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_message = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_message);
  auto js_path = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_path);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_message, js_path,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod4: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_message, RustBuffer rs_path,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_message, rs_path, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod4
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod4
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_message,
                 RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_message, rs_path,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_message,
               rs_path, rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod4
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod5

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod5::UniffiCallbackInterfaceExternalSignerMethod5
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod5 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_message,
                 RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_message = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_message);
  auto js_path = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_path);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_message, js_path,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod5: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_message, RustBuffer rs_path,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_message, rs_path, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod5
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod5
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_message,
                 RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_message, rs_path,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_message,
               rs_path, rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod5
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod6

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod6::UniffiCallbackInterfaceExternalSignerMethod6
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod6 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_hash,
                 RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_hash = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_hash);
  auto js_path = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_path);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_hash, js_path,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod6: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_hash, RustBuffer rs_path,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_hash, rs_path, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod6
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod6
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_hash,
                 RustBuffer rs_path,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_hash, rs_path,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_hash,
               rs_path, rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod6
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod7

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod7::UniffiCallbackInterfaceExternalSignerMethod7
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod7 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, UniffiForeignFutureCompleteRustBuffer,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_uniffiFutureCallback,
                                js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod7: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiFutureCallback, rs_uniffiCallbackData,
           rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod7
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod7
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiFutureCallback,
         rs_uniffiCallbackData, rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod7
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod8

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod8::UniffiCallbackInterfaceExternalSignerMethod8
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod8 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_id,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_id = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_id);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_id,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod8: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_id,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_id, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod8
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod8
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_id,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_id,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_id,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod8
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod9

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod9::UniffiCallbackInterfaceExternalSignerMethod9
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod9 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, UniffiForeignFutureCompleteRustBuffer,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_uniffiFutureCallback,
                                js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod9: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiFutureCallback, rs_uniffiCallbackData,
           rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod9
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod9
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiFutureCallback,
         rs_uniffiCallbackData, rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod9
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod10

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod10::UniffiCallbackInterfaceExternalSignerMethod10
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod10 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, uint32_t,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, uint32_t rs_index,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_index =
      uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rs_index);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_index,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod10: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, uint32_t rs_index,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_index, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod10
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod10
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, uint32_t rs_index,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_index,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_index,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod10
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod11

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod11::UniffiCallbackInterfaceExternalSignerMethod11
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod11 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, uint32_t,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, uint32_t rs_index,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_index =
      uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rs_index);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_index,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod11: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, uint32_t rs_index,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_index, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod11
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod11
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, uint32_t rs_index,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_index,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_index,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod11
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod12

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod12::UniffiCallbackInterfaceExternalSignerMethod12
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod12 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, uint32_t,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, uint32_t rs_index,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_index =
      uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rs_index);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_index,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod12: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, uint32_t rs_index,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_index, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod12
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod12
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, uint32_t rs_index,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_index,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_index,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod12
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod13

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod13::UniffiCallbackInterfaceExternalSignerMethod13
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod13 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_signingKey,
                 RustBuffer rs_newSigningKey,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_signingKey = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_signingKey);
  auto js_newSigningKey = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_newSigningKey);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult =
        cb.call(rt, js_uniffiHandle, js_signingKey, js_newSigningKey,
                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod13: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_signingKey,
         RustBuffer rs_newSigningKey,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_signingKey, rs_newSigningKey,
           rs_uniffiFutureCallback, rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod13
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod13
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_signingKey,
                 RustBuffer rs_newSigningKey,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_signingKey,
         rs_newSigningKey, rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_signingKey,
               rs_newSigningKey, rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod13
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod14

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod14::UniffiCallbackInterfaceExternalSignerMethod14
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod14 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, uint32_t, uint32_t,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_secret,
                 uint32_t rs_threshold, uint32_t rs_numShares,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_secret = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_secret);
  auto js_threshold =
      uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rs_threshold);
  auto js_numShares =
      uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rs_numShares);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult =
        cb.call(rt, js_uniffiHandle, js_secret, js_threshold, js_numShares,
                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod14: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_secret, uint32_t rs_threshold,
         uint32_t rs_numShares,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_secret, rs_threshold, rs_numShares,
           rs_uniffiFutureCallback, rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod14
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod14
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_secret,
                 uint32_t rs_threshold, uint32_t rs_numShares,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_secret, rs_threshold,
         rs_numShares, rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_secret,
               rs_threshold, rs_numShares, rs_uniffiFutureCallback,
               rs_uniffiCallbackData, rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod14
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod15

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod15::UniffiCallbackInterfaceExternalSignerMethod15
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod15 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_privateKey,
                 RustBuffer rs_receiverPublicKey,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_privateKey = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_privateKey);
  auto js_receiverPublicKey =
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                          rs_receiverPublicKey);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult =
        cb.call(rt, js_uniffiHandle, js_privateKey, js_receiverPublicKey,
                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod15: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_privateKey,
         RustBuffer rs_receiverPublicKey,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_privateKey, rs_receiverPublicKey,
           rs_uniffiFutureCallback, rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod15
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod15
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_privateKey,
                 RustBuffer rs_receiverPublicKey,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_privateKey,
         rs_receiverPublicKey, rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_privateKey,
               rs_receiverPublicKey, rs_uniffiFutureCallback,
               rs_uniffiCallbackData, rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod15
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod16

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod16::UniffiCallbackInterfaceExternalSignerMethod16
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod16 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_privateKey,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_privateKey = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_privateKey);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_privateKey,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod16: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_privateKey,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_privateKey, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod16
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod16
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_privateKey,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_privateKey,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_privateKey,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod16
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod17

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod17::UniffiCallbackInterfaceExternalSignerMethod17
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod17 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_request,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_request = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_request);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_request,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod17: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_request,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_request, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod17
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod17
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_request,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_request,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_request,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod17
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceExternalSignerMethod18

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod18::UniffiCallbackInterfaceExternalSignerMethod18
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod18 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_request,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_request = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_request);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_request,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceExternalSignerMethod18: "
        << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_request,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_request, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceExternalSignerMethod18
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod18
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_request,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_request,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_request,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod18
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceFiatServiceMethod0

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacefiatservicemethod0::UniffiCallbackInterfaceFiatServiceMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacefiatservicemethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, UniffiForeignFutureCompleteRustBuffer,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_uniffiFutureCallback,
                                js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFiatServiceMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiFutureCallback, rs_uniffiCallbackData,
           rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceFiatServiceMethod0
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacefiatservicemethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiFutureCallback,
         rs_uniffiCallbackData, rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacefiatservicemethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceFiatServiceMethod1

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacefiatservicemethod1::UniffiCallbackInterfaceFiatServiceMethod1
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacefiatservicemethod1 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, UniffiForeignFutureCompleteRustBuffer,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_uniffiFutureCallback,
                                js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFiatServiceMethod1: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiFutureCallback, rs_uniffiCallbackData,
           rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceFiatServiceMethod1
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacefiatservicemethod1
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiFutureCallback,
         rs_uniffiCallbackData, rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacefiatservicemethod1
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfacePaymentObserverMethod0

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacepaymentobservermethod0::UniffiCallbackInterfacePaymentObserverMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacepaymentobservermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_payments,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_payments = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_payments);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_payments,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfacePaymentObserverMethod0: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_payments,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_payments, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfacePaymentObserverMethod0
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacepaymentobservermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_payments,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_payments,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_payments,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::breez_sdk_spark::cb::callbackinterfacepaymentobservermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceRestClientMethod0

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod0::UniffiCallbackInterfaceRestClientMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_url,
                 RustBuffer rs_headers,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_url = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_url);
  auto js_headers = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_headers);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_url, js_headers,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceRestClientMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_url, RustBuffer rs_headers,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_url, rs_headers, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceRestClientMethod0
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_url,
                 RustBuffer rs_headers,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_url, rs_headers,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_url,
               rs_headers, rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceRestClientMethod1

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod1::UniffiCallbackInterfaceRestClientMethod1
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod1 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_url,
                 RustBuffer rs_headers, RustBuffer rs_body,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_url = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_url);
  auto js_headers = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_headers);
  auto js_body = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_body);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult =
        cb.call(rt, js_uniffiHandle, js_url, js_headers, js_body,
                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceRestClientMethod1: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_url, RustBuffer rs_headers,
         RustBuffer rs_body,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_url, rs_headers, rs_body,
           rs_uniffiFutureCallback, rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceRestClientMethod1
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod1
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_url,
                 RustBuffer rs_headers, RustBuffer rs_body,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_url, rs_headers,
         rs_body, rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_url,
               rs_headers, rs_body, rs_uniffiFutureCallback,
               rs_uniffiCallbackData, rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod1
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceRestClientMethod2

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod2::UniffiCallbackInterfaceRestClientMethod2
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod2 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_url,
                 RustBuffer rs_headers, RustBuffer rs_body,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_url = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_url);
  auto js_headers = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_headers);
  auto js_body = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_body);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult =
        cb.call(rt, js_uniffiHandle, js_url, js_headers, js_body,
                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceRestClientMethod2: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_url, RustBuffer rs_headers,
         RustBuffer rs_body,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_url, rs_headers, rs_body,
           rs_uniffiFutureCallback, rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceRestClientMethod2
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod2
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_url,
                 RustBuffer rs_headers, RustBuffer rs_body,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_url, rs_headers,
         rs_body, rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_url,
               rs_headers, rs_body, rs_uniffiFutureCallback,
               rs_uniffiCallbackData, rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod2
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod0

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod0::UniffiCallbackInterfaceStorageMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_key,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_key = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_key);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_key,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_key,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_key, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod0
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_key,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_key,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_key,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod1

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod1::UniffiCallbackInterfaceStorageMethod1
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod1 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_key,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_key = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_key);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_key,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod1: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_key,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_key, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod1
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod1
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_key,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_key,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_key,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod1
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod2

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod2::UniffiCallbackInterfaceStorageMethod2
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod2 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteVoid, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_key,
                 RustBuffer rs_value,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_key = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_key);
  auto js_value = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_value);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_key, js_value,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod2: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_key,
                     RustBuffer rs_value,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_key, rs_value, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod2
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod2
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_key,
                 RustBuffer rs_value,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_key, rs_value,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_key,
               rs_value, rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod2
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod3

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod3::UniffiCallbackInterfaceStorageMethod3
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod3 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_request,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_request = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_request);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_request,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod3: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_request,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_request, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod3
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod3
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_request,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_request,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_request,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod3
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod4

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod4::UniffiCallbackInterfaceStorageMethod4
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod4 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_payment,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_payment = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_payment);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_payment,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod4: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_payment,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_payment, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod4
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod4
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_payment,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_payment,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_payment,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod4
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod5

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod5::UniffiCallbackInterfaceStorageMethod5
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod5 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer,
                          UniffiForeignFutureCompleteVoid, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_paymentId,
                 RustBuffer rs_metadata,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_paymentId = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_paymentId);
  auto js_metadata = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_metadata);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_paymentId, js_metadata,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod5: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_paymentId,
                     RustBuffer rs_metadata,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_paymentId, rs_metadata, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod5
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod5
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_paymentId,
                 RustBuffer rs_metadata,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_paymentId, rs_metadata,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_paymentId,
               rs_metadata, rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod5
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod6

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod6::UniffiCallbackInterfaceStorageMethod6
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod6 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_id,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_id = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_id);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_id,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod6: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_id,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_id, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod6
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod6
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_id,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_id,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_id,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod6
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod7

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod7::UniffiCallbackInterfaceStorageMethod7
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod7 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_invoice,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_invoice = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_invoice);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_invoice,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod7: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, RustBuffer rs_invoice,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_invoice, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod7
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod7
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_invoice,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_invoice,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_invoice,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod7
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod8

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod8::UniffiCallbackInterfaceStorageMethod8
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod8 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, uint32_t, uint64_t,
                          UniffiForeignFutureCompleteVoid, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_txid, uint32_t rs_vout,
                 uint64_t rs_amountSats,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_txid = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_txid);
  auto js_vout = uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rs_vout);
  auto js_amountSats =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_amountSats);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult =
        cb.call(rt, js_uniffiHandle, js_txid, js_vout, js_amountSats,
                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod8: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_txid,
                     uint32_t rs_vout, uint64_t rs_amountSats,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_txid, rs_vout, rs_amountSats,
           rs_uniffiFutureCallback, rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod8
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod8
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_txid, uint32_t rs_vout,
                 uint64_t rs_amountSats,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_txid, rs_vout,
         rs_amountSats, rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_txid,
               rs_vout, rs_amountSats, rs_uniffiFutureCallback,
               rs_uniffiCallbackData, rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod8
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod9

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod9::UniffiCallbackInterfaceStorageMethod9
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod9 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, uint32_t,
                          UniffiForeignFutureCompleteVoid, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_txid, uint32_t rs_vout,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_txid = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_txid);
  auto js_vout = uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rs_vout);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_txid, js_vout,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod9: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_txid,
                     uint32_t rs_vout,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_txid, rs_vout, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod9
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod9
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_txid, uint32_t rs_vout,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_txid, rs_vout,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_txid,
               rs_vout, rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod9
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod10

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod10::UniffiCallbackInterfaceStorageMethod10
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod10 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, UniffiForeignFutureCompleteRustBuffer,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_uniffiFutureCallback,
                                js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod10: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiFutureCallback, rs_uniffiCallbackData,
           rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod10
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod10
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiFutureCallback,
         rs_uniffiCallbackData, rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod10
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod11

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod11::UniffiCallbackInterfaceStorageMethod11
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod11 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, uint32_t, RustBuffer,
                          UniffiForeignFutureCompleteVoid, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_txid, uint32_t rs_vout,
                 RustBuffer rs_payload,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_txid = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_txid);
  auto js_vout = uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rs_vout);
  auto js_payload = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_payload);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult =
        cb.call(rt, js_uniffiHandle, js_txid, js_vout, js_payload,
                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod11: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_txid,
                     uint32_t rs_vout, RustBuffer rs_payload,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_txid, rs_vout, rs_payload,
           rs_uniffiFutureCallback, rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod11
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod11
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_txid, uint32_t rs_vout,
                 RustBuffer rs_payload,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_txid, rs_vout,
         rs_payload, rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_txid,
               rs_vout, rs_payload, rs_uniffiFutureCallback,
               rs_uniffiCallbackData, rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod11
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceStorageMethod12

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod12::UniffiCallbackInterfaceStorageMethod12
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod12 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_metadata,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_metadata = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_metadata);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_metadata,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceStorageMethod12: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_metadata,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_metadata, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceStorageMethod12
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod12
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_metadata,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_metadata,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_metadata,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod12
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSyncStorageMethod0

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod0::UniffiCallbackInterfaceSyncStorageMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteU64,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_record,
                 UniffiForeignFutureCompleteU64 rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_record = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_record);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteU64>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_record,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSyncStorageMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_record,
                     UniffiForeignFutureCompleteU64 rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_record, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceSyncStorageMethod0
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_record,
                 UniffiForeignFutureCompleteU64 rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_record,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_record,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSyncStorageMethod1

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod1::UniffiCallbackInterfaceSyncStorageMethod1
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod1 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_record,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_record = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_record);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_record,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSyncStorageMethod1: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_record,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_record, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceSyncStorageMethod1
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod1
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_record,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_record,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_record,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod1
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSyncStorageMethod2

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod2::UniffiCallbackInterfaceSyncStorageMethod2
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod2 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, uint32_t,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, uint32_t rs_limit,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_limit =
      uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rs_limit);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_limit,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSyncStorageMethod2: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, uint32_t rs_limit,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_limit, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceSyncStorageMethod2
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod2
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, uint32_t rs_limit,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_limit,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_limit,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod2
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSyncStorageMethod3

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod3::UniffiCallbackInterfaceSyncStorageMethod3
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod3 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, UniffiForeignFutureCompleteU64, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteU64 rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteU64>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_uniffiFutureCallback,
                                js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSyncStorageMethod3: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle,
                     UniffiForeignFutureCompleteU64 rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiFutureCallback, rs_uniffiCallbackData,
           rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceSyncStorageMethod3
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod3
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteU64 rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiFutureCallback,
         rs_uniffiCallbackData, rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod3
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSyncStorageMethod4

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod4::UniffiCallbackInterfaceSyncStorageMethod4
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod4 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_records,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_records = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_records);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_records,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSyncStorageMethod4: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_records,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_records, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceSyncStorageMethod4
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod4
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_records,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_records,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_records,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod4
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSyncStorageMethod5

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod5::UniffiCallbackInterfaceSyncStorageMethod5
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod5 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_record,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_record = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_record);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_record,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSyncStorageMethod5: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_record,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_record, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceSyncStorageMethod5
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod5
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_record,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_record,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_record,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod5
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSyncStorageMethod6

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod6::UniffiCallbackInterfaceSyncStorageMethod6
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod6 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, uint64_t, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, uint64_t rs_revision,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_revision =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_revision);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_revision,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSyncStorageMethod6: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, uint64_t rs_revision,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_revision, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceSyncStorageMethod6
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod6
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, uint64_t rs_revision,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_revision,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_revision,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod6
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSyncStorageMethod7

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod7::UniffiCallbackInterfaceSyncStorageMethod7
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod7 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, uint32_t,
                          UniffiForeignFutureCompleteRustBuffer, uint64_t,
                          UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, uint32_t rs_limit,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_limit =
      uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, rs_limit);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_limit,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSyncStorageMethod7: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle, uint32_t rs_limit,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_limit, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceSyncStorageMethod7
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod7
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, uint32_t rs_limit,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_limit,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_limit,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod7
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSyncStorageMethod8

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod8::UniffiCallbackInterfaceSyncStorageMethod8
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod8 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, UniffiForeignFutureCompleteRustBuffer,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_uniffiFutureCallback = uniffi::breez_sdk_spark::Bridging<
      UniffiForeignFutureCompleteRustBuffer>::toJs(rt, callInvoker,
                                                   rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_uniffiFutureCallback,
                                js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSyncStorageMethod8: "
              << error.what() << std::endl;
    throw error;
  }
}

static void
callback(uint64_t rs_uniffiHandle,
         UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
         uint64_t rs_uniffiCallbackData,
         UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiFutureCallback, rs_uniffiCallbackData,
           rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceSyncStorageMethod8
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod8
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle,
                 UniffiForeignFutureCompleteRustBuffer rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiFutureCallback,
         rs_uniffiCallbackData, rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod8
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSyncStorageMethod9

// Callback function:
// uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod9::UniffiCallbackInterfaceSyncStorageMethod9
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod9 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, UniffiForeignFutureCompleteVoid,
                          uint64_t, UniffiForeignFuture *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_record,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_record = uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(
      rt, callInvoker, rs_record);
  auto js_uniffiFutureCallback =
      uniffi::breez_sdk_spark::Bridging<UniffiForeignFutureCompleteVoid>::toJs(
          rt, callInvoker, rs_uniffiFutureCallback);
  auto js_uniffiCallbackData = uniffi_jsi::Bridging<uint64_t>::toJs(
      rt, callInvoker, rs_uniffiCallbackData);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_record,
                                js_uniffiFutureCallback, js_uniffiCallbackData);

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi::breez_sdk_spark::Bridging<
        ReferenceHolder<UniffiForeignFuture>>::fromJs(rt, callInvoker,
                                                      uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSyncStorageMethod9: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_record,
                     UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                     uint64_t rs_uniffiCallbackData,
                     UniffiForeignFuture *rs_uniffiOutReturn) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_record, rs_uniffiFutureCallback,
           rs_uniffiCallbackData, rs_uniffiOutReturn);
}

static UniffiCallbackInterfaceSyncStorageMethod9
makeCallbackFunction( // uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod9
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_record,
                 UniffiForeignFutureCompleteVoid rs_uniffiFutureCallback,
                 uint64_t rs_uniffiCallbackData,
                 UniffiForeignFuture *rs_uniffiOutReturn) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_record,
         rs_uniffiFutureCallback, rs_uniffiCallbackData,
         rs_uniffiOutReturn](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_record,
               rs_uniffiFutureCallback, rs_uniffiCallbackData,
               rs_uniffiOutReturn);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeBreezSdkSpark, which only
// happens when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod9
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceEventListener> {
  static UniffiVTableCallbackInterfaceEventListener
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt,
          "Expected an object for UniffiVTableCallbackInterfaceEventListener");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceEventListener rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_event = uniffi::breez_sdk_spark::cb::
        callbackinterfaceeventlistenermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onEvent"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_spark::st::vtablecallbackinterfaceeventlistener::
            vtablecallbackinterfaceeventlistener::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceLogger> {
  static UniffiVTableCallbackInterfaceLogger
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiVTableCallbackInterfaceLogger");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceLogger rsObject;

    // Create the vtable from the js callbacks.
    rsObject.log = uniffi::breez_sdk_spark::cb::callbackinterfaceloggermethod0::
        makeCallbackFunction(rt, callInvoker, jsObject.getProperty(rt, "log"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_spark::st::vtablecallbackinterfacelogger::
            vtablecallbackinterfacelogger::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceBitcoinChainService> {
  static UniffiVTableCallbackInterfaceBitcoinChainService
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for "
                         "UniffiVTableCallbackInterfaceBitcoinChainService");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceBitcoinChainService rsObject;

    // Create the vtable from the js callbacks.
    rsObject.get_address_utxos = uniffi::breez_sdk_spark::cb::
        callbackinterfacebitcoinchainservicemethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "getAddressUtxos"));
    rsObject.get_transaction_status = uniffi::breez_sdk_spark::cb::
        callbackinterfacebitcoinchainservicemethod1::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "getTransactionStatus"));
    rsObject.get_transaction_hex = uniffi::breez_sdk_spark::cb::
        callbackinterfacebitcoinchainservicemethod2::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "getTransactionHex"));
    rsObject.broadcast_transaction = uniffi::breez_sdk_spark::cb::
        callbackinterfacebitcoinchainservicemethod3::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "broadcastTransaction"));
    rsObject.recommended_fees = uniffi::breez_sdk_spark::cb::
        callbackinterfacebitcoinchainservicemethod4::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "recommendedFees"));
    rsObject.uniffi_free = uniffi::breez_sdk_spark::st::
        vtablecallbackinterfacebitcoinchainservice::
            vtablecallbackinterfacebitcoinchainservice::free::
                makeCallbackFunction(rt, callInvoker,
                                     jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceExternalSigner> {
  static UniffiVTableCallbackInterfaceExternalSigner
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt,
          "Expected an object for UniffiVTableCallbackInterfaceExternalSigner");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceExternalSigner rsObject;

    // Create the vtable from the js callbacks.
    rsObject.identity_public_key = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "identityPublicKey"));
    rsObject.derive_public_key = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod1::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "derivePublicKey"));
    rsObject.sign_ecdsa = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod2::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "signEcdsa"));
    rsObject.sign_ecdsa_recoverable = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod3::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "signEcdsaRecoverable"));
    rsObject.ecies_encrypt = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod4::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "eciesEncrypt"));
    rsObject.ecies_decrypt = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod5::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "eciesDecrypt"));
    rsObject.sign_hash_schnorr = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod6::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "signHashSchnorr"));
    rsObject.generate_frost_signing_commitments = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod7::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "generateFrostSigningCommitments"));
    rsObject.get_public_key_for_node = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod8::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "getPublicKeyForNode"));
    rsObject.generate_random_key = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod9::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "generateRandomKey"));
    rsObject.get_static_deposit_private_key_source = uniffi::breez_sdk_spark::
        cb::callbackinterfaceexternalsignermethod10::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "getStaticDepositPrivateKeySource"));
    rsObject.get_static_deposit_private_key = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod11::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "getStaticDepositPrivateKey"));
    rsObject.get_static_deposit_public_key = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod12::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "getStaticDepositPublicKey"));
    rsObject.subtract_private_keys = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod13::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "subtractPrivateKeys"));
    rsObject.split_secret = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod14::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "splitSecret"));
    rsObject.encrypt_private_key_for_receiver = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod15::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "encryptPrivateKeyForReceiver"));
    rsObject.get_public_key_from_private_key_source = uniffi::breez_sdk_spark::
        cb::callbackinterfaceexternalsignermethod16::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "getPublicKeyFromPrivateKeySource"));
    rsObject.sign_frost = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod17::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "signFrost"));
    rsObject.aggregate_frost_signatures = uniffi::breez_sdk_spark::cb::
        callbackinterfaceexternalsignermethod18::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "aggregateFrostSignatures"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_spark::st::vtablecallbackinterfaceexternalsigner::
            vtablecallbackinterfaceexternalsigner::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceFiatService> {
  static UniffiVTableCallbackInterfaceFiatService
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt,
          "Expected an object for UniffiVTableCallbackInterfaceFiatService");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceFiatService rsObject;

    // Create the vtable from the js callbacks.
    rsObject.fetch_fiat_currencies = uniffi::breez_sdk_spark::cb::
        callbackinterfacefiatservicemethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "fetchFiatCurrencies"));
    rsObject.fetch_fiat_rates = uniffi::breez_sdk_spark::cb::
        callbackinterfacefiatservicemethod1::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "fetchFiatRates"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_spark::st::vtablecallbackinterfacefiatservice::
            vtablecallbackinterfacefiatservice::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfacePaymentObserver> {
  static UniffiVTableCallbackInterfacePaymentObserver
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for "
                             "UniffiVTableCallbackInterfacePaymentObserver");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfacePaymentObserver rsObject;

    // Create the vtable from the js callbacks.
    rsObject.before_send = uniffi::breez_sdk_spark::cb::
        callbackinterfacepaymentobservermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "beforeSend"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_spark::st::vtablecallbackinterfacepaymentobserver::
            vtablecallbackinterfacepaymentobserver::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceRestClient> {
  static UniffiVTableCallbackInterfaceRestClient
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiVTableCallbackInterfaceRestClient");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceRestClient rsObject;

    // Create the vtable from the js callbacks.
    rsObject.get_request = uniffi::breez_sdk_spark::cb::
        callbackinterfacerestclientmethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "getRequest"));
    rsObject.post_request = uniffi::breez_sdk_spark::cb::
        callbackinterfacerestclientmethod1::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "postRequest"));
    rsObject.delete_request = uniffi::breez_sdk_spark::cb::
        callbackinterfacerestclientmethod2::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "deleteRequest"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_spark::st::vtablecallbackinterfacerestclient::
            vtablecallbackinterfacerestclient::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceStorage> {
  static UniffiVTableCallbackInterfaceStorage
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiVTableCallbackInterfaceStorage");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceStorage rsObject;

    // Create the vtable from the js callbacks.
    rsObject.delete_cached_item = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "deleteCachedItem"));
    rsObject.get_cached_item = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod1::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "getCachedItem"));
    rsObject.set_cached_item = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod2::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "setCachedItem"));
    rsObject.list_payments = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod3::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "listPayments"));
    rsObject.insert_payment = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod4::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "insertPayment"));
    rsObject.set_payment_metadata = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod5::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "setPaymentMetadata"));
    rsObject.get_payment_by_id = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod6::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "getPaymentById"));
    rsObject.get_payment_by_invoice = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod7::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "getPaymentByInvoice"));
    rsObject.add_deposit = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod8::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "addDeposit"));
    rsObject.delete_deposit = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod9::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "deleteDeposit"));
    rsObject.list_deposits = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod10::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "listDeposits"));
    rsObject.update_deposit = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod11::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "updateDeposit"));
    rsObject.set_lnurl_metadata = uniffi::breez_sdk_spark::cb::
        callbackinterfacestoragemethod12::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "setLnurlMetadata"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_spark::st::vtablecallbackinterfacestorage::
            vtablecallbackinterfacestorage::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark
namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceSyncStorage> {
  static UniffiVTableCallbackInterfaceSyncStorage
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt,
          "Expected an object for UniffiVTableCallbackInterfaceSyncStorage");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceSyncStorage rsObject;

    // Create the vtable from the js callbacks.
    rsObject.add_outgoing_change = uniffi::breez_sdk_spark::cb::
        callbackinterfacesyncstoragemethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "addOutgoingChange"));
    rsObject.complete_outgoing_sync = uniffi::breez_sdk_spark::cb::
        callbackinterfacesyncstoragemethod1::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "completeOutgoingSync"));
    rsObject.get_pending_outgoing_changes = uniffi::breez_sdk_spark::cb::
        callbackinterfacesyncstoragemethod2::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "getPendingOutgoingChanges"));
    rsObject.get_last_revision = uniffi::breez_sdk_spark::cb::
        callbackinterfacesyncstoragemethod3::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "getLastRevision"));
    rsObject.insert_incoming_records = uniffi::breez_sdk_spark::cb::
        callbackinterfacesyncstoragemethod4::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "insertIncomingRecords"));
    rsObject.delete_incoming_record = uniffi::breez_sdk_spark::cb::
        callbackinterfacesyncstoragemethod5::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "deleteIncomingRecord"));
    rsObject.rebase_pending_outgoing_records = uniffi::breez_sdk_spark::cb::
        callbackinterfacesyncstoragemethod6::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "rebasePendingOutgoingRecords"));
    rsObject.get_incoming_records = uniffi::breez_sdk_spark::cb::
        callbackinterfacesyncstoragemethod7::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "getIncomingRecords"));
    rsObject.get_latest_outgoing_change = uniffi::breez_sdk_spark::cb::
        callbackinterfacesyncstoragemethod8::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "getLatestOutgoingChange"));
    rsObject.update_record_from_incoming = uniffi::breez_sdk_spark::cb::
        callbackinterfacesyncstoragemethod9::makeCallbackFunction(
            rt, callInvoker,
            jsObject.getProperty(rt, "updateRecordFromIncoming"));
    rsObject.uniffi_free =
        uniffi::breez_sdk_spark::st::vtablecallbackinterfacesyncstorage::
            vtablecallbackinterfacesyncstorage::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::breez_sdk_spark

namespace uniffi::breez_sdk_spark {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiRustFutureContinuationCallback> {
  static UniffiRustFutureContinuationCallback
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &value) {
    try {
      return uniffi::breez_sdk_spark::cb::rustfuturecontinuationcallback::
          makeCallbackFunction(rt, callInvoker, value);
    } catch (const std::logic_error &e) {
      throw jsi::JSError(rt, e.what());
    }
  }
};

} // namespace uniffi::breez_sdk_spark

NativeBreezSdkSpark::NativeBreezSdkSpark(
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> invoker)
    : callInvoker(invoker), props() {
  // Map from Javascript names to the cpp names
  props["ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__string_to_byte_length(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_free_bitcoinchainservice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_free_bitcoinchainservice"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_"
        "utxos"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "bitcoinchainservice_get_address_utxos"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_"
        "transaction_status"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                "bitcoinchainservice_get_transaction_status"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_"
        "transaction_hex"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "bitcoinchainservice_get_transaction_hex"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_"
        "transaction"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                "bitcoinchainservice_broadcast_transaction"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_"
        "fees"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "bitcoinchainservice_recommended_fees"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_fees(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_clone_breezsdk"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_clone_breezsdk"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_clone_breezsdk(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_free_breezsdk"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_free_breezsdk"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_free_breezsdk(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "breezsdk_add_event_listener"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_cancel_leaf_"
        "optimization"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "breezsdk_cancel_leaf_optimization"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_cancel_leaf_optimization(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_"
        "address_available"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                "breezsdk_check_lightning_address_available"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_check_message"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_check_message"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "breezsdk_claim_htlc_payment"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_"
        "address"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "breezsdk_delete_lightning_address"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_fetch_conversion_"
        "limits"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "breezsdk_fetch_conversion_limits"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_fetch_conversion_limits(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_info"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_info"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_leaf_optimization_"
        "progress"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "breezsdk_get_leaf_optimization_progress"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_leaf_optimization_progress(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_"
        "address"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "breezsdk_get_lightning_address"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "breezsdk_get_token_issuer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "breezsdk_get_tokens_metadata"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "breezsdk_get_user_settings"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "breezsdk_list_fiat_currencies"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_"
        "deposits"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "breezsdk_list_unclaimed_deposits"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_parse"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_parse"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_parse(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "breezsdk_prepare_lnurl_pay"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "breezsdk_prepare_send_payment"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "breezsdk_recommended_fees"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_"
        "address"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "breezsdk_register_lightning_address"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_"
        "listener"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "breezsdk_remove_event_listener"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_start_leaf_"
        "optimization"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "breezsdk_start_leaf_optimization"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_start_leaf_optimization(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "breezsdk_update_user_settings"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_clone_externalsigner"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_clone_externalsigner"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_clone_externalsigner(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_free_externalsigner"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_free_externalsigner"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_free_externalsigner(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_identity_public_"
        "key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "externalsigner_identity_public_key"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_identity_public_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_derive_public_"
        "key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "externalsigner_derive_public_key"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_derive_public_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "externalsigner_sign_ecdsa"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa_"
        "recoverable"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "externalsigner_sign_ecdsa_recoverable"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa_recoverable(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_encrypt"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "externalsigner_ecies_encrypt"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_encrypt(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_decrypt"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "externalsigner_ecies_decrypt"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_decrypt(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_hash_"
        "schnorr"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "externalsigner_sign_hash_schnorr"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_hash_schnorr(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_generate_frost_"
        "signing_commitments"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_generate_"
              "frost_signing_commitments"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_generate_frost_signing_commitments(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_"
        "for_node"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "externalsigner_get_public_key_for_node"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_for_node(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_"
        "key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "externalsigner_generate_random_key"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_"
        "deposit_private_key_source"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_"
              "deposit_private_key_source"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key_source(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_"
        "deposit_private_key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_"
              "deposit_private_key"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_"
        "deposit_public_key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                "externalsigner_get_static_deposit_public_key"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_public_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_subtract_private_"
        "keys"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "externalsigner_subtract_private_keys"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_subtract_private_keys(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_split_secret"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "externalsigner_split_secret"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_split_secret(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_private_"
        "key_for_receiver"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_"
              "private_key_for_receiver"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_private_key_for_receiver(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_"
        "from_private_key_source"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_"
              "key_from_private_key_source"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_from_private_key_source(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_frost"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "externalsigner_sign_frost"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_frost(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_aggregate_frost_"
        "signatures"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                "externalsigner_aggregate_frost_signatures"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_aggregate_frost_signatures(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_clone_fiatservice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_clone_fiatservice"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_clone_fiatservice(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_free_fiatservice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_free_fiatservice"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_free_fiatservice(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_"
        "currencies"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "fiatservice_fetch_fiat_currencies"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "fiatservice_fetch_fiat_rates"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_clone_paymentobserver"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_clone_paymentobserver"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_clone_paymentobserver(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_free_paymentobserver"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_free_paymentobserver"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_free_paymentobserver(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "paymentobserver_before_send"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_clone_restclient"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_clone_restclient"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_clone_restclient(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_free_restclient"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_free_restclient"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_free_restclient(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_restclient_get_request"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_restclient_get_request"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_restclient_get_request(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_restclient_post_request"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_restclient_post_request"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_restclient_post_request(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_restclient_delete_request"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "restclient_delete_request"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_restclient_delete_request(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_clone_sdkbuilder"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_clone_sdkbuilder"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_clone_sdkbuilder(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_free_sdkbuilder"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_free_sdkbuilder"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_free_sdkbuilder(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_build"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_build"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "sdkbuilder_with_chain_service"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_"
        "storage"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "sdkbuilder_with_default_storage"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "sdkbuilder_with_fiat_service"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "sdkbuilder_with_lnurl_client"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_"
        "observer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "sdkbuilder_with_payment_observer"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_"
        "storage"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "sdkbuilder_with_real_time_sync_storage"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_"
        "service"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "sdkbuilder_with_rest_chain_service"),
      4,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_clone_storage"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_clone_storage"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_clone_storage(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_free_storage"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_free_storage"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_free_storage(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "storage_delete_cached_item"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_cached_item"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_cached_item"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_cached_item"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_cached_item"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_payments"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_payments"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_list_payments(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_insert_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_storage_insert_payment"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "storage_set_payment_metadata"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "storage_get_payment_by_id"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_"
        "invoice"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "storage_get_payment_by_invoice"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_add_deposit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_method_storage_add_deposit"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_deposit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_deposit"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_deposits"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_deposits"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_update_deposit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_method_storage_update_deposit"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "storage_set_lnurl_metadata"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_clone_syncstorage"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_clone_syncstorage"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_clone_syncstorage(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_free_syncstorage"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_free_syncstorage"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_free_syncstorage(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_add_outgoing_"
        "change"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "syncstorage_add_outgoing_change"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_add_outgoing_change(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_complete_outgoing_"
        "sync"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "syncstorage_complete_outgoing_sync"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_complete_outgoing_sync(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_get_pending_"
        "outgoing_changes"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "syncstorage_get_pending_outgoing_changes"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_get_pending_outgoing_changes(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_get_last_revision"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "syncstorage_get_last_revision"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_get_last_revision(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_insert_incoming_"
        "records"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "syncstorage_insert_incoming_records"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_insert_incoming_records(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_delete_incoming_"
        "record"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "syncstorage_delete_incoming_record"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_delete_incoming_record(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_rebase_pending_"
        "outgoing_records"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                "syncstorage_rebase_pending_outgoing_records"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_rebase_pending_outgoing_records(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_get_incoming_"
        "records"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "syncstorage_get_incoming_records"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_get_incoming_records(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_get_latest_outgoing_"
        "change"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "syncstorage_get_latest_outgoing_change"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_get_latest_outgoing_change(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_syncstorage_update_record_from_"
        "incoming"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "syncstorage_update_record_from_incoming"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_update_record_from_incoming(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_clone_tokenissuer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_clone_tokenissuer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_clone_tokenissuer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_free_tokenissuer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_free_tokenissuer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_free_tokenissuer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "tokenissuer_burn_issuer_token"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_"
        "token"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "tokenissuer_create_issuer_token"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_token(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_"
        "token"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "tokenissuer_freeze_issuer_token"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_token(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_"
        "balance"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "tokenissuer_get_issuer_token_balance"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_balance(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_"
        "metadata"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "tokenissuer_get_issuer_token_metadata"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_metadata(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                        "tokenissuer_mint_issuer_token"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_"
        "token"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_method_"
                                    "tokenissuer_unfreeze_issuer_token"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_token(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_func_connect"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_func_connect"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_func_connect(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_func_connect_with_signer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_func_connect_with_signer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_func_connect_with_signer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_func_default_config"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_func_default_config"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_func_default_config(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_func_default_external_signer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_func_default_external_signer"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_func_default_external_signer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_func_init_logging"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_func_init_logging"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_fn_func_init_logging(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_u8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_u8"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_u8(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_u8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_u8"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_u8(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_u8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_u8"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_u8(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_u8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_u8"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_u8(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_i8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_i8"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_i8(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_i8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_i8"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_i8(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_i8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_i8"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_i8(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_i8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_i8"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_i8(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_u16"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_u16"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_u16(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_u16"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_u16"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_u16(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_u16"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_u16"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_u16(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_u16"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_u16"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_u16(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_i16"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_i16"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_i16(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_i16"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_i16"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_i16(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_i16"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_i16"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_i16(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_i16"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_i16"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_i16(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_u32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_u32"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_u32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_u32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_u32"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_u32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_u32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_u32"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_u32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_u32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_u32"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_u32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_i32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_i32"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_i32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_i32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_i32"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_i32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_i32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_i32"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_i32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_i32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_i32"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_i32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_u64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_u64"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_u64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_u64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_u64"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_u64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_u64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_u64"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_u64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_u64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_u64"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_u64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_i64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_i64"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_i64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_i64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_i64"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_i64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_i64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_i64"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_i64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_i64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_i64"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_i64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_f32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_f32"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_f32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_f32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_f32"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_f32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_f32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_f32"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_f32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_f32"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_f32"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_f32(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_f64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_f64"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_f64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_f64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_f64"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_f64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_f64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_f64"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_f64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_f64"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_f64"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_f64(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_pointer(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_pointer(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_pointer(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_pointer(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_rust_buffer(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_rust_buffer(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_ffi_breez_sdk_spark_rust_future_complete_rust_buffer(
                    rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_poll_void"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_poll_void"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_poll_void(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_cancel_void"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_cancel_void"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_cancel_void(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_free_void"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_free_void"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_free_void(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_rust_future_complete_void"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_rust_future_complete_void"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_rust_future_complete_void(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_func_connect"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_checksum_func_connect"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_checksum_func_connect(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_func_connect_with_signer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_checksum_func_connect_with_signer"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_func_connect_with_signer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_func_default_config"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_checksum_func_default_config"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_func_default_config(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_func_default_external_signer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "func_default_external_signer"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_func_default_external_signer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_func_init_logging"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_checksum_func_init_logging"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_checksum_func_init_logging(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_"
        "address_utxos"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "bitcoinchainservice_get_address_utxos"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_"
        "transaction_status"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "bitcoinchainservice_get_transaction_status"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_"
        "transaction_hex"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "bitcoinchainservice_get_transaction_hex"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_"
        "broadcast_transaction"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "bitcoinchainservice_broadcast_transaction"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_"
        "recommended_fees"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "bitcoinchainservice_recommended_fees"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_"
        "listener"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_add_event_listener"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_"
        "optimization"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_cancel_leaf_optimization"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_optimization(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_"
        "address_available"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "breezsdk_check_lightning_address_available"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_breezsdk_check_message"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_breezsdk_claim_deposit"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_"
        "payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_claim_htlc_payment"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_"
        "address"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_delete_lightning_address"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_breezsdk_disconnect"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_conversion_"
        "limits"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_fetch_conversion_limits"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_conversion_limits(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_"
        "optimization_progress"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "breezsdk_get_leaf_optimization_progress"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_optimization_progress(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_"
        "address"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_get_lightning_address"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_breezsdk_get_payment"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_"
        "issuer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_get_token_issuer"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_"
        "metadata"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_get_tokens_metadata"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_"
        "settings"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_get_user_settings"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_"
        "currencies"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_list_fiat_currencies"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_"
        "rates"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_list_fiat_rates"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_breezsdk_list_payments"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_"
        "deposits"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_list_unclaimed_deposits"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_breezsdk_lnurl_withdraw"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_parse"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_parse"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_parse(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_"
        "pay"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_prepare_lnurl_pay"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_"
        "payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_prepare_send_payment"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_"
        "payment"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_receive_payment"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_"
        "fees"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_recommended_fees"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_breezsdk_refund_deposit"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_register_"
        "lightning_address"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "breezsdk_register_lightning_address"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_"
        "listener"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_remove_event_listener"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_breezsdk_send_payment"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_breezsdk_sign_message"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_"
        "optimization"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_start_leaf_optimization"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_optimization(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_breezsdk_sync_wallet"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_"
        "settings"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_breezsdk_update_user_settings"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_"
        "public_key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "externalsigner_identity_public_key"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_public_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_"
        "public_key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_externalsigner_derive_public_key"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_public_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_"
        "ecdsa"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_externalsigner_sign_ecdsa"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_"
        "recoverable"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "externalsigner_sign_ecdsa_recoverable"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_recoverable(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_"
        "encrypt"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_externalsigner_ecies_encrypt"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_encrypt(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_"
        "decrypt"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_externalsigner_ecies_decrypt"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_decrypt(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_"
        "schnorr"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_externalsigner_sign_hash_schnorr"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_schnorr(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_"
        "frost_signing_commitments"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_"
              "generate_frost_signing_commitments"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_frost_signing_commitments(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_"
        "key_for_node"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "externalsigner_get_public_key_for_node"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_for_node(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_"
        "random_key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "externalsigner_generate_random_key"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_"
        "deposit_private_key_source"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_"
              "static_deposit_private_key_source"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key_source(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_"
        "deposit_private_key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_"
              "static_deposit_private_key"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_"
        "deposit_public_key"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "externalsigner_get_static_deposit_public_key"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_public_key(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_"
        "private_keys"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "externalsigner_subtract_private_keys"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_private_keys(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_split_"
        "secret"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_externalsigner_split_secret"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_split_secret(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_"
        "private_key_for_receiver"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_"
              "encrypt_private_key_for_receiver"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_private_key_for_receiver(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_"
        "key_from_private_key_source"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_"
              "public_key_from_private_key_source"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_from_private_key_source(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_"
        "frost"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_externalsigner_sign_frost"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_frost(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_"
        "frost_signatures"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "externalsigner_aggregate_frost_signatures"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_frost_signatures(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_"
        "currencies"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_fiatservice_fetch_fiat_currencies"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_"
        "rates"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_fiatservice_fetch_fiat_rates"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_"
        "send"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_paymentobserver_before_send"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_restclient_get_request"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_restclient_get_request"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_restclient_get_request(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_restclient_post_request"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_restclient_post_request"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_restclient_post_request(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_restclient_delete_"
        "request"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_restclient_delete_request"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_restclient_delete_request(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_"
        "service"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_sdkbuilder_with_chain_service"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_"
        "storage"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_sdkbuilder_with_default_storage"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_"
        "service"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_sdkbuilder_with_fiat_service"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_sdkbuilder_with_key_set"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_"
        "client"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_sdkbuilder_with_lnurl_client"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_"
        "observer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_sdkbuilder_with_payment_observer"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_"
        "sync_storage"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "sdkbuilder_with_real_time_sync_storage"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_"
        "chain_service"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "sdkbuilder_with_rest_chain_service"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_sdkbuilder_with_storage"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_"
        "item"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_storage_delete_cached_item"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_storage_get_cached_item"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_storage_set_cached_item"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_list_payments"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_storage_list_payments"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_list_payments(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_insert_payment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_storage_insert_payment"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_insert_payment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_payment_"
        "metadata"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_storage_set_payment_metadata"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_"
        "id"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_storage_get_payment_by_id"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_"
        "invoice"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_storage_get_payment_by_invoice"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_add_deposit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_storage_add_deposit"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_add_deposit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_storage_delete_deposit"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_list_deposits"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_storage_list_deposits"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_list_deposits(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_update_deposit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_storage_update_deposit"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_update_deposit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_"
        "metadata"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_storage_set_lnurl_metadata"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_"
        "change"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_syncstorage_add_outgoing_change"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_change(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_"
        "outgoing_sync"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "syncstorage_complete_outgoing_sync"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_outgoing_sync(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_"
        "outgoing_changes"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "syncstorage_get_pending_outgoing_changes"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_outgoing_changes(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_"
        "revision"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_syncstorage_get_last_revision"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_revision(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_"
        "incoming_records"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "syncstorage_insert_incoming_records"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_incoming_records(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_"
        "incoming_record"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "syncstorage_delete_incoming_record"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_incoming_record(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_"
        "pending_outgoing_records"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "syncstorage_rebase_pending_outgoing_records"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_pending_outgoing_records(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_"
        "records"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_syncstorage_get_incoming_records"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_records(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_"
        "outgoing_change"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "syncstorage_get_latest_outgoing_change"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_outgoing_change(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_"
        "from_incoming"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "syncstorage_update_record_from_incoming"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_from_incoming(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_"
        "token"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_tokenissuer_burn_issuer_token"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_"
        "token"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_tokenissuer_create_issuer_token"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_"
        "token"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_tokenissuer_freeze_issuer_token"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_"
        "token_balance"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "tokenissuer_get_issuer_token_balance"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_"
        "token_metadata"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_breez_sdk_spark_checksum_method_"
                                "tokenissuer_get_issuer_token_metadata"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_"
        "token"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_tokenissuer_mint_issuer_token"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_"
        "issuer_token"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                    "method_tokenissuer_unfreeze_issuer_token"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "constructor_sdkbuilder_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_checksum_"
                                        "method_eventlistener_on_event"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_checksum_method_logger_log"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_checksum_method_logger_log"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_breez_sdk_spark_checksum_method_logger_log(
                rt, thisVal, args, count);
          });
  props["ubrn_ffi_breez_sdk_spark_uniffi_contract_version"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_ffi_breez_sdk_spark_uniffi_contract_version"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_breez_sdk_spark_uniffi_contract_version(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_init_"
                                        "callback_vtable_eventlistener"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_logger"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_logger"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_"
        "bitcoinchainservice"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_init_"
                                    "callback_vtable_bitcoinchainservice"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_externalsigner"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_init_"
                                        "callback_vtable_externalsigner"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_externalsigner(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_init_"
                                        "callback_vtable_fiatservice"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_init_"
                                        "callback_vtable_paymentobserver"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_storage"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_storage"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_syncstorage"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_breez_sdk_spark_fn_init_"
                                        "callback_vtable_syncstorage"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_syncstorage(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_bitcoinchainservice_ffi__bless_"
        "pointer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                    "bitcoinchainservice_ffi__bless_pointer"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_internal_fn_method_bitcoinchainservice_ffi__bless_pointer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_internal_fn_method_breezsdk_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_method_breezsdk_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_breezsdk_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_externalsigner_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "externalsigner_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_externalsigner_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_fiatservice_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_fiatservice_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_fiatservice_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_paymentobserver_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "paymentobserver_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_paymentobserver_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_restclient_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_restclient_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_restclient_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_sdkbuilder_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_sdkbuilder_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_sdkbuilder_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_storage_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_method_storage_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_storage_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_syncstorage_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_syncstorage_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_syncstorage_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_tokenissuer_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_tokenissuer_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_tokenissuer_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
}

void NativeBreezSdkSpark::registerModule(
    jsi::Runtime &rt, std::shared_ptr<react::CallInvoker> callInvoker) {
  auto invoker =
      std::make_shared<uniffi_runtime::UniffiCallInvoker>(callInvoker);
  auto tm = std::make_shared<NativeBreezSdkSpark>(rt, invoker);
  auto obj = rt.global().createFromHostObject(rt, tm);
  rt.global().setProperty(rt, "NativeBreezSdkSpark", obj);
}

void NativeBreezSdkSpark::unregisterModule(jsi::Runtime &rt) {
  uniffi::breez_sdk_spark::registry::clearRegistry();
}

jsi::Value NativeBreezSdkSpark::get(jsi::Runtime &rt,
                                    const jsi::PropNameID &name) {
  try {
    return jsi::Value(rt, props.at(name.utf8(rt)));
  } catch (std::out_of_range &e) {
    return jsi::Value::undefined();
  }
}

std::vector<jsi::PropNameID>
NativeBreezSdkSpark::getPropertyNames(jsi::Runtime &rt) {
  std::vector<jsi::PropNameID> rval;
  for (auto &[key, value] : props) {
    rval.push_back(jsi::PropNameID::forUtf8(rt, key));
  }
  return rval;
}

void NativeBreezSdkSpark::set(jsi::Runtime &rt, const jsi::PropNameID &name,
                              const jsi::Value &value) {
  props.insert_or_assign(name.utf8(rt), &value);
}

NativeBreezSdkSpark::~NativeBreezSdkSpark() {
  // Cleanup for callback function RustFutureContinuationCallback
  uniffi::breez_sdk_spark::cb::rustfuturecontinuationcallback::cleanup();
  // Cleanup for "free" callback function CallbackInterfaceFree
  uniffi::breez_sdk_spark::st::foreignfuture::foreignfuture::free::cleanup();
  uniffi::breez_sdk_spark::st::vtablecallbackinterfaceeventlistener::
      vtablecallbackinterfaceeventlistener::free::cleanup();
  uniffi::breez_sdk_spark::st::vtablecallbackinterfacelogger::
      vtablecallbackinterfacelogger::free::cleanup();
  uniffi::breez_sdk_spark::st::vtablecallbackinterfacebitcoinchainservice::
      vtablecallbackinterfacebitcoinchainservice::free::cleanup();
  uniffi::breez_sdk_spark::st::vtablecallbackinterfaceexternalsigner::
      vtablecallbackinterfaceexternalsigner::free::cleanup();
  uniffi::breez_sdk_spark::st::vtablecallbackinterfacefiatservice::
      vtablecallbackinterfacefiatservice::free::cleanup();
  uniffi::breez_sdk_spark::st::vtablecallbackinterfacepaymentobserver::
      vtablecallbackinterfacepaymentobserver::free::cleanup();
  uniffi::breez_sdk_spark::st::vtablecallbackinterfacerestclient::
      vtablecallbackinterfacerestclient::free::cleanup();
  uniffi::breez_sdk_spark::st::vtablecallbackinterfacestorage::
      vtablecallbackinterfacestorage::free::cleanup();
  uniffi::breez_sdk_spark::st::vtablecallbackinterfacesyncstorage::
      vtablecallbackinterfacesyncstorage::free::cleanup();
  // Cleanup for callback function CallbackInterfaceEventListenerMethod0
  uniffi::breez_sdk_spark::cb::callbackinterfaceeventlistenermethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceLoggerMethod0
  uniffi::breez_sdk_spark::cb::callbackinterfaceloggermethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceBitcoinChainServiceMethod0
  uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod0::
      cleanup();
  // Cleanup for callback function CallbackInterfaceBitcoinChainServiceMethod1
  uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod1::
      cleanup();
  // Cleanup for callback function CallbackInterfaceBitcoinChainServiceMethod2
  uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod2::
      cleanup();
  // Cleanup for callback function CallbackInterfaceBitcoinChainServiceMethod3
  uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod3::
      cleanup();
  // Cleanup for callback function CallbackInterfaceBitcoinChainServiceMethod4
  uniffi::breez_sdk_spark::cb::callbackinterfacebitcoinchainservicemethod4::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod0
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod0::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod1
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod1::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod2
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod2::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod3
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod3::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod4
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod4::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod5
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod5::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod6
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod6::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod7
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod7::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod8
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod8::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod9
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod9::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod10
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod10::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod11
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod11::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod12
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod12::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod13
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod13::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod14
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod14::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod15
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod15::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod16
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod16::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod17
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod17::
      cleanup();
  // Cleanup for callback function CallbackInterfaceExternalSignerMethod18
  uniffi::breez_sdk_spark::cb::callbackinterfaceexternalsignermethod18::
      cleanup();
  // Cleanup for callback function CallbackInterfaceFiatServiceMethod0
  uniffi::breez_sdk_spark::cb::callbackinterfacefiatservicemethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceFiatServiceMethod1
  uniffi::breez_sdk_spark::cb::callbackinterfacefiatservicemethod1::cleanup();
  // Cleanup for callback function CallbackInterfacePaymentObserverMethod0
  uniffi::breez_sdk_spark::cb::callbackinterfacepaymentobservermethod0::
      cleanup();
  // Cleanup for callback function CallbackInterfaceRestClientMethod0
  uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceRestClientMethod1
  uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod1::cleanup();
  // Cleanup for callback function CallbackInterfaceRestClientMethod2
  uniffi::breez_sdk_spark::cb::callbackinterfacerestclientmethod2::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod0
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod1
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod1::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod2
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod2::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod3
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod3::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod4
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod4::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod5
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod5::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod6
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod6::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod7
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod7::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod8
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod8::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod9
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod9::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod10
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod10::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod11
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod11::cleanup();
  // Cleanup for callback function CallbackInterfaceStorageMethod12
  uniffi::breez_sdk_spark::cb::callbackinterfacestoragemethod12::cleanup();
  // Cleanup for callback function CallbackInterfaceSyncStorageMethod0
  uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceSyncStorageMethod1
  uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod1::cleanup();
  // Cleanup for callback function CallbackInterfaceSyncStorageMethod2
  uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod2::cleanup();
  // Cleanup for callback function CallbackInterfaceSyncStorageMethod3
  uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod3::cleanup();
  // Cleanup for callback function CallbackInterfaceSyncStorageMethod4
  uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod4::cleanup();
  // Cleanup for callback function CallbackInterfaceSyncStorageMethod5
  uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod5::cleanup();
  // Cleanup for callback function CallbackInterfaceSyncStorageMethod6
  uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod6::cleanup();
  // Cleanup for callback function CallbackInterfaceSyncStorageMethod7
  uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod7::cleanup();
  // Cleanup for callback function CallbackInterfaceSyncStorageMethod8
  uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod8::cleanup();
  // Cleanup for callback function CallbackInterfaceSyncStorageMethod9
  uniffi::breez_sdk_spark::cb::callbackinterfacesyncstoragemethod9::cleanup();
}

// Utility functions for serialization/deserialization of strings.
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_internal_fn_func_ffi__string_to_byte_length(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  return uniffi_jsi::Bridging<std::string>::string_to_bytelength(rt, args[0]);
}

jsi::Value
NativeBreezSdkSpark::cpp_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  return uniffi_jsi::Bridging<std::string>::string_to_arraybuffer(rt, args[0]);
}

jsi::Value
NativeBreezSdkSpark::cpp_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  return uniffi_jsi::Bridging<std::string>::arraybuffer_to_string(rt, args[0]);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_internal_fn_method_bitcoinchainservice_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_internal_fn_method_breezsdk_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_spark_fn_free_breezsdk(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_internal_fn_method_externalsigner_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_spark_fn_free_externalsigner(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_internal_fn_method_fiatservice_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_spark_fn_free_fiatservice(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_internal_fn_method_paymentobserver_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_spark_fn_free_paymentobserver(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_internal_fn_method_restclient_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_spark_fn_free_restclient(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_internal_fn_method_sdkbuilder_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_spark_fn_free_sdkbuilder(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_internal_fn_method_storage_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_spark_fn_free_storage(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_internal_fn_method_syncstorage_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_spark_fn_free_syncstorage(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_internal_fn_method_tokenissuer_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_breez_sdk_spark_fn_free_tokenissuer(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}

// Methods calling directly into the uniffi generated C API of the Rust crate.
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_fees(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_fees(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_clone_breezsdk(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_clone_breezsdk(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_free_breezsdk(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_free_breezsdk(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_cancel_leaf_optimization(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_breezsdk_cancel_leaf_optimization(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_fetch_conversion_limits(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_breezsdk_fetch_conversion_limits(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_leaf_optimization_progress(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_spark_fn_method_breezsdk_get_leaf_optimization_progress(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                             value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_parse(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_parse(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_start_leaf_optimization(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_method_breezsdk_start_leaf_optimization(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_clone_externalsigner(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_clone_externalsigner(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_free_externalsigner(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_free_externalsigner(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_identity_public_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_identity_public_key(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                             value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_derive_public_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_derive_public_key(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa_recoverable(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa_recoverable(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_encrypt(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_encrypt(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_decrypt(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_decrypt(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_hash_schnorr(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_sign_hash_schnorr(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_generate_frost_signing_commitments(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_generate_frost_signing_commitments(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_for_node(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_for_node(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_key(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key_source(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key_source(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_public_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_public_key(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_subtract_private_keys(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_subtract_private_keys(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_split_secret(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_externalsigner_split_secret(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[3]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_private_key_for_receiver(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_private_key_for_receiver(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_from_private_key_source(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_from_private_key_source(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_frost(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_externalsigner_sign_frost(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_externalsigner_aggregate_frost_signatures(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_externalsigner_aggregate_frost_signatures(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_clone_fiatservice(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_clone_fiatservice(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_free_fiatservice(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_free_fiatservice(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_clone_paymentobserver(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_clone_paymentobserver(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_free_paymentobserver(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_free_paymentobserver(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_clone_restclient(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_clone_restclient(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_free_restclient(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_free_restclient(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_restclient_get_request(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_restclient_get_request(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_restclient_post_request(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_restclient_post_request(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[2]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[3]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_restclient_delete_request(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_restclient_delete_request(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[2]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[3]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_clone_sdkbuilder(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_clone_sdkbuilder(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_free_sdkbuilder(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_free_sdkbuilder(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[2]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[3]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_clone_storage(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_clone_storage(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_free_storage(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_free_storage(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_storage_list_payments(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_list_payments(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[3]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[3]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_clone_syncstorage(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_clone_syncstorage(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_free_syncstorage(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_free_syncstorage(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_add_outgoing_change(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_syncstorage_add_outgoing_change(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_complete_outgoing_sync(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_syncstorage_complete_outgoing_sync(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_get_pending_outgoing_changes(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_syncstorage_get_pending_outgoing_changes(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_get_last_revision(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_syncstorage_get_last_revision(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_insert_incoming_records(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_syncstorage_insert_incoming_records(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_delete_incoming_record(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_syncstorage_delete_incoming_record(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_rebase_pending_outgoing_records(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_syncstorage_rebase_pending_outgoing_records(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_get_incoming_records(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_syncstorage_get_incoming_records(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_get_latest_outgoing_change(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_syncstorage_get_latest_outgoing_change(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_syncstorage_update_record_from_incoming(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_syncstorage_update_record_from_incoming(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_clone_tokenissuer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_clone_tokenissuer(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_free_tokenissuer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_free_tokenissuer(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_token(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_token(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_token(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_token(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_balance(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_balance(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_metadata(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_metadata(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_token(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_token(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                                args[1]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_func_connect(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_func_connect(
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_func_connect_with_signer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_fn_func_connect_with_signer(
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[0]));

  return uniffi_jsi::Bridging</*handle*/ uint64_t>::toJs(rt, callInvoker,
                                                         value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_func_default_config(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_func_default_config(
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                             value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_func_default_external_signer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_breez_sdk_spark_fn_func_default_external_signer(
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[2]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[3]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_func_init_logging(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_breez_sdk_spark_fn_func_init_logging(
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[0]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[1]),
      uniffi::breez_sdk_spark::Bridging<RustBuffer>::fromJs(rt, callInvoker,
                                                            args[2]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_u8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_u8(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_u8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_u8(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_u8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_u8(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_u8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_u8(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<uint8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_i8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_i8(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_i8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_i8(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_i8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_i8(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_i8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_i8(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_u16(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_u16(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_u16(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_u16(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_u16(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_u16(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_u16(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_u16(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_i16(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_i16(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_i16(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_i16(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_i16(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_i16(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_i16(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_i16(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<int16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_u32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_u32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_u32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_u32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_u32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_u32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_u32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_u32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_i32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_i32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_i32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_i32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_i32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_i32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_i32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_i32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<int32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_u64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_u64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_u64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_u64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_u64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_u64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_u64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_u64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_i64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_i64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_i64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_i64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_i64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_i64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_i64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_i64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<int64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_f32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_f32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_f32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_f32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_f32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_f32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_f32(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_f32(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<float>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_f64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_f64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_f64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_f64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_f64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_f64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_f64(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_f64(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<double>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_pointer(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_pointer(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_pointer(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_pointer(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_rust_buffer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_rust_buffer(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_rust_buffer(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_rust_buffer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_rust_buffer(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_rust_buffer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = ffi_breez_sdk_spark_rust_future_complete_rust_buffer(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return uniffi::breez_sdk_spark::Bridging<RustBuffer>::toJs(rt, callInvoker,
                                                             value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_poll_void(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_poll_void(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      uniffi::breez_sdk_spark::Bridging<
          UniffiRustFutureContinuationCallback>::fromJs(rt, callInvoker,
                                                        args[1]),
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[2]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_cancel_void(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_cancel_void(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_free_void(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  ffi_breez_sdk_spark_rust_future_free_void(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]));

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_rust_future_complete_void(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::breez_sdk_spark::Bridging<RustCallStatus>::rustSuccess(rt);
  ffi_breez_sdk_spark_rust_future_complete_void(
      uniffi_jsi::Bridging</*handle*/ uint64_t>::fromJs(rt, callInvoker,
                                                        args[0]),
      &status);
  uniffi::breez_sdk_spark::Bridging<RustCallStatus>::copyIntoJs(
      rt, callInvoker, status, args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_checksum_func_connect(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_func_connect();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_func_connect_with_signer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_func_connect_with_signer();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_checksum_func_default_config(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_func_default_config();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_func_default_external_signer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_func_default_external_signer();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_checksum_func_init_logging(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_func_init_logging();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_optimization(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_optimization();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_conversion_limits(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_conversion_limits();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_optimization_progress(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_optimization_progress();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_parse(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_parse();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_optimization(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_optimization();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_public_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_public_key();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_public_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_public_key();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_recoverable(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_recoverable();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_encrypt(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_encrypt();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_decrypt(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_decrypt();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_schnorr(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_schnorr();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_frost_signing_commitments(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_frost_signing_commitments();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_for_node(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_for_node();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_key();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key_source(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key_source();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_public_key(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_public_key();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_private_keys(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_private_keys();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_split_secret(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_split_secret();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_private_key_for_receiver(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_private_key_for_receiver();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_from_private_key_source(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_from_private_key_source();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_frost(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_frost();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_frost_signatures(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_frost_signatures();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_restclient_get_request(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_restclient_get_request();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_restclient_post_request(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_restclient_post_request();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_restclient_delete_request(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_restclient_delete_request();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_list_payments(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_storage_list_payments();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_insert_payment(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_storage_insert_payment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_add_deposit(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_storage_add_deposit();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_list_deposits(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_storage_list_deposits();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_update_deposit(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_storage_update_deposit();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_change(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_change();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_outgoing_sync(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_outgoing_sync();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_outgoing_changes(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_outgoing_changes();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_revision(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_revision();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_incoming_records(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_incoming_records();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_incoming_record(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_incoming_record();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_pending_outgoing_records(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_pending_outgoing_records();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_records(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_records();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_outgoing_change(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_outgoing_change();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_from_incoming(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_from_incoming();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_checksum_method_logger_log(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_breez_sdk_spark_checksum_method_logger_log();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::cpp_ffi_breez_sdk_spark_uniffi_contract_version(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = ffi_breez_sdk_spark_uniffi_contract_version();

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_spark::Bridging<
      UniffiVTableCallbackInterfaceEventListener>::fromJs(rt, callInvoker,
                                                          args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_spark::registry::vtableMutex);
  uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(
      uniffi::breez_sdk_spark::registry::putTable(
          "UniffiVTableCallbackInterfaceEventListener", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance = uniffi::breez_sdk_spark::Bridging<
      UniffiVTableCallbackInterfaceLogger>::fromJs(rt, callInvoker, args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_spark::registry::vtableMutex);
  uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(
      uniffi::breez_sdk_spark::registry::putTable(
          "UniffiVTableCallbackInterfaceLogger", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_spark::Bridging<
      UniffiVTableCallbackInterfaceBitcoinChainService>::fromJs(rt, callInvoker,
                                                                args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_spark::registry::vtableMutex);
  uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(
      uniffi::breez_sdk_spark::registry::putTable(
          "UniffiVTableCallbackInterfaceBitcoinChainService", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_externalsigner(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_spark::Bridging<
      UniffiVTableCallbackInterfaceExternalSigner>::fromJs(rt, callInvoker,
                                                           args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_spark::registry::vtableMutex);
  uniffi_breez_sdk_spark_fn_init_callback_vtable_externalsigner(
      uniffi::breez_sdk_spark::registry::putTable(
          "UniffiVTableCallbackInterfaceExternalSigner", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_spark::Bridging<
      UniffiVTableCallbackInterfaceFiatService>::fromJs(rt, callInvoker,
                                                        args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_spark::registry::vtableMutex);
  uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice(
      uniffi::breez_sdk_spark::registry::putTable(
          "UniffiVTableCallbackInterfaceFiatService", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_spark::Bridging<
      UniffiVTableCallbackInterfacePaymentObserver>::fromJs(rt, callInvoker,
                                                            args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_spark::registry::vtableMutex);
  uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(
      uniffi::breez_sdk_spark::registry::putTable(
          "UniffiVTableCallbackInterfacePaymentObserver", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_spark::Bridging<
      UniffiVTableCallbackInterfaceRestClient>::fromJs(rt, callInvoker,
                                                       args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_spark::registry::vtableMutex);
  uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient(
      uniffi::breez_sdk_spark::registry::putTable(
          "UniffiVTableCallbackInterfaceRestClient", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value
NativeBreezSdkSpark::cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance = uniffi::breez_sdk_spark::Bridging<
      UniffiVTableCallbackInterfaceStorage>::fromJs(rt, callInvoker, args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_spark::registry::vtableMutex);
  uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(
      uniffi::breez_sdk_spark::registry::putTable(
          "UniffiVTableCallbackInterfaceStorage", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeBreezSdkSpark::
    cpp_uniffi_breez_sdk_spark_fn_init_callback_vtable_syncstorage(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::breez_sdk_spark::Bridging<
      UniffiVTableCallbackInterfaceSyncStorage>::fromJs(rt, callInvoker,
                                                        args[0]);

  std::lock_guard<std::mutex> lock(
      uniffi::breez_sdk_spark::registry::vtableMutex);
  uniffi_breez_sdk_spark_fn_init_callback_vtable_syncstorage(
      uniffi::breez_sdk_spark::registry::putTable(
          "UniffiVTableCallbackInterfaceSyncStorage", vtableInstance));
  return jsi::Value::undefined();
}