"use strict";// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule from"./breez_sdk_spark-ffi.js";import{AbstractFfiConverterByteArray,FfiConverterArray,FfiConverterArrayBuffer,FfiConverterBool,FfiConverterCallback,FfiConverterFloat64,FfiConverterInt32,FfiConverterMap,FfiConverterObject,FfiConverterObjectWithCallbacks,FfiConverterOptional,FfiConverterUInt16,FfiConverterUInt32,FfiConverterUInt64,FfiConverterUInt8,UniffiAbstractObject,UniffiEnum,UniffiError,UniffiInternalError,UniffiResult,UniffiRustCaller,destructorGuardSymbol,pointerLiteralSymbol,uniffiCreateFfiConverterString,uniffiCreateRecord,uniffiRustCallAsync,uniffiTraitInterfaceCall,uniffiTraitInterfaceCallAsync,uniffiTraitInterfaceCallAsyncWithError,uniffiTraitInterfaceCallWithError,uniffiTypeNameSymbol}from'uniffi-bindgen-react-native';// Get converters from the other files, if any.
const uniffiCaller=new UniffiRustCaller();const uniffiIsDebug=// @ts-ignore -- The process global might not be defined
typeof process!=='object'||// @ts-ignore -- The process global might not be defined
process?.env?.NODE_ENV!=='production'||false;// Public interface members begin here.
/**
 * Connects to the Spark network using the provided configuration and mnemonic.
 *
 * # Arguments
 *
 * * `request` - The connection request object
 *
 * # Returns
 *
 * Result containing either the initialized `BreezSdk` or an `SdkError`
 */export async function connect(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_connect(FfiConverterTypeConnectRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_pointer,/*liftFunc:*/FfiConverterTypeBreezSdk.lift.bind(FfiConverterTypeBreezSdk),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
 * Connects to the Spark network using an external signer.
 *
 * This method allows using a custom signer implementation instead of providing
 * a seed directly.
 *
 * # Arguments
 *
 * * `request` - The connection request object with external signer
 *
 * # Returns
 *
 * Result containing either the initialized `BreezSdk` or an `SdkError`
 */export async function connectWithSigner(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_connect_with_signer(FfiConverterTypeConnectWithSignerRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_pointer,/*liftFunc:*/FfiConverterTypeBreezSdk.lift.bind(FfiConverterTypeBreezSdk),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}export function defaultConfig(network){return FfiConverterTypeConfig.lift(uniffiCaller.rustCall(/*caller:*/callStatus=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_default_config(FfiConverterTypeNetwork.lower(network),callStatus);},/*liftString:*/FfiConverterString.lift));}/**
 * Creates a default external signer from a mnemonic.
 *
 * This is a convenience factory method for creating a signer that can be used
 * with `connect_with_signer` or `SdkBuilder::new_with_signer`.
 *
 * # Arguments
 *
 * * `mnemonic` - BIP39 mnemonic phrase (12 or 24 words)
 * * `passphrase` - Optional passphrase for the mnemonic
 * * `network` - Network to use (Mainnet or Regtest)
 * * `key_set_config` - Optional key set configuration. If None, uses default configuration.
 *
 * # Returns
 *
 * Result containing the signer as `Arc<dyn ExternalSigner>`
 */export function defaultExternalSigner(mnemonic,passphrase,network,keySetConfig)/*throws*/{return FfiConverterTypeExternalSigner.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError),/*caller:*/callStatus=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_default_external_signer(FfiConverterString.lower(mnemonic),FfiConverterOptionalString.lower(passphrase),FfiConverterTypeNetwork.lower(network),FfiConverterOptionalTypeKeySetConfig.lower(keySetConfig),callStatus);},/*liftString:*/FfiConverterString.lift));}/**
 * Fetches the current status of Spark network services relevant to the SDK.
 *
 * This function queries the Spark status API and returns the worst status
 * across the Spark Operators and SSP services.
 */export async function getSparkStatus(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_get_spark_status();},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeSparkStatus.lift.bind(FfiConverterTypeSparkStatus),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}export function initLogging(logDir,appLogger,logFilter)/*throws*/{uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError),/*caller:*/callStatus=>{nativeModule().ubrn_uniffi_breez_sdk_spark_fn_func_init_logging(FfiConverterOptionalString.lower(logDir),FfiConverterOptionalTypeLogger.lower(appLogger),FfiConverterOptionalString.lower(logFilter),callStatus);},/*liftString:*/FfiConverterString.lift);}/**
 * Trait for event listeners
 */// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEventListener={// Create the VTable using a series of closures.
// ts automatically converts these into C callback functions.
vtable:{onEvent:(uniffiHandle,event,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeEventListener.lift(uniffiHandle);return await jsCallback.onEvent(FfiConverterTypeSdkEvent.lift(event),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsync(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},uniffiFree:uniffiHandle=>{// EventListener: this will throw a stale handle error if the handle isn't found.
FfiConverterTypeEventListener.drop(uniffiHandle);}},register:()=>{nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(uniffiCallbackInterfaceEventListener.vtable);}};// FfiConverter protocol for callback interfaces
const FfiConverterTypeEventListener=new FfiConverterCallback();// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLogger={// Create the VTable using a series of closures.
// ts automatically converts these into C callback functions.
vtable:{log:(uniffiHandle,l)=>{const uniffiMakeCall=()=>{const jsCallback=FfiConverterTypeLogger.lift(uniffiHandle);return jsCallback.log(FfiConverterTypeLogEntry.lift(l));};const uniffiResult=UniffiResult.ready();const uniffiHandleSuccess=obj=>{};const uniffiHandleError=(code,errBuf)=>{UniffiResult.writeError(uniffiResult,code,errBuf);};uniffiTraitInterfaceCall(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*lowerString:*/FfiConverterString.lower);return uniffiResult;},uniffiFree:uniffiHandle=>{// Logger: this will throw a stale handle error if the handle isn't found.
FfiConverterTypeLogger.drop(uniffiHandle);}},register:()=>{nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(uniffiCallbackInterfaceLogger.vtable);}};// FfiConverter protocol for callback interfaces
const FfiConverterTypeLogger=new FfiConverterCallback();/**
 * Payload of the AES success action, as received from the LNURL endpoint
 *
 * See [`AesSuccessActionDataDecrypted`] for a similar wrapper containing the decrypted payload
 *//**
 * Generated factory for {@link AesSuccessActionData} record objects.
 */export const AesSuccessActionData=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link AesSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link AesSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeAesSuccessActionData=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{description:FfiConverterString.read(from),ciphertext:FfiConverterString.read(from),iv:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.description,into);FfiConverterString.write(value.ciphertext,into);FfiConverterString.write(value.iv,into);}allocationSize(value){return FfiConverterString.allocationSize(value.description)+FfiConverterString.allocationSize(value.ciphertext)+FfiConverterString.allocationSize(value.iv);}}return new FFIConverter();})();/**
 * Wrapper for the decrypted [`AesSuccessActionData`] payload
 *//**
 * Generated factory for {@link AesSuccessActionDataDecrypted} record objects.
 */export const AesSuccessActionDataDecrypted=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link AesSuccessActionDataDecrypted}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link AesSuccessActionDataDecrypted}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeAesSuccessActionDataDecrypted=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{description:FfiConverterString.read(from),plaintext:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.description,into);FfiConverterString.write(value.plaintext,into);}allocationSize(value){return FfiConverterString.allocationSize(value.description)+FfiConverterString.allocationSize(value.plaintext);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bip21Details} record objects.
 */export const Bip21Details=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bip21Details}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bip21Details}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBip21Details=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{amountSat:FfiConverterOptionalUInt64.read(from),assetId:FfiConverterOptionalString.read(from),uri:FfiConverterString.read(from),extras:FfiConverterArrayTypeBip21Extra.read(from),label:FfiConverterOptionalString.read(from),message:FfiConverterOptionalString.read(from),paymentMethods:FfiConverterArrayTypeInputType.read(from)};}write(value,into){FfiConverterOptionalUInt64.write(value.amountSat,into);FfiConverterOptionalString.write(value.assetId,into);FfiConverterString.write(value.uri,into);FfiConverterArrayTypeBip21Extra.write(value.extras,into);FfiConverterOptionalString.write(value.label,into);FfiConverterOptionalString.write(value.message,into);FfiConverterArrayTypeInputType.write(value.paymentMethods,into);}allocationSize(value){return FfiConverterOptionalUInt64.allocationSize(value.amountSat)+FfiConverterOptionalString.allocationSize(value.assetId)+FfiConverterString.allocationSize(value.uri)+FfiConverterArrayTypeBip21Extra.allocationSize(value.extras)+FfiConverterOptionalString.allocationSize(value.label)+FfiConverterOptionalString.allocationSize(value.message)+FfiConverterArrayTypeInputType.allocationSize(value.paymentMethods);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bip21Extra} record objects.
 */export const Bip21Extra=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bip21Extra}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bip21Extra}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBip21Extra=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{key:FfiConverterString.read(from),value:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.key,into);FfiConverterString.write(value.value,into);}allocationSize(value){return FfiConverterString.allocationSize(value.key)+FfiConverterString.allocationSize(value.value);}}return new FFIConverter();})();/**
 * Generated factory for {@link BitcoinAddressDetails} record objects.
 */export const BitcoinAddressDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link BitcoinAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link BitcoinAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBitcoinAddressDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{address:FfiConverterString.read(from),network:FfiConverterTypeBitcoinNetwork.read(from),source:FfiConverterTypePaymentRequestSource.read(from)};}write(value,into){FfiConverterString.write(value.address,into);FfiConverterTypeBitcoinNetwork.write(value.network,into);FfiConverterTypePaymentRequestSource.write(value.source,into);}allocationSize(value){return FfiConverterString.allocationSize(value.address)+FfiConverterTypeBitcoinNetwork.allocationSize(value.network)+FfiConverterTypePaymentRequestSource.allocationSize(value.source);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bolt11Invoice} record objects.
 */export const Bolt11Invoice=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bolt11Invoice}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bolt11Invoice}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBolt11Invoice=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bolt11:FfiConverterString.read(from),source:FfiConverterTypePaymentRequestSource.read(from)};}write(value,into){FfiConverterString.write(value.bolt11,into);FfiConverterTypePaymentRequestSource.write(value.source,into);}allocationSize(value){return FfiConverterString.allocationSize(value.bolt11)+FfiConverterTypePaymentRequestSource.allocationSize(value.source);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bolt11InvoiceDetails} record objects.
 */export const Bolt11InvoiceDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bolt11InvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bolt11InvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBolt11InvoiceDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{amountMsat:FfiConverterOptionalUInt64.read(from),description:FfiConverterOptionalString.read(from),descriptionHash:FfiConverterOptionalString.read(from),expiry:FfiConverterUInt64.read(from),invoice:FfiConverterTypeBolt11Invoice.read(from),minFinalCltvExpiryDelta:FfiConverterUInt64.read(from),network:FfiConverterTypeBitcoinNetwork.read(from),payeePubkey:FfiConverterString.read(from),paymentHash:FfiConverterString.read(from),paymentSecret:FfiConverterString.read(from),routingHints:FfiConverterArrayTypeBolt11RouteHint.read(from),timestamp:FfiConverterUInt64.read(from)};}write(value,into){FfiConverterOptionalUInt64.write(value.amountMsat,into);FfiConverterOptionalString.write(value.description,into);FfiConverterOptionalString.write(value.descriptionHash,into);FfiConverterUInt64.write(value.expiry,into);FfiConverterTypeBolt11Invoice.write(value.invoice,into);FfiConverterUInt64.write(value.minFinalCltvExpiryDelta,into);FfiConverterTypeBitcoinNetwork.write(value.network,into);FfiConverterString.write(value.payeePubkey,into);FfiConverterString.write(value.paymentHash,into);FfiConverterString.write(value.paymentSecret,into);FfiConverterArrayTypeBolt11RouteHint.write(value.routingHints,into);FfiConverterUInt64.write(value.timestamp,into);}allocationSize(value){return FfiConverterOptionalUInt64.allocationSize(value.amountMsat)+FfiConverterOptionalString.allocationSize(value.description)+FfiConverterOptionalString.allocationSize(value.descriptionHash)+FfiConverterUInt64.allocationSize(value.expiry)+FfiConverterTypeBolt11Invoice.allocationSize(value.invoice)+FfiConverterUInt64.allocationSize(value.minFinalCltvExpiryDelta)+FfiConverterTypeBitcoinNetwork.allocationSize(value.network)+FfiConverterString.allocationSize(value.payeePubkey)+FfiConverterString.allocationSize(value.paymentHash)+FfiConverterString.allocationSize(value.paymentSecret)+FfiConverterArrayTypeBolt11RouteHint.allocationSize(value.routingHints)+FfiConverterUInt64.allocationSize(value.timestamp);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bolt11RouteHint} record objects.
 */export const Bolt11RouteHint=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bolt11RouteHint}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bolt11RouteHint}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBolt11RouteHint=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{hops:FfiConverterArrayTypeBolt11RouteHintHop.read(from)};}write(value,into){FfiConverterArrayTypeBolt11RouteHintHop.write(value.hops,into);}allocationSize(value){return FfiConverterArrayTypeBolt11RouteHintHop.allocationSize(value.hops);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bolt11RouteHintHop} record objects.
 */export const Bolt11RouteHintHop=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bolt11RouteHintHop}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bolt11RouteHintHop}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBolt11RouteHintHop=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{srcNodeId:FfiConverterString.read(from),shortChannelId:FfiConverterString.read(from),feesBaseMsat:FfiConverterUInt32.read(from),feesProportionalMillionths:FfiConverterUInt32.read(from),cltvExpiryDelta:FfiConverterUInt16.read(from),htlcMinimumMsat:FfiConverterOptionalUInt64.read(from),htlcMaximumMsat:FfiConverterOptionalUInt64.read(from)};}write(value,into){FfiConverterString.write(value.srcNodeId,into);FfiConverterString.write(value.shortChannelId,into);FfiConverterUInt32.write(value.feesBaseMsat,into);FfiConverterUInt32.write(value.feesProportionalMillionths,into);FfiConverterUInt16.write(value.cltvExpiryDelta,into);FfiConverterOptionalUInt64.write(value.htlcMinimumMsat,into);FfiConverterOptionalUInt64.write(value.htlcMaximumMsat,into);}allocationSize(value){return FfiConverterString.allocationSize(value.srcNodeId)+FfiConverterString.allocationSize(value.shortChannelId)+FfiConverterUInt32.allocationSize(value.feesBaseMsat)+FfiConverterUInt32.allocationSize(value.feesProportionalMillionths)+FfiConverterUInt16.allocationSize(value.cltvExpiryDelta)+FfiConverterOptionalUInt64.allocationSize(value.htlcMinimumMsat)+FfiConverterOptionalUInt64.allocationSize(value.htlcMaximumMsat);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bolt12Invoice} record objects.
 */export const Bolt12Invoice=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bolt12Invoice}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bolt12Invoice}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBolt12Invoice=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{invoice:FfiConverterString.read(from),source:FfiConverterTypePaymentRequestSource.read(from)};}write(value,into){FfiConverterString.write(value.invoice,into);FfiConverterTypePaymentRequestSource.write(value.source,into);}allocationSize(value){return FfiConverterString.allocationSize(value.invoice)+FfiConverterTypePaymentRequestSource.allocationSize(value.source);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bolt12InvoiceDetails} record objects.
 */export const Bolt12InvoiceDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bolt12InvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bolt12InvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBolt12InvoiceDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{amountMsat:FfiConverterUInt64.read(from),invoice:FfiConverterTypeBolt12Invoice.read(from)};}write(value,into){FfiConverterUInt64.write(value.amountMsat,into);FfiConverterTypeBolt12Invoice.write(value.invoice,into);}allocationSize(value){return FfiConverterUInt64.allocationSize(value.amountMsat)+FfiConverterTypeBolt12Invoice.allocationSize(value.invoice);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bolt12InvoiceRequestDetails} record objects.
 */export const Bolt12InvoiceRequestDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bolt12InvoiceRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bolt12InvoiceRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBolt12InvoiceRequestDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{};}write(value,into){}allocationSize(value){return 0;}}return new FFIConverter();})();/**
 * Generated factory for {@link Bolt12Offer} record objects.
 */export const Bolt12Offer=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bolt12Offer}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bolt12Offer}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBolt12Offer=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{offer:FfiConverterString.read(from),source:FfiConverterTypePaymentRequestSource.read(from)};}write(value,into){FfiConverterString.write(value.offer,into);FfiConverterTypePaymentRequestSource.write(value.source,into);}allocationSize(value){return FfiConverterString.allocationSize(value.offer)+FfiConverterTypePaymentRequestSource.allocationSize(value.source);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bolt12OfferBlindedPath} record objects.
 */export const Bolt12OfferBlindedPath=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bolt12OfferBlindedPath}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bolt12OfferBlindedPath}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBolt12OfferBlindedPath=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{blindedHops:FfiConverterArrayString.read(from)};}write(value,into){FfiConverterArrayString.write(value.blindedHops,into);}allocationSize(value){return FfiConverterArrayString.allocationSize(value.blindedHops);}}return new FFIConverter();})();/**
 * Generated factory for {@link Bolt12OfferDetails} record objects.
 */export const Bolt12OfferDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Bolt12OfferDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Bolt12OfferDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBolt12OfferDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{absoluteExpiry:FfiConverterOptionalUInt64.read(from),chains:FfiConverterArrayString.read(from),description:FfiConverterOptionalString.read(from),issuer:FfiConverterOptionalString.read(from),minAmount:FfiConverterOptionalTypeAmount.read(from),offer:FfiConverterTypeBolt12Offer.read(from),paths:FfiConverterArrayTypeBolt12OfferBlindedPath.read(from),signingPubkey:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterOptionalUInt64.write(value.absoluteExpiry,into);FfiConverterArrayString.write(value.chains,into);FfiConverterOptionalString.write(value.description,into);FfiConverterOptionalString.write(value.issuer,into);FfiConverterOptionalTypeAmount.write(value.minAmount,into);FfiConverterTypeBolt12Offer.write(value.offer,into);FfiConverterArrayTypeBolt12OfferBlindedPath.write(value.paths,into);FfiConverterOptionalString.write(value.signingPubkey,into);}allocationSize(value){return FfiConverterOptionalUInt64.allocationSize(value.absoluteExpiry)+FfiConverterArrayString.allocationSize(value.chains)+FfiConverterOptionalString.allocationSize(value.description)+FfiConverterOptionalString.allocationSize(value.issuer)+FfiConverterOptionalTypeAmount.allocationSize(value.minAmount)+FfiConverterTypeBolt12Offer.allocationSize(value.offer)+FfiConverterArrayTypeBolt12OfferBlindedPath.allocationSize(value.paths)+FfiConverterOptionalString.allocationSize(value.signingPubkey);}}return new FFIConverter();})();/**
 * Generated factory for {@link BurnIssuerTokenRequest} record objects.
 */export const BurnIssuerTokenRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link BurnIssuerTokenRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link BurnIssuerTokenRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBurnIssuerTokenRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{amount:FfiConverterTypeu128.read(from)};}write(value,into){FfiConverterTypeu128.write(value.amount,into);}allocationSize(value){return FfiConverterTypeu128.allocationSize(value.amount);}}return new FFIConverter();})();/**
 * Request to buy Bitcoin using an external provider (`MoonPay`)
 *//**
 * Generated factory for {@link BuyBitcoinRequest} record objects.
 */export const BuyBitcoinRequest=(()=>{const defaults=()=>({lockedAmountSat:undefined,redirectUrl:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link BuyBitcoinRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link BuyBitcoinRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBuyBitcoinRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{lockedAmountSat:FfiConverterOptionalUInt64.read(from),redirectUrl:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterOptionalUInt64.write(value.lockedAmountSat,into);FfiConverterOptionalString.write(value.redirectUrl,into);}allocationSize(value){return FfiConverterOptionalUInt64.allocationSize(value.lockedAmountSat)+FfiConverterOptionalString.allocationSize(value.redirectUrl);}}return new FFIConverter();})();/**
 * Response containing a URL to complete the Bitcoin purchase
 *//**
 * Generated factory for {@link BuyBitcoinResponse} record objects.
 */export const BuyBitcoinResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link BuyBitcoinResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link BuyBitcoinResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeBuyBitcoinResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{url:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.url,into);}allocationSize(value){return FfiConverterString.allocationSize(value.url);}}return new FFIConverter();})();/**
 * Generated factory for {@link CheckLightningAddressRequest} record objects.
 */export const CheckLightningAddressRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link CheckLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link CheckLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeCheckLightningAddressRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{username:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.username,into);}allocationSize(value){return FfiConverterString.allocationSize(value.username);}}return new FFIConverter();})();/**
 * Generated factory for {@link CheckMessageRequest} record objects.
 */export const CheckMessageRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link CheckMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link CheckMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeCheckMessageRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{message:FfiConverterString.read(from),pubkey:FfiConverterString.read(from),signature:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.message,into);FfiConverterString.write(value.pubkey,into);FfiConverterString.write(value.signature,into);}allocationSize(value){return FfiConverterString.allocationSize(value.message)+FfiConverterString.allocationSize(value.pubkey)+FfiConverterString.allocationSize(value.signature);}}return new FFIConverter();})();/**
 * Generated factory for {@link CheckMessageResponse} record objects.
 */export const CheckMessageResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link CheckMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link CheckMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeCheckMessageResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{isValid:FfiConverterBool.read(from)};}write(value,into){FfiConverterBool.write(value.isValid,into);}allocationSize(value){return FfiConverterBool.allocationSize(value.isValid);}}return new FFIConverter();})();/**
 * Generated factory for {@link ClaimDepositRequest} record objects.
 */export const ClaimDepositRequest=(()=>{const defaults=()=>({maxFee:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ClaimDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ClaimDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeClaimDepositRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{txid:FfiConverterString.read(from),vout:FfiConverterUInt32.read(from),maxFee:FfiConverterOptionalTypeMaxFee.read(from)};}write(value,into){FfiConverterString.write(value.txid,into);FfiConverterUInt32.write(value.vout,into);FfiConverterOptionalTypeMaxFee.write(value.maxFee,into);}allocationSize(value){return FfiConverterString.allocationSize(value.txid)+FfiConverterUInt32.allocationSize(value.vout)+FfiConverterOptionalTypeMaxFee.allocationSize(value.maxFee);}}return new FFIConverter();})();/**
 * Generated factory for {@link ClaimDepositResponse} record objects.
 */export const ClaimDepositResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ClaimDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ClaimDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeClaimDepositResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{payment:FfiConverterTypePayment.read(from)};}write(value,into){FfiConverterTypePayment.write(value.payment,into);}allocationSize(value){return FfiConverterTypePayment.allocationSize(value.payment);}}return new FFIConverter();})();/**
 * Generated factory for {@link ClaimHtlcPaymentRequest} record objects.
 */export const ClaimHtlcPaymentRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ClaimHtlcPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ClaimHtlcPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeClaimHtlcPaymentRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{preimage:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.preimage,into);}allocationSize(value){return FfiConverterString.allocationSize(value.preimage);}}return new FFIConverter();})();/**
 * Generated factory for {@link ClaimHtlcPaymentResponse} record objects.
 */export const ClaimHtlcPaymentResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ClaimHtlcPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ClaimHtlcPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeClaimHtlcPaymentResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{payment:FfiConverterTypePayment.read(from)};}write(value,into){FfiConverterTypePayment.write(value.payment,into);}allocationSize(value){return FfiConverterTypePayment.allocationSize(value.payment);}}return new FFIConverter();})();/**
 * Generated factory for {@link Config} record objects.
 */export const Config=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeConfig=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{apiKey:FfiConverterOptionalString.read(from),network:FfiConverterTypeNetwork.read(from),syncIntervalSecs:FfiConverterUInt32.read(from),maxDepositClaimFee:FfiConverterOptionalTypeMaxFee.read(from),lnurlDomain:FfiConverterOptionalString.read(from),preferSparkOverLightning:FfiConverterBool.read(from),externalInputParsers:FfiConverterOptionalArrayTypeExternalInputParser.read(from),useDefaultExternalInputParsers:FfiConverterBool.read(from),realTimeSyncServerUrl:FfiConverterOptionalString.read(from),privateEnabledDefault:FfiConverterBool.read(from),optimizationConfig:FfiConverterTypeOptimizationConfig.read(from)};}write(value,into){FfiConverterOptionalString.write(value.apiKey,into);FfiConverterTypeNetwork.write(value.network,into);FfiConverterUInt32.write(value.syncIntervalSecs,into);FfiConverterOptionalTypeMaxFee.write(value.maxDepositClaimFee,into);FfiConverterOptionalString.write(value.lnurlDomain,into);FfiConverterBool.write(value.preferSparkOverLightning,into);FfiConverterOptionalArrayTypeExternalInputParser.write(value.externalInputParsers,into);FfiConverterBool.write(value.useDefaultExternalInputParsers,into);FfiConverterOptionalString.write(value.realTimeSyncServerUrl,into);FfiConverterBool.write(value.privateEnabledDefault,into);FfiConverterTypeOptimizationConfig.write(value.optimizationConfig,into);}allocationSize(value){return FfiConverterOptionalString.allocationSize(value.apiKey)+FfiConverterTypeNetwork.allocationSize(value.network)+FfiConverterUInt32.allocationSize(value.syncIntervalSecs)+FfiConverterOptionalTypeMaxFee.allocationSize(value.maxDepositClaimFee)+FfiConverterOptionalString.allocationSize(value.lnurlDomain)+FfiConverterBool.allocationSize(value.preferSparkOverLightning)+FfiConverterOptionalArrayTypeExternalInputParser.allocationSize(value.externalInputParsers)+FfiConverterBool.allocationSize(value.useDefaultExternalInputParsers)+FfiConverterOptionalString.allocationSize(value.realTimeSyncServerUrl)+FfiConverterBool.allocationSize(value.privateEnabledDefault)+FfiConverterTypeOptimizationConfig.allocationSize(value.optimizationConfig);}}return new FFIConverter();})();/**
 * Generated factory for {@link ConnectRequest} record objects.
 */export const ConnectRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ConnectRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ConnectRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeConnectRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{config:FfiConverterTypeConfig.read(from),seed:FfiConverterTypeSeed.read(from),storageDir:FfiConverterString.read(from)};}write(value,into){FfiConverterTypeConfig.write(value.config,into);FfiConverterTypeSeed.write(value.seed,into);FfiConverterString.write(value.storageDir,into);}allocationSize(value){return FfiConverterTypeConfig.allocationSize(value.config)+FfiConverterTypeSeed.allocationSize(value.seed)+FfiConverterString.allocationSize(value.storageDir);}}return new FFIConverter();})();/**
 * Request object for connecting to the Spark network using an external signer.
 *
 * This allows using a custom signer implementation instead of providing a seed directly.
 *//**
 * Generated factory for {@link ConnectWithSignerRequest} record objects.
 */export const ConnectWithSignerRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ConnectWithSignerRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ConnectWithSignerRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeConnectWithSignerRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{config:FfiConverterTypeConfig.read(from),signer:FfiConverterTypeExternalSigner.read(from),storageDir:FfiConverterString.read(from)};}write(value,into){FfiConverterTypeConfig.write(value.config,into);FfiConverterTypeExternalSigner.write(value.signer,into);FfiConverterString.write(value.storageDir,into);}allocationSize(value){return FfiConverterTypeConfig.allocationSize(value.config)+FfiConverterTypeExternalSigner.allocationSize(value.signer)+FfiConverterString.allocationSize(value.storageDir);}}return new FFIConverter();})();/**
 * Outlines the steps involved in a conversion
 *//**
 * Generated factory for {@link ConversionDetails} record objects.
 */export const ConversionDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ConversionDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ConversionDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeConversionDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{from:FfiConverterTypeConversionStep.read(from),to:FfiConverterTypeConversionStep.read(from)};}write(value,into){FfiConverterTypeConversionStep.write(value.from,into);FfiConverterTypeConversionStep.write(value.to,into);}allocationSize(value){return FfiConverterTypeConversionStep.allocationSize(value.from)+FfiConverterTypeConversionStep.allocationSize(value.to);}}return new FFIConverter();})();/**
 * Response from estimating a conversion, used when preparing a payment that requires conversion
 *//**
 * Generated factory for {@link ConversionEstimate} record objects.
 */export const ConversionEstimate=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ConversionEstimate}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ConversionEstimate}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeConversionEstimate=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{options:FfiConverterTypeConversionOptions.read(from),amount:FfiConverterTypeu128.read(from),fee:FfiConverterTypeu128.read(from)};}write(value,into){FfiConverterTypeConversionOptions.write(value.options,into);FfiConverterTypeu128.write(value.amount,into);FfiConverterTypeu128.write(value.fee,into);}allocationSize(value){return FfiConverterTypeConversionOptions.allocationSize(value.options)+FfiConverterTypeu128.allocationSize(value.amount)+FfiConverterTypeu128.allocationSize(value.fee);}}return new FFIConverter();})();/**
 * Generated factory for {@link ConversionInfo} record objects.
 */export const ConversionInfo=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ConversionInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ConversionInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeConversionInfo=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{poolId:FfiConverterString.read(from),conversionId:FfiConverterString.read(from),status:FfiConverterTypeConversionStatus.read(from),fee:FfiConverterOptionalTypeu128.read(from),purpose:FfiConverterOptionalTypeConversionPurpose.read(from)};}write(value,into){FfiConverterString.write(value.poolId,into);FfiConverterString.write(value.conversionId,into);FfiConverterTypeConversionStatus.write(value.status,into);FfiConverterOptionalTypeu128.write(value.fee,into);FfiConverterOptionalTypeConversionPurpose.write(value.purpose,into);}allocationSize(value){return FfiConverterString.allocationSize(value.poolId)+FfiConverterString.allocationSize(value.conversionId)+FfiConverterTypeConversionStatus.allocationSize(value.status)+FfiConverterOptionalTypeu128.allocationSize(value.fee)+FfiConverterOptionalTypeConversionPurpose.allocationSize(value.purpose);}}return new FFIConverter();})();/**
 * Options for conversion when fulfilling a payment. When set, the SDK will
 * perform a conversion before fulfilling the payment. If not set, the payment
 * will only be fulfilled if the wallet has sufficient balance of the required asset.
 *//**
 * Generated factory for {@link ConversionOptions} record objects.
 */export const ConversionOptions=(()=>{const defaults=()=>({maxSlippageBps:undefined,completionTimeoutSecs:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ConversionOptions}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ConversionOptions}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeConversionOptions=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{conversionType:FfiConverterTypeConversionType.read(from),maxSlippageBps:FfiConverterOptionalUInt32.read(from),completionTimeoutSecs:FfiConverterOptionalUInt32.read(from)};}write(value,into){FfiConverterTypeConversionType.write(value.conversionType,into);FfiConverterOptionalUInt32.write(value.maxSlippageBps,into);FfiConverterOptionalUInt32.write(value.completionTimeoutSecs,into);}allocationSize(value){return FfiConverterTypeConversionType.allocationSize(value.conversionType)+FfiConverterOptionalUInt32.allocationSize(value.maxSlippageBps)+FfiConverterOptionalUInt32.allocationSize(value.completionTimeoutSecs);}}return new FFIConverter();})();/**
 * A single step in a conversion
 *//**
 * Generated factory for {@link ConversionStep} record objects.
 */export const ConversionStep=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ConversionStep}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ConversionStep}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeConversionStep=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentId:FfiConverterString.read(from),amount:FfiConverterTypeu128.read(from),fee:FfiConverterTypeu128.read(from),method:FfiConverterTypePaymentMethod.read(from),tokenMetadata:FfiConverterOptionalTypeTokenMetadata.read(from)};}write(value,into){FfiConverterString.write(value.paymentId,into);FfiConverterTypeu128.write(value.amount,into);FfiConverterTypeu128.write(value.fee,into);FfiConverterTypePaymentMethod.write(value.method,into);FfiConverterOptionalTypeTokenMetadata.write(value.tokenMetadata,into);}allocationSize(value){return FfiConverterString.allocationSize(value.paymentId)+FfiConverterTypeu128.allocationSize(value.amount)+FfiConverterTypeu128.allocationSize(value.fee)+FfiConverterTypePaymentMethod.allocationSize(value.method)+FfiConverterOptionalTypeTokenMetadata.allocationSize(value.tokenMetadata);}}return new FFIConverter();})();/**
 * Generated factory for {@link CreateIssuerTokenRequest} record objects.
 */export const CreateIssuerTokenRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link CreateIssuerTokenRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link CreateIssuerTokenRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeCreateIssuerTokenRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{name:FfiConverterString.read(from),ticker:FfiConverterString.read(from),decimals:FfiConverterUInt32.read(from),isFreezable:FfiConverterBool.read(from),maxSupply:FfiConverterTypeu128.read(from)};}write(value,into){FfiConverterString.write(value.name,into);FfiConverterString.write(value.ticker,into);FfiConverterUInt32.write(value.decimals,into);FfiConverterBool.write(value.isFreezable,into);FfiConverterTypeu128.write(value.maxSupply,into);}allocationSize(value){return FfiConverterString.allocationSize(value.name)+FfiConverterString.allocationSize(value.ticker)+FfiConverterUInt32.allocationSize(value.decimals)+FfiConverterBool.allocationSize(value.isFreezable)+FfiConverterTypeu128.allocationSize(value.maxSupply);}}return new FFIConverter();})();/**
 * Generated factory for {@link Credentials} record objects.
 */export const Credentials=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Credentials}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Credentials}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeCredentials=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{username:FfiConverterString.read(from),password:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.username,into);FfiConverterString.write(value.password,into);}allocationSize(value){return FfiConverterString.allocationSize(value.username)+FfiConverterString.allocationSize(value.password);}}return new FFIConverter();})();/**
 * Details about a supported currency in the fiat rate feed
 *//**
 * Generated factory for {@link CurrencyInfo} record objects.
 */export const CurrencyInfo=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link CurrencyInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link CurrencyInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeCurrencyInfo=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{name:FfiConverterString.read(from),fractionSize:FfiConverterUInt32.read(from),spacing:FfiConverterOptionalUInt32.read(from),symbol:FfiConverterOptionalTypeSymbol.read(from),uniqSymbol:FfiConverterOptionalTypeSymbol.read(from),localizedName:FfiConverterArrayTypeLocalizedName.read(from),localeOverrides:FfiConverterArrayTypeLocaleOverrides.read(from)};}write(value,into){FfiConverterString.write(value.name,into);FfiConverterUInt32.write(value.fractionSize,into);FfiConverterOptionalUInt32.write(value.spacing,into);FfiConverterOptionalTypeSymbol.write(value.symbol,into);FfiConverterOptionalTypeSymbol.write(value.uniqSymbol,into);FfiConverterArrayTypeLocalizedName.write(value.localizedName,into);FfiConverterArrayTypeLocaleOverrides.write(value.localeOverrides,into);}allocationSize(value){return FfiConverterString.allocationSize(value.name)+FfiConverterUInt32.allocationSize(value.fractionSize)+FfiConverterOptionalUInt32.allocationSize(value.spacing)+FfiConverterOptionalTypeSymbol.allocationSize(value.symbol)+FfiConverterOptionalTypeSymbol.allocationSize(value.uniqSymbol)+FfiConverterArrayTypeLocalizedName.allocationSize(value.localizedName)+FfiConverterArrayTypeLocaleOverrides.allocationSize(value.localeOverrides);}}return new FFIConverter();})();/**
 * Generated factory for {@link DepositInfo} record objects.
 */export const DepositInfo=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link DepositInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link DepositInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeDepositInfo=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{txid:FfiConverterString.read(from),vout:FfiConverterUInt32.read(from),amountSats:FfiConverterUInt64.read(from),refundTx:FfiConverterOptionalString.read(from),refundTxId:FfiConverterOptionalString.read(from),claimError:FfiConverterOptionalTypeDepositClaimError.read(from)};}write(value,into){FfiConverterString.write(value.txid,into);FfiConverterUInt32.write(value.vout,into);FfiConverterUInt64.write(value.amountSats,into);FfiConverterOptionalString.write(value.refundTx,into);FfiConverterOptionalString.write(value.refundTxId,into);FfiConverterOptionalTypeDepositClaimError.write(value.claimError,into);}allocationSize(value){return FfiConverterString.allocationSize(value.txid)+FfiConverterUInt32.allocationSize(value.vout)+FfiConverterUInt64.allocationSize(value.amountSats)+FfiConverterOptionalString.allocationSize(value.refundTx)+FfiConverterOptionalString.allocationSize(value.refundTxId)+FfiConverterOptionalTypeDepositClaimError.allocationSize(value.claimError);}}return new FFIConverter();})();/**
 * FFI-safe representation of an ECDSA signature (64 bytes)
 *//**
 * Generated factory for {@link EcdsaSignatureBytes} record objects.
 */export const EcdsaSignatureBytes=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link EcdsaSignatureBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link EcdsaSignatureBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeEcdsaSignatureBytes=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * FFI-safe representation of `spark_wallet::AggregateFrostRequest`
 *//**
 * Generated factory for {@link ExternalAggregateFrostRequest} record objects.
 */export const ExternalAggregateFrostRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalAggregateFrostRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalAggregateFrostRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalAggregateFrostRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{message:FfiConverterArrayBuffer.read(from),statechainSignatures:FfiConverterArrayTypeIdentifierSignaturePair.read(from),statechainPublicKeys:FfiConverterArrayTypeIdentifierPublicKeyPair.read(from),verifyingKey:FfiConverterArrayBuffer.read(from),statechainCommitments:FfiConverterArrayTypeIdentifierCommitmentPair.read(from),selfCommitment:FfiConverterTypeExternalSigningCommitments.read(from),publicKey:FfiConverterArrayBuffer.read(from),selfSignature:FfiConverterTypeExternalFrostSignatureShare.read(from),adaptorPublicKey:FfiConverterOptionalArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.message,into);FfiConverterArrayTypeIdentifierSignaturePair.write(value.statechainSignatures,into);FfiConverterArrayTypeIdentifierPublicKeyPair.write(value.statechainPublicKeys,into);FfiConverterArrayBuffer.write(value.verifyingKey,into);FfiConverterArrayTypeIdentifierCommitmentPair.write(value.statechainCommitments,into);FfiConverterTypeExternalSigningCommitments.write(value.selfCommitment,into);FfiConverterArrayBuffer.write(value.publicKey,into);FfiConverterTypeExternalFrostSignatureShare.write(value.selfSignature,into);FfiConverterOptionalArrayBuffer.write(value.adaptorPublicKey,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.message)+FfiConverterArrayTypeIdentifierSignaturePair.allocationSize(value.statechainSignatures)+FfiConverterArrayTypeIdentifierPublicKeyPair.allocationSize(value.statechainPublicKeys)+FfiConverterArrayBuffer.allocationSize(value.verifyingKey)+FfiConverterArrayTypeIdentifierCommitmentPair.allocationSize(value.statechainCommitments)+FfiConverterTypeExternalSigningCommitments.allocationSize(value.selfCommitment)+FfiConverterArrayBuffer.allocationSize(value.publicKey)+FfiConverterTypeExternalFrostSignatureShare.allocationSize(value.selfSignature)+FfiConverterOptionalArrayBuffer.allocationSize(value.adaptorPublicKey);}}return new FFIConverter();})();/**
 * FFI-safe representation of `spark_wallet::EncryptedSecret`
 *//**
 * Generated factory for {@link ExternalEncryptedSecret} record objects.
 */export const ExternalEncryptedSecret=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalEncryptedSecret}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalEncryptedSecret}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalEncryptedSecret=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{ciphertext:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.ciphertext,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.ciphertext);}}return new FFIConverter();})();/**
 * FFI-safe representation of `spark_wallet::FrostSigningCommitmentsWithNonces`
 *//**
 * Generated factory for {@link ExternalFrostCommitments} record objects.
 */export const ExternalFrostCommitments=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalFrostCommitments}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalFrostCommitments}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalFrostCommitments=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{hidingCommitment:FfiConverterArrayBuffer.read(from),bindingCommitment:FfiConverterArrayBuffer.read(from),noncesCiphertext:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.hidingCommitment,into);FfiConverterArrayBuffer.write(value.bindingCommitment,into);FfiConverterArrayBuffer.write(value.noncesCiphertext,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.hidingCommitment)+FfiConverterArrayBuffer.allocationSize(value.bindingCommitment)+FfiConverterArrayBuffer.allocationSize(value.noncesCiphertext);}}return new FFIConverter();})();/**
 * FFI-safe representation of `frost_secp256k1_tr::Signature`
 *//**
 * Generated factory for {@link ExternalFrostSignature} record objects.
 */export const ExternalFrostSignature=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalFrostSignature}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalFrostSignature}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalFrostSignature=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * FFI-safe representation of `frost_secp256k1_tr::round2::SignatureShare`
 *//**
 * Generated factory for {@link ExternalFrostSignatureShare} record objects.
 */export const ExternalFrostSignatureShare=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalFrostSignatureShare}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalFrostSignatureShare}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalFrostSignatureShare=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * FFI-safe representation of `frost_secp256k1_tr::Identifier`
 *//**
 * Generated factory for {@link ExternalIdentifier} record objects.
 */export const ExternalIdentifier=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalIdentifier}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalIdentifier}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalIdentifier=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * Configuration for an external input parser
 *//**
 * Generated factory for {@link ExternalInputParser} record objects.
 */export const ExternalInputParser=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalInputParser}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalInputParser}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalInputParser=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{providerId:FfiConverterString.read(from),inputRegex:FfiConverterString.read(from),parserUrl:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.providerId,into);FfiConverterString.write(value.inputRegex,into);FfiConverterString.write(value.parserUrl,into);}allocationSize(value){return FfiConverterString.allocationSize(value.providerId)+FfiConverterString.allocationSize(value.inputRegex)+FfiConverterString.allocationSize(value.parserUrl);}}return new FFIConverter();})();/**
 * FFI-safe representation of `k256::Scalar` (32 bytes)
 *//**
 * Generated factory for {@link ExternalScalar} record objects.
 */export const ExternalScalar=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalScalar}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalScalar}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalScalar=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * FFI-safe representation of `spark_wallet::SecretShare`
 *//**
 * Generated factory for {@link ExternalSecretShare} record objects.
 */export const ExternalSecretShare=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalSecretShare}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalSecretShare}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalSecretShare=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{threshold:FfiConverterUInt32.read(from),index:FfiConverterTypeExternalScalar.read(from),share:FfiConverterTypeExternalScalar.read(from)};}write(value,into){FfiConverterUInt32.write(value.threshold,into);FfiConverterTypeExternalScalar.write(value.index,into);FfiConverterTypeExternalScalar.write(value.share,into);}allocationSize(value){return FfiConverterUInt32.allocationSize(value.threshold)+FfiConverterTypeExternalScalar.allocationSize(value.index)+FfiConverterTypeExternalScalar.allocationSize(value.share);}}return new FFIConverter();})();/**
 * FFI-safe representation of `spark_wallet::SignFrostRequest`
 *//**
 * Generated factory for {@link ExternalSignFrostRequest} record objects.
 */export const ExternalSignFrostRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalSignFrostRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalSignFrostRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalSignFrostRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{message:FfiConverterArrayBuffer.read(from),publicKey:FfiConverterArrayBuffer.read(from),secret:FfiConverterTypeExternalSecretSource.read(from),verifyingKey:FfiConverterArrayBuffer.read(from),selfNonceCommitment:FfiConverterTypeExternalFrostCommitments.read(from),statechainCommitments:FfiConverterArrayTypeIdentifierCommitmentPair.read(from),adaptorPublicKey:FfiConverterOptionalArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.message,into);FfiConverterArrayBuffer.write(value.publicKey,into);FfiConverterTypeExternalSecretSource.write(value.secret,into);FfiConverterArrayBuffer.write(value.verifyingKey,into);FfiConverterTypeExternalFrostCommitments.write(value.selfNonceCommitment,into);FfiConverterArrayTypeIdentifierCommitmentPair.write(value.statechainCommitments,into);FfiConverterOptionalArrayBuffer.write(value.adaptorPublicKey,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.message)+FfiConverterArrayBuffer.allocationSize(value.publicKey)+FfiConverterTypeExternalSecretSource.allocationSize(value.secret)+FfiConverterArrayBuffer.allocationSize(value.verifyingKey)+FfiConverterTypeExternalFrostCommitments.allocationSize(value.selfNonceCommitment)+FfiConverterArrayTypeIdentifierCommitmentPair.allocationSize(value.statechainCommitments)+FfiConverterOptionalArrayBuffer.allocationSize(value.adaptorPublicKey);}}return new FFIConverter();})();/**
 * FFI-safe representation of `frost_secp256k1_tr::round1::SigningCommitments`
 *//**
 * Generated factory for {@link ExternalSigningCommitments} record objects.
 */export const ExternalSigningCommitments=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalSigningCommitments}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalSigningCommitments}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalSigningCommitments=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{hiding:FfiConverterArrayBuffer.read(from),binding:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.hiding,into);FfiConverterArrayBuffer.write(value.binding,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.hiding)+FfiConverterArrayBuffer.allocationSize(value.binding);}}return new FFIConverter();})();/**
 * FFI-safe representation of `spark_wallet::TreeNodeId`
 *//**
 * Generated factory for {@link ExternalTreeNodeId} record objects.
 */export const ExternalTreeNodeId=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalTreeNodeId}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalTreeNodeId}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalTreeNodeId=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{id:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.id,into);}allocationSize(value){return FfiConverterString.allocationSize(value.id);}}return new FFIConverter();})();/**
 * FFI-safe representation of `spark_wallet::VerifiableSecretShare`
 *//**
 * Generated factory for {@link ExternalVerifiableSecretShare} record objects.
 */export const ExternalVerifiableSecretShare=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ExternalVerifiableSecretShare}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ExternalVerifiableSecretShare}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeExternalVerifiableSecretShare=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{secretShare:FfiConverterTypeExternalSecretShare.read(from),proofs:FfiConverterArrayArrayBuffer.read(from)};}write(value,into){FfiConverterTypeExternalSecretShare.write(value.secretShare,into);FfiConverterArrayArrayBuffer.write(value.proofs,into);}allocationSize(value){return FfiConverterTypeExternalSecretShare.allocationSize(value.secretShare)+FfiConverterArrayArrayBuffer.allocationSize(value.proofs);}}return new FFIConverter();})();/**
 * Generated factory for {@link FetchConversionLimitsRequest} record objects.
 */export const FetchConversionLimitsRequest=(()=>{const defaults=()=>({tokenIdentifier:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link FetchConversionLimitsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link FetchConversionLimitsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeFetchConversionLimitsRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{conversionType:FfiConverterTypeConversionType.read(from),tokenIdentifier:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterTypeConversionType.write(value.conversionType,into);FfiConverterOptionalString.write(value.tokenIdentifier,into);}allocationSize(value){return FfiConverterTypeConversionType.allocationSize(value.conversionType)+FfiConverterOptionalString.allocationSize(value.tokenIdentifier);}}return new FFIConverter();})();/**
 * Generated factory for {@link FetchConversionLimitsResponse} record objects.
 */export const FetchConversionLimitsResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link FetchConversionLimitsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link FetchConversionLimitsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeFetchConversionLimitsResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{minFromAmount:FfiConverterOptionalTypeu128.read(from),minToAmount:FfiConverterOptionalTypeu128.read(from)};}write(value,into){FfiConverterOptionalTypeu128.write(value.minFromAmount,into);FfiConverterOptionalTypeu128.write(value.minToAmount,into);}allocationSize(value){return FfiConverterOptionalTypeu128.allocationSize(value.minFromAmount)+FfiConverterOptionalTypeu128.allocationSize(value.minToAmount);}}return new FFIConverter();})();/**
 * Wrapper around the [`CurrencyInfo`] of a fiat currency
 *//**
 * Generated factory for {@link FiatCurrency} record objects.
 */export const FiatCurrency=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link FiatCurrency}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link FiatCurrency}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeFiatCurrency=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{id:FfiConverterString.read(from),info:FfiConverterTypeCurrencyInfo.read(from)};}write(value,into){FfiConverterString.write(value.id,into);FfiConverterTypeCurrencyInfo.write(value.info,into);}allocationSize(value){return FfiConverterString.allocationSize(value.id)+FfiConverterTypeCurrencyInfo.allocationSize(value.info);}}return new FFIConverter();})();/**
 * Generated factory for {@link FreezeIssuerTokenRequest} record objects.
 */export const FreezeIssuerTokenRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link FreezeIssuerTokenRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link FreezeIssuerTokenRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeFreezeIssuerTokenRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{address:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.address,into);}allocationSize(value){return FfiConverterString.allocationSize(value.address);}}return new FFIConverter();})();/**
 * Generated factory for {@link FreezeIssuerTokenResponse} record objects.
 */export const FreezeIssuerTokenResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link FreezeIssuerTokenResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link FreezeIssuerTokenResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeFreezeIssuerTokenResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{impactedOutputIds:FfiConverterArrayString.read(from),impactedTokenAmount:FfiConverterTypeu128.read(from)};}write(value,into){FfiConverterArrayString.write(value.impactedOutputIds,into);FfiConverterTypeu128.write(value.impactedTokenAmount,into);}allocationSize(value){return FfiConverterArrayString.allocationSize(value.impactedOutputIds)+FfiConverterTypeu128.allocationSize(value.impactedTokenAmount);}}return new FFIConverter();})();/**
 * Request to get the balance of the wallet
 *//**
 * Generated factory for {@link GetInfoRequest} record objects.
 */export const GetInfoRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link GetInfoRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link GetInfoRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeGetInfoRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{ensureSynced:FfiConverterOptionalBool.read(from)};}write(value,into){FfiConverterOptionalBool.write(value.ensureSynced,into);}allocationSize(value){return FfiConverterOptionalBool.allocationSize(value.ensureSynced);}}return new FFIConverter();})();/**
 * Response containing the balance of the wallet
 *//**
 * Generated factory for {@link GetInfoResponse} record objects.
 */export const GetInfoResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeGetInfoResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{identityPubkey:FfiConverterString.read(from),balanceSats:FfiConverterUInt64.read(from),tokenBalances:FfiConverterMapStringTypeTokenBalance.read(from)};}write(value,into){FfiConverterString.write(value.identityPubkey,into);FfiConverterUInt64.write(value.balanceSats,into);FfiConverterMapStringTypeTokenBalance.write(value.tokenBalances,into);}allocationSize(value){return FfiConverterString.allocationSize(value.identityPubkey)+FfiConverterUInt64.allocationSize(value.balanceSats)+FfiConverterMapStringTypeTokenBalance.allocationSize(value.tokenBalances);}}return new FFIConverter();})();/**
 * Generated factory for {@link GetPaymentRequest} record objects.
 */export const GetPaymentRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link GetPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link GetPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeGetPaymentRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentId:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.paymentId,into);}allocationSize(value){return FfiConverterString.allocationSize(value.paymentId);}}return new FFIConverter();})();/**
 * Generated factory for {@link GetPaymentResponse} record objects.
 */export const GetPaymentResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link GetPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link GetPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeGetPaymentResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{payment:FfiConverterTypePayment.read(from)};}write(value,into){FfiConverterTypePayment.write(value.payment,into);}allocationSize(value){return FfiConverterTypePayment.allocationSize(value.payment);}}return new FFIConverter();})();/**
 * Generated factory for {@link GetTokensMetadataRequest} record objects.
 */export const GetTokensMetadataRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link GetTokensMetadataRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link GetTokensMetadataRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeGetTokensMetadataRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{tokenIdentifiers:FfiConverterArrayString.read(from)};}write(value,into){FfiConverterArrayString.write(value.tokenIdentifiers,into);}allocationSize(value){return FfiConverterArrayString.allocationSize(value.tokenIdentifiers);}}return new FFIConverter();})();/**
 * Generated factory for {@link GetTokensMetadataResponse} record objects.
 */export const GetTokensMetadataResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link GetTokensMetadataResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link GetTokensMetadataResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeGetTokensMetadataResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{tokensMetadata:FfiConverterArrayTypeTokenMetadata.read(from)};}write(value,into){FfiConverterArrayTypeTokenMetadata.write(value.tokensMetadata,into);}allocationSize(value){return FfiConverterArrayTypeTokenMetadata.allocationSize(value.tokensMetadata);}}return new FFIConverter();})();/**
 * Generated factory for {@link HashedMessageBytes} record objects.
 */export const HashedMessageBytes=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link HashedMessageBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link HashedMessageBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeHashedMessageBytes=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * FFI-safe wrapper for (Identifier, `SigningCommitments`) pair
 *//**
 * Generated factory for {@link IdentifierCommitmentPair} record objects.
 */export const IdentifierCommitmentPair=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link IdentifierCommitmentPair}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link IdentifierCommitmentPair}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeIdentifierCommitmentPair=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{identifier:FfiConverterTypeExternalIdentifier.read(from),commitment:FfiConverterTypeExternalSigningCommitments.read(from)};}write(value,into){FfiConverterTypeExternalIdentifier.write(value.identifier,into);FfiConverterTypeExternalSigningCommitments.write(value.commitment,into);}allocationSize(value){return FfiConverterTypeExternalIdentifier.allocationSize(value.identifier)+FfiConverterTypeExternalSigningCommitments.allocationSize(value.commitment);}}return new FFIConverter();})();/**
 * FFI-safe wrapper for (Identifier, `PublicKey`) pair
 *//**
 * Generated factory for {@link IdentifierPublicKeyPair} record objects.
 */export const IdentifierPublicKeyPair=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link IdentifierPublicKeyPair}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link IdentifierPublicKeyPair}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeIdentifierPublicKeyPair=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{identifier:FfiConverterTypeExternalIdentifier.read(from),publicKey:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterTypeExternalIdentifier.write(value.identifier,into);FfiConverterArrayBuffer.write(value.publicKey,into);}allocationSize(value){return FfiConverterTypeExternalIdentifier.allocationSize(value.identifier)+FfiConverterArrayBuffer.allocationSize(value.publicKey);}}return new FFIConverter();})();/**
 * FFI-safe wrapper for (Identifier, `SignatureShare`) pair
 *//**
 * Generated factory for {@link IdentifierSignaturePair} record objects.
 */export const IdentifierSignaturePair=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link IdentifierSignaturePair}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link IdentifierSignaturePair}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeIdentifierSignaturePair=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{identifier:FfiConverterTypeExternalIdentifier.read(from),signature:FfiConverterTypeExternalFrostSignatureShare.read(from)};}write(value,into){FfiConverterTypeExternalIdentifier.write(value.identifier,into);FfiConverterTypeExternalFrostSignatureShare.write(value.signature,into);}allocationSize(value){return FfiConverterTypeExternalIdentifier.allocationSize(value.identifier)+FfiConverterTypeExternalFrostSignatureShare.allocationSize(value.signature);}}return new FFIConverter();})();/**
 * Generated factory for {@link IncomingChange} record objects.
 */export const IncomingChange=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link IncomingChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link IncomingChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeIncomingChange=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{newState:FfiConverterTypeRecord.read(from),oldState:FfiConverterOptionalTypeRecord.read(from)};}write(value,into){FfiConverterTypeRecord.write(value.newState,into);FfiConverterOptionalTypeRecord.write(value.oldState,into);}allocationSize(value){return FfiConverterTypeRecord.allocationSize(value.newState)+FfiConverterOptionalTypeRecord.allocationSize(value.oldState);}}return new FFIConverter();})();/**
 * Configuration for key set derivation.
 *
 * This struct encapsulates the parameters needed for BIP32 key derivation.
 *//**
 * Generated factory for {@link KeySetConfig} record objects.
 */export const KeySetConfig=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link KeySetConfig}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link KeySetConfig}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeKeySetConfig=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{keySetType:FfiConverterTypeKeySetType.read(from),useAddressIndex:FfiConverterBool.read(from),accountNumber:FfiConverterOptionalUInt32.read(from)};}write(value,into){FfiConverterTypeKeySetType.write(value.keySetType,into);FfiConverterBool.write(value.useAddressIndex,into);FfiConverterOptionalUInt32.write(value.accountNumber,into);}allocationSize(value){return FfiConverterTypeKeySetType.allocationSize(value.keySetType)+FfiConverterBool.allocationSize(value.useAddressIndex)+FfiConverterOptionalUInt32.allocationSize(value.accountNumber);}}return new FFIConverter();})();/**
 * Generated factory for {@link LightningAddressDetails} record objects.
 */export const LightningAddressDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LightningAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LightningAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLightningAddressDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{address:FfiConverterString.read(from),payRequest:FfiConverterTypeLnurlPayRequestDetails.read(from)};}write(value,into){FfiConverterString.write(value.address,into);FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest,into);}allocationSize(value){return FfiConverterString.allocationSize(value.address)+FfiConverterTypeLnurlPayRequestDetails.allocationSize(value.payRequest);}}return new FFIConverter();})();/**
 * Generated factory for {@link LightningAddressInfo} record objects.
 */export const LightningAddressInfo=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LightningAddressInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LightningAddressInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLightningAddressInfo=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{description:FfiConverterString.read(from),lightningAddress:FfiConverterString.read(from),lnurl:FfiConverterTypeLnurlInfo.read(from),username:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.description,into);FfiConverterString.write(value.lightningAddress,into);FfiConverterTypeLnurlInfo.write(value.lnurl,into);FfiConverterString.write(value.username,into);}allocationSize(value){return FfiConverterString.allocationSize(value.description)+FfiConverterString.allocationSize(value.lightningAddress)+FfiConverterTypeLnurlInfo.allocationSize(value.lnurl)+FfiConverterString.allocationSize(value.username);}}return new FFIConverter();})();/**
 * Response from listing fiat currencies
 *//**
 * Generated factory for {@link ListFiatCurrenciesResponse} record objects.
 */export const ListFiatCurrenciesResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ListFiatCurrenciesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ListFiatCurrenciesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeListFiatCurrenciesResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{currencies:FfiConverterArrayTypeFiatCurrency.read(from)};}write(value,into){FfiConverterArrayTypeFiatCurrency.write(value.currencies,into);}allocationSize(value){return FfiConverterArrayTypeFiatCurrency.allocationSize(value.currencies);}}return new FFIConverter();})();/**
 * Response from listing fiat rates
 *//**
 * Generated factory for {@link ListFiatRatesResponse} record objects.
 */export const ListFiatRatesResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ListFiatRatesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ListFiatRatesResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeListFiatRatesResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{rates:FfiConverterArrayTypeRate.read(from)};}write(value,into){FfiConverterArrayTypeRate.write(value.rates,into);}allocationSize(value){return FfiConverterArrayTypeRate.allocationSize(value.rates);}}return new FFIConverter();})();/**
 * Request to list payments with optional filters and pagination
 *//**
 * Generated factory for {@link ListPaymentsRequest} record objects.
 */export const ListPaymentsRequest=(()=>{const defaults=()=>({typeFilter:undefined,statusFilter:undefined,assetFilter:undefined,paymentDetailsFilter:undefined,fromTimestamp:undefined,toTimestamp:undefined,offset:undefined,limit:undefined,sortAscending:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ListPaymentsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ListPaymentsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeListPaymentsRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{typeFilter:FfiConverterOptionalArrayTypePaymentType.read(from),statusFilter:FfiConverterOptionalArrayTypePaymentStatus.read(from),assetFilter:FfiConverterOptionalTypeAssetFilter.read(from),paymentDetailsFilter:FfiConverterOptionalArrayTypePaymentDetailsFilter.read(from),fromTimestamp:FfiConverterOptionalUInt64.read(from),toTimestamp:FfiConverterOptionalUInt64.read(from),offset:FfiConverterOptionalUInt32.read(from),limit:FfiConverterOptionalUInt32.read(from),sortAscending:FfiConverterOptionalBool.read(from)};}write(value,into){FfiConverterOptionalArrayTypePaymentType.write(value.typeFilter,into);FfiConverterOptionalArrayTypePaymentStatus.write(value.statusFilter,into);FfiConverterOptionalTypeAssetFilter.write(value.assetFilter,into);FfiConverterOptionalArrayTypePaymentDetailsFilter.write(value.paymentDetailsFilter,into);FfiConverterOptionalUInt64.write(value.fromTimestamp,into);FfiConverterOptionalUInt64.write(value.toTimestamp,into);FfiConverterOptionalUInt32.write(value.offset,into);FfiConverterOptionalUInt32.write(value.limit,into);FfiConverterOptionalBool.write(value.sortAscending,into);}allocationSize(value){return FfiConverterOptionalArrayTypePaymentType.allocationSize(value.typeFilter)+FfiConverterOptionalArrayTypePaymentStatus.allocationSize(value.statusFilter)+FfiConverterOptionalTypeAssetFilter.allocationSize(value.assetFilter)+FfiConverterOptionalArrayTypePaymentDetailsFilter.allocationSize(value.paymentDetailsFilter)+FfiConverterOptionalUInt64.allocationSize(value.fromTimestamp)+FfiConverterOptionalUInt64.allocationSize(value.toTimestamp)+FfiConverterOptionalUInt32.allocationSize(value.offset)+FfiConverterOptionalUInt32.allocationSize(value.limit)+FfiConverterOptionalBool.allocationSize(value.sortAscending);}}return new FFIConverter();})();/**
 * Response from listing payments
 *//**
 * Generated factory for {@link ListPaymentsResponse} record objects.
 */export const ListPaymentsResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ListPaymentsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ListPaymentsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeListPaymentsResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{payments:FfiConverterArrayTypePayment.read(from)};}write(value,into){FfiConverterArrayTypePayment.write(value.payments,into);}allocationSize(value){return FfiConverterArrayTypePayment.allocationSize(value.payments);}}return new FFIConverter();})();/**
 * Generated factory for {@link ListUnclaimedDepositsRequest} record objects.
 */export const ListUnclaimedDepositsRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ListUnclaimedDepositsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ListUnclaimedDepositsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeListUnclaimedDepositsRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{};}write(value,into){}allocationSize(value){return 0;}}return new FFIConverter();})();/**
 * Generated factory for {@link ListUnclaimedDepositsResponse} record objects.
 */export const ListUnclaimedDepositsResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ListUnclaimedDepositsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ListUnclaimedDepositsResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeListUnclaimedDepositsResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{deposits:FfiConverterArrayTypeDepositInfo.read(from)};}write(value,into){FfiConverterArrayTypeDepositInfo.write(value.deposits,into);}allocationSize(value){return FfiConverterArrayTypeDepositInfo.allocationSize(value.deposits);}}return new FFIConverter();})();/**
 * Wrapped in a [`InputType::LnurlAuth`], this is the result of [`parse`](breez_sdk_common::input::parse) when given a LNURL-auth endpoint.
 *
 * It represents the endpoint's parameters for the LNURL workflow.
 *
 * See <https://github.com/lnurl/luds/blob/luds/04.md>
 *//**
 * Generated factory for {@link LnurlAuthRequestDetails} record objects.
 */export const LnurlAuthRequestDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlAuthRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlAuthRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlAuthRequestDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{k1:FfiConverterString.read(from),action:FfiConverterOptionalString.read(from),domain:FfiConverterString.read(from),url:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.k1,into);FfiConverterOptionalString.write(value.action,into);FfiConverterString.write(value.domain,into);FfiConverterString.write(value.url,into);}allocationSize(value){return FfiConverterString.allocationSize(value.k1)+FfiConverterOptionalString.allocationSize(value.action)+FfiConverterString.allocationSize(value.domain)+FfiConverterString.allocationSize(value.url);}}return new FFIConverter();})();/**
 * LNURL error details
 *//**
 * Generated factory for {@link LnurlErrorDetails} record objects.
 */export const LnurlErrorDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlErrorDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlErrorDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlErrorDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{reason:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.reason,into);}allocationSize(value){return FfiConverterString.allocationSize(value.reason);}}return new FFIConverter();})();/**
 * Generated factory for {@link LnurlInfo} record objects.
 */export const LnurlInfo=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlInfo=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{url:FfiConverterString.read(from),bech32:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.url,into);FfiConverterString.write(value.bech32,into);}allocationSize(value){return FfiConverterString.allocationSize(value.url)+FfiConverterString.allocationSize(value.bech32);}}return new FFIConverter();})();/**
 * Represents the payment LNURL info
 *//**
 * Generated factory for {@link LnurlPayInfo} record objects.
 */export const LnurlPayInfo=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlPayInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlPayInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlPayInfo=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{lnAddress:FfiConverterOptionalString.read(from),comment:FfiConverterOptionalString.read(from),domain:FfiConverterOptionalString.read(from),metadata:FfiConverterOptionalString.read(from),processedSuccessAction:FfiConverterOptionalTypeSuccessActionProcessed.read(from),rawSuccessAction:FfiConverterOptionalTypeSuccessAction.read(from)};}write(value,into){FfiConverterOptionalString.write(value.lnAddress,into);FfiConverterOptionalString.write(value.comment,into);FfiConverterOptionalString.write(value.domain,into);FfiConverterOptionalString.write(value.metadata,into);FfiConverterOptionalTypeSuccessActionProcessed.write(value.processedSuccessAction,into);FfiConverterOptionalTypeSuccessAction.write(value.rawSuccessAction,into);}allocationSize(value){return FfiConverterOptionalString.allocationSize(value.lnAddress)+FfiConverterOptionalString.allocationSize(value.comment)+FfiConverterOptionalString.allocationSize(value.domain)+FfiConverterOptionalString.allocationSize(value.metadata)+FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(value.processedSuccessAction)+FfiConverterOptionalTypeSuccessAction.allocationSize(value.rawSuccessAction);}}return new FFIConverter();})();/**
 * Generated factory for {@link LnurlPayRequest} record objects.
 */export const LnurlPayRequest=(()=>{const defaults=()=>({idempotencyKey:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlPayRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{prepareResponse:FfiConverterTypePrepareLnurlPayResponse.read(from),idempotencyKey:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterTypePrepareLnurlPayResponse.write(value.prepareResponse,into);FfiConverterOptionalString.write(value.idempotencyKey,into);}allocationSize(value){return FfiConverterTypePrepareLnurlPayResponse.allocationSize(value.prepareResponse)+FfiConverterOptionalString.allocationSize(value.idempotencyKey);}}return new FFIConverter();})();/**
 * Generated factory for {@link LnurlPayRequestDetails} record objects.
 */export const LnurlPayRequestDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlPayRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlPayRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlPayRequestDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{callback:FfiConverterString.read(from),minSendable:FfiConverterUInt64.read(from),maxSendable:FfiConverterUInt64.read(from),metadataStr:FfiConverterString.read(from),commentAllowed:FfiConverterUInt16.read(from),domain:FfiConverterString.read(from),url:FfiConverterString.read(from),address:FfiConverterOptionalString.read(from),allowsNostr:FfiConverterOptionalBool.read(from),nostrPubkey:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterString.write(value.callback,into);FfiConverterUInt64.write(value.minSendable,into);FfiConverterUInt64.write(value.maxSendable,into);FfiConverterString.write(value.metadataStr,into);FfiConverterUInt16.write(value.commentAllowed,into);FfiConverterString.write(value.domain,into);FfiConverterString.write(value.url,into);FfiConverterOptionalString.write(value.address,into);FfiConverterOptionalBool.write(value.allowsNostr,into);FfiConverterOptionalString.write(value.nostrPubkey,into);}allocationSize(value){return FfiConverterString.allocationSize(value.callback)+FfiConverterUInt64.allocationSize(value.minSendable)+FfiConverterUInt64.allocationSize(value.maxSendable)+FfiConverterString.allocationSize(value.metadataStr)+FfiConverterUInt16.allocationSize(value.commentAllowed)+FfiConverterString.allocationSize(value.domain)+FfiConverterString.allocationSize(value.url)+FfiConverterOptionalString.allocationSize(value.address)+FfiConverterOptionalBool.allocationSize(value.allowsNostr)+FfiConverterOptionalString.allocationSize(value.nostrPubkey);}}return new FFIConverter();})();/**
 * Generated factory for {@link LnurlPayResponse} record objects.
 */export const LnurlPayResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlPayResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{payment:FfiConverterTypePayment.read(from),successAction:FfiConverterOptionalTypeSuccessActionProcessed.read(from)};}write(value,into){FfiConverterTypePayment.write(value.payment,into);FfiConverterOptionalTypeSuccessActionProcessed.write(value.successAction,into);}allocationSize(value){return FfiConverterTypePayment.allocationSize(value.payment)+FfiConverterOptionalTypeSuccessActionProcessed.allocationSize(value.successAction);}}return new FFIConverter();})();/**
 * Generated factory for {@link LnurlReceiveMetadata} record objects.
 */export const LnurlReceiveMetadata=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlReceiveMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlReceiveMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlReceiveMetadata=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{nostrZapRequest:FfiConverterOptionalString.read(from),nostrZapReceipt:FfiConverterOptionalString.read(from),senderComment:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterOptionalString.write(value.nostrZapRequest,into);FfiConverterOptionalString.write(value.nostrZapReceipt,into);FfiConverterOptionalString.write(value.senderComment,into);}allocationSize(value){return FfiConverterOptionalString.allocationSize(value.nostrZapRequest)+FfiConverterOptionalString.allocationSize(value.nostrZapReceipt)+FfiConverterOptionalString.allocationSize(value.senderComment);}}return new FFIConverter();})();/**
 * Represents the withdraw LNURL info
 *//**
 * Generated factory for {@link LnurlWithdrawInfo} record objects.
 */export const LnurlWithdrawInfo=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlWithdrawInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlWithdrawInfo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlWithdrawInfo=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{withdrawUrl:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.withdrawUrl,into);}allocationSize(value){return FfiConverterString.allocationSize(value.withdrawUrl);}}return new FFIConverter();})();/**
 * Generated factory for {@link LnurlWithdrawRequest} record objects.
 */export const LnurlWithdrawRequest=(()=>{const defaults=()=>({completionTimeoutSecs:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlWithdrawRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlWithdrawRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlWithdrawRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{amountSats:FfiConverterUInt64.read(from),withdrawRequest:FfiConverterTypeLnurlWithdrawRequestDetails.read(from),completionTimeoutSecs:FfiConverterOptionalUInt32.read(from)};}write(value,into){FfiConverterUInt64.write(value.amountSats,into);FfiConverterTypeLnurlWithdrawRequestDetails.write(value.withdrawRequest,into);FfiConverterOptionalUInt32.write(value.completionTimeoutSecs,into);}allocationSize(value){return FfiConverterUInt64.allocationSize(value.amountSats)+FfiConverterTypeLnurlWithdrawRequestDetails.allocationSize(value.withdrawRequest)+FfiConverterOptionalUInt32.allocationSize(value.completionTimeoutSecs);}}return new FFIConverter();})();/**
 * Generated factory for {@link LnurlWithdrawRequestDetails} record objects.
 */export const LnurlWithdrawRequestDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlWithdrawRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlWithdrawRequestDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlWithdrawRequestDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{callback:FfiConverterString.read(from),k1:FfiConverterString.read(from),defaultDescription:FfiConverterString.read(from),minWithdrawable:FfiConverterUInt64.read(from),maxWithdrawable:FfiConverterUInt64.read(from)};}write(value,into){FfiConverterString.write(value.callback,into);FfiConverterString.write(value.k1,into);FfiConverterString.write(value.defaultDescription,into);FfiConverterUInt64.write(value.minWithdrawable,into);FfiConverterUInt64.write(value.maxWithdrawable,into);}allocationSize(value){return FfiConverterString.allocationSize(value.callback)+FfiConverterString.allocationSize(value.k1)+FfiConverterString.allocationSize(value.defaultDescription)+FfiConverterUInt64.allocationSize(value.minWithdrawable)+FfiConverterUInt64.allocationSize(value.maxWithdrawable);}}return new FFIConverter();})();/**
 * Generated factory for {@link LnurlWithdrawResponse} record objects.
 */export const LnurlWithdrawResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LnurlWithdrawResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LnurlWithdrawResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLnurlWithdrawResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentRequest:FfiConverterString.read(from),payment:FfiConverterOptionalTypePayment.read(from)};}write(value,into){FfiConverterString.write(value.paymentRequest,into);FfiConverterOptionalTypePayment.write(value.payment,into);}allocationSize(value){return FfiConverterString.allocationSize(value.paymentRequest)+FfiConverterOptionalTypePayment.allocationSize(value.payment);}}return new FFIConverter();})();/**
 * Locale-specific settings for the representation of a currency
 *//**
 * Generated factory for {@link LocaleOverrides} record objects.
 */export const LocaleOverrides=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LocaleOverrides}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LocaleOverrides}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLocaleOverrides=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{locale:FfiConverterString.read(from),spacing:FfiConverterOptionalUInt32.read(from),symbol:FfiConverterTypeSymbol.read(from)};}write(value,into){FfiConverterString.write(value.locale,into);FfiConverterOptionalUInt32.write(value.spacing,into);FfiConverterTypeSymbol.write(value.symbol,into);}allocationSize(value){return FfiConverterString.allocationSize(value.locale)+FfiConverterOptionalUInt32.allocationSize(value.spacing)+FfiConverterTypeSymbol.allocationSize(value.symbol);}}return new FFIConverter();})();/**
 * Localized name of a currency
 *//**
 * Generated factory for {@link LocalizedName} record objects.
 */export const LocalizedName=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LocalizedName}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LocalizedName}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLocalizedName=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{locale:FfiConverterString.read(from),name:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.locale,into);FfiConverterString.write(value.name,into);}allocationSize(value){return FfiConverterString.allocationSize(value.locale)+FfiConverterString.allocationSize(value.name);}}return new FFIConverter();})();/**
 * Generated factory for {@link LogEntry} record objects.
 */export const LogEntry=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link LogEntry}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link LogEntry}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeLogEntry=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{line:FfiConverterString.read(from),level:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.line,into);FfiConverterString.write(value.level,into);}allocationSize(value){return FfiConverterString.allocationSize(value.line)+FfiConverterString.allocationSize(value.level);}}return new FFIConverter();})();/**
 * FFI-safe representation of a 32-byte message digest for ECDSA signing
 *//**
 * Generated factory for {@link MessageBytes} record objects.
 */export const MessageBytes=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link MessageBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link MessageBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeMessageBytes=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * Generated factory for {@link MessageSuccessActionData} record objects.
 */export const MessageSuccessActionData=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link MessageSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link MessageSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeMessageSuccessActionData=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{message:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.message,into);}allocationSize(value){return FfiConverterString.allocationSize(value.message);}}return new FFIConverter();})();/**
 * Generated factory for {@link MintIssuerTokenRequest} record objects.
 */export const MintIssuerTokenRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link MintIssuerTokenRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link MintIssuerTokenRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeMintIssuerTokenRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{amount:FfiConverterTypeu128.read(from)};}write(value,into){FfiConverterTypeu128.write(value.amount,into);}allocationSize(value){return FfiConverterTypeu128.allocationSize(value.amount);}}return new FFIConverter();})();/**
 * Generated factory for {@link OptimizationConfig} record objects.
 */export const OptimizationConfig=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link OptimizationConfig}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link OptimizationConfig}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeOptimizationConfig=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{autoEnabled:FfiConverterBool.read(from),multiplicity:FfiConverterUInt8.read(from)};}write(value,into){FfiConverterBool.write(value.autoEnabled,into);FfiConverterUInt8.write(value.multiplicity,into);}allocationSize(value){return FfiConverterBool.allocationSize(value.autoEnabled)+FfiConverterUInt8.allocationSize(value.multiplicity);}}return new FFIConverter();})();/**
 * Generated factory for {@link OptimizationProgress} record objects.
 */export const OptimizationProgress=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link OptimizationProgress}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link OptimizationProgress}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeOptimizationProgress=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{isRunning:FfiConverterBool.read(from),currentRound:FfiConverterUInt32.read(from),totalRounds:FfiConverterUInt32.read(from)};}write(value,into){FfiConverterBool.write(value.isRunning,into);FfiConverterUInt32.write(value.currentRound,into);FfiConverterUInt32.write(value.totalRounds,into);}allocationSize(value){return FfiConverterBool.allocationSize(value.isRunning)+FfiConverterUInt32.allocationSize(value.currentRound)+FfiConverterUInt32.allocationSize(value.totalRounds);}}return new FFIConverter();})();/**
 * Generated factory for {@link OutgoingChange} record objects.
 */export const OutgoingChange=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link OutgoingChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link OutgoingChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeOutgoingChange=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{change:FfiConverterTypeRecordChange.read(from),parent:FfiConverterOptionalTypeRecord.read(from)};}write(value,into){FfiConverterTypeRecordChange.write(value.change,into);FfiConverterOptionalTypeRecord.write(value.parent,into);}allocationSize(value){return FfiConverterTypeRecordChange.allocationSize(value.change)+FfiConverterOptionalTypeRecord.allocationSize(value.parent);}}return new FFIConverter();})();/**
 * Represents a payment (sent or received)
 *//**
 * Generated factory for {@link Payment} record objects.
 */export const Payment=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Payment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Payment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypePayment=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{id:FfiConverterString.read(from),paymentType:FfiConverterTypePaymentType.read(from),status:FfiConverterTypePaymentStatus.read(from),amount:FfiConverterTypeu128.read(from),fees:FfiConverterTypeu128.read(from),timestamp:FfiConverterUInt64.read(from),method:FfiConverterTypePaymentMethod.read(from),details:FfiConverterOptionalTypePaymentDetails.read(from),conversionDetails:FfiConverterOptionalTypeConversionDetails.read(from)};}write(value,into){FfiConverterString.write(value.id,into);FfiConverterTypePaymentType.write(value.paymentType,into);FfiConverterTypePaymentStatus.write(value.status,into);FfiConverterTypeu128.write(value.amount,into);FfiConverterTypeu128.write(value.fees,into);FfiConverterUInt64.write(value.timestamp,into);FfiConverterTypePaymentMethod.write(value.method,into);FfiConverterOptionalTypePaymentDetails.write(value.details,into);FfiConverterOptionalTypeConversionDetails.write(value.conversionDetails,into);}allocationSize(value){return FfiConverterString.allocationSize(value.id)+FfiConverterTypePaymentType.allocationSize(value.paymentType)+FfiConverterTypePaymentStatus.allocationSize(value.status)+FfiConverterTypeu128.allocationSize(value.amount)+FfiConverterTypeu128.allocationSize(value.fees)+FfiConverterUInt64.allocationSize(value.timestamp)+FfiConverterTypePaymentMethod.allocationSize(value.method)+FfiConverterOptionalTypePaymentDetails.allocationSize(value.details)+FfiConverterOptionalTypeConversionDetails.allocationSize(value.conversionDetails);}}return new FFIConverter();})();/**
 * Metadata associated with a payment that cannot be extracted from the Spark operator.
 *//**
 * Generated factory for {@link PaymentMetadata} record objects.
 */export const PaymentMetadata=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link PaymentMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link PaymentMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypePaymentMetadata=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{parentPaymentId:FfiConverterOptionalString.read(from),lnurlPayInfo:FfiConverterOptionalTypeLnurlPayInfo.read(from),lnurlWithdrawInfo:FfiConverterOptionalTypeLnurlWithdrawInfo.read(from),lnurlDescription:FfiConverterOptionalString.read(from),conversionInfo:FfiConverterOptionalTypeConversionInfo.read(from)};}write(value,into){FfiConverterOptionalString.write(value.parentPaymentId,into);FfiConverterOptionalTypeLnurlPayInfo.write(value.lnurlPayInfo,into);FfiConverterOptionalTypeLnurlWithdrawInfo.write(value.lnurlWithdrawInfo,into);FfiConverterOptionalString.write(value.lnurlDescription,into);FfiConverterOptionalTypeConversionInfo.write(value.conversionInfo,into);}allocationSize(value){return FfiConverterOptionalString.allocationSize(value.parentPaymentId)+FfiConverterOptionalTypeLnurlPayInfo.allocationSize(value.lnurlPayInfo)+FfiConverterOptionalTypeLnurlWithdrawInfo.allocationSize(value.lnurlWithdrawInfo)+FfiConverterOptionalString.allocationSize(value.lnurlDescription)+FfiConverterOptionalTypeConversionInfo.allocationSize(value.conversionInfo);}}return new FFIConverter();})();/**
 * Generated factory for {@link PaymentRequestSource} record objects.
 */export const PaymentRequestSource=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link PaymentRequestSource}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link PaymentRequestSource}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypePaymentRequestSource=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bip21Uri:FfiConverterOptionalString.read(from),bip353Address:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterOptionalString.write(value.bip21Uri,into);FfiConverterOptionalString.write(value.bip353Address,into);}allocationSize(value){return FfiConverterOptionalString.allocationSize(value.bip21Uri)+FfiConverterOptionalString.allocationSize(value.bip353Address);}}return new FFIConverter();})();/**
 * Generated factory for {@link PrepareLnurlPayRequest} record objects.
 */export const PrepareLnurlPayRequest=(()=>{const defaults=()=>({comment:undefined,validateSuccessActionUrl:undefined,conversionOptions:undefined,feePolicy:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link PrepareLnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link PrepareLnurlPayRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypePrepareLnurlPayRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{amountSats:FfiConverterUInt64.read(from),payRequest:FfiConverterTypeLnurlPayRequestDetails.read(from),comment:FfiConverterOptionalString.read(from),validateSuccessActionUrl:FfiConverterOptionalBool.read(from),conversionOptions:FfiConverterOptionalTypeConversionOptions.read(from),feePolicy:FfiConverterOptionalTypeFeePolicy.read(from)};}write(value,into){FfiConverterUInt64.write(value.amountSats,into);FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest,into);FfiConverterOptionalString.write(value.comment,into);FfiConverterOptionalBool.write(value.validateSuccessActionUrl,into);FfiConverterOptionalTypeConversionOptions.write(value.conversionOptions,into);FfiConverterOptionalTypeFeePolicy.write(value.feePolicy,into);}allocationSize(value){return FfiConverterUInt64.allocationSize(value.amountSats)+FfiConverterTypeLnurlPayRequestDetails.allocationSize(value.payRequest)+FfiConverterOptionalString.allocationSize(value.comment)+FfiConverterOptionalBool.allocationSize(value.validateSuccessActionUrl)+FfiConverterOptionalTypeConversionOptions.allocationSize(value.conversionOptions)+FfiConverterOptionalTypeFeePolicy.allocationSize(value.feePolicy);}}return new FFIConverter();})();/**
 * Generated factory for {@link PrepareLnurlPayResponse} record objects.
 */export const PrepareLnurlPayResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link PrepareLnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link PrepareLnurlPayResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypePrepareLnurlPayResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{amountSats:FfiConverterUInt64.read(from),comment:FfiConverterOptionalString.read(from),payRequest:FfiConverterTypeLnurlPayRequestDetails.read(from),feeSats:FfiConverterUInt64.read(from),invoiceDetails:FfiConverterTypeBolt11InvoiceDetails.read(from),successAction:FfiConverterOptionalTypeSuccessAction.read(from),conversionEstimate:FfiConverterOptionalTypeConversionEstimate.read(from),feePolicy:FfiConverterTypeFeePolicy.read(from)};}write(value,into){FfiConverterUInt64.write(value.amountSats,into);FfiConverterOptionalString.write(value.comment,into);FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest,into);FfiConverterUInt64.write(value.feeSats,into);FfiConverterTypeBolt11InvoiceDetails.write(value.invoiceDetails,into);FfiConverterOptionalTypeSuccessAction.write(value.successAction,into);FfiConverterOptionalTypeConversionEstimate.write(value.conversionEstimate,into);FfiConverterTypeFeePolicy.write(value.feePolicy,into);}allocationSize(value){return FfiConverterUInt64.allocationSize(value.amountSats)+FfiConverterOptionalString.allocationSize(value.comment)+FfiConverterTypeLnurlPayRequestDetails.allocationSize(value.payRequest)+FfiConverterUInt64.allocationSize(value.feeSats)+FfiConverterTypeBolt11InvoiceDetails.allocationSize(value.invoiceDetails)+FfiConverterOptionalTypeSuccessAction.allocationSize(value.successAction)+FfiConverterOptionalTypeConversionEstimate.allocationSize(value.conversionEstimate)+FfiConverterTypeFeePolicy.allocationSize(value.feePolicy);}}return new FFIConverter();})();/**
 * Generated factory for {@link PrepareSendPaymentRequest} record objects.
 */export const PrepareSendPaymentRequest=(()=>{const defaults=()=>({amount:undefined,tokenIdentifier:undefined,conversionOptions:undefined,feePolicy:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link PrepareSendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link PrepareSendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypePrepareSendPaymentRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentRequest:FfiConverterString.read(from),amount:FfiConverterOptionalTypeu128.read(from),tokenIdentifier:FfiConverterOptionalString.read(from),conversionOptions:FfiConverterOptionalTypeConversionOptions.read(from),feePolicy:FfiConverterOptionalTypeFeePolicy.read(from)};}write(value,into){FfiConverterString.write(value.paymentRequest,into);FfiConverterOptionalTypeu128.write(value.amount,into);FfiConverterOptionalString.write(value.tokenIdentifier,into);FfiConverterOptionalTypeConversionOptions.write(value.conversionOptions,into);FfiConverterOptionalTypeFeePolicy.write(value.feePolicy,into);}allocationSize(value){return FfiConverterString.allocationSize(value.paymentRequest)+FfiConverterOptionalTypeu128.allocationSize(value.amount)+FfiConverterOptionalString.allocationSize(value.tokenIdentifier)+FfiConverterOptionalTypeConversionOptions.allocationSize(value.conversionOptions)+FfiConverterOptionalTypeFeePolicy.allocationSize(value.feePolicy);}}return new FFIConverter();})();/**
 * Generated factory for {@link PrepareSendPaymentResponse} record objects.
 */export const PrepareSendPaymentResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link PrepareSendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link PrepareSendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypePrepareSendPaymentResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentMethod:FfiConverterTypeSendPaymentMethod.read(from),amount:FfiConverterTypeu128.read(from),tokenIdentifier:FfiConverterOptionalString.read(from),conversionEstimate:FfiConverterOptionalTypeConversionEstimate.read(from),feePolicy:FfiConverterTypeFeePolicy.read(from)};}write(value,into){FfiConverterTypeSendPaymentMethod.write(value.paymentMethod,into);FfiConverterTypeu128.write(value.amount,into);FfiConverterOptionalString.write(value.tokenIdentifier,into);FfiConverterOptionalTypeConversionEstimate.write(value.conversionEstimate,into);FfiConverterTypeFeePolicy.write(value.feePolicy,into);}allocationSize(value){return FfiConverterTypeSendPaymentMethod.allocationSize(value.paymentMethod)+FfiConverterTypeu128.allocationSize(value.amount)+FfiConverterOptionalString.allocationSize(value.tokenIdentifier)+FfiConverterOptionalTypeConversionEstimate.allocationSize(value.conversionEstimate)+FfiConverterTypeFeePolicy.allocationSize(value.feePolicy);}}return new FFIConverter();})();/**
 * Generated factory for {@link ProvisionalPayment} record objects.
 */export const ProvisionalPayment=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ProvisionalPayment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ProvisionalPayment}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeProvisionalPayment=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentId:FfiConverterString.read(from),amount:FfiConverterTypeu128.read(from),details:FfiConverterTypeProvisionalPaymentDetails.read(from)};}write(value,into){FfiConverterString.write(value.paymentId,into);FfiConverterTypeu128.write(value.amount,into);FfiConverterTypeProvisionalPaymentDetails.write(value.details,into);}allocationSize(value){return FfiConverterString.allocationSize(value.paymentId)+FfiConverterTypeu128.allocationSize(value.amount)+FfiConverterTypeProvisionalPaymentDetails.allocationSize(value.details);}}return new FFIConverter();})();/**
 * FFI-safe representation of a secp256k1 public key (33 bytes compressed)
 *//**
 * Generated factory for {@link PublicKeyBytes} record objects.
 */export const PublicKeyBytes=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link PublicKeyBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link PublicKeyBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypePublicKeyBytes=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * Denominator in an exchange rate
 *//**
 * Generated factory for {@link Rate} record objects.
 */export const Rate=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Rate}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Rate}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeRate=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{coin:FfiConverterString.read(from),value:FfiConverterFloat64.read(from)};}write(value,into){FfiConverterString.write(value.coin,into);FfiConverterFloat64.write(value.value,into);}allocationSize(value){return FfiConverterString.allocationSize(value.coin)+FfiConverterFloat64.allocationSize(value.value);}}return new FFIConverter();})();/**
 * Generated factory for {@link ReceivePaymentRequest} record objects.
 */export const ReceivePaymentRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ReceivePaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ReceivePaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeReceivePaymentRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentMethod:FfiConverterTypeReceivePaymentMethod.read(from)};}write(value,into){FfiConverterTypeReceivePaymentMethod.write(value.paymentMethod,into);}allocationSize(value){return FfiConverterTypeReceivePaymentMethod.allocationSize(value.paymentMethod);}}return new FFIConverter();})();/**
 * Generated factory for {@link ReceivePaymentResponse} record objects.
 */export const ReceivePaymentResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link ReceivePaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link ReceivePaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeReceivePaymentResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentRequest:FfiConverterString.read(from),fee:FfiConverterTypeu128.read(from)};}write(value,into){FfiConverterString.write(value.paymentRequest,into);FfiConverterTypeu128.write(value.fee,into);}allocationSize(value){return FfiConverterString.allocationSize(value.paymentRequest)+FfiConverterTypeu128.allocationSize(value.fee);}}return new FFIConverter();})();/**
 * Generated factory for {@link RecommendedFees} record objects.
 */export const RecommendedFees=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link RecommendedFees}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link RecommendedFees}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeRecommendedFees=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{fastestFee:FfiConverterUInt64.read(from),halfHourFee:FfiConverterUInt64.read(from),hourFee:FfiConverterUInt64.read(from),economyFee:FfiConverterUInt64.read(from),minimumFee:FfiConverterUInt64.read(from)};}write(value,into){FfiConverterUInt64.write(value.fastestFee,into);FfiConverterUInt64.write(value.halfHourFee,into);FfiConverterUInt64.write(value.hourFee,into);FfiConverterUInt64.write(value.economyFee,into);FfiConverterUInt64.write(value.minimumFee,into);}allocationSize(value){return FfiConverterUInt64.allocationSize(value.fastestFee)+FfiConverterUInt64.allocationSize(value.halfHourFee)+FfiConverterUInt64.allocationSize(value.hourFee)+FfiConverterUInt64.allocationSize(value.economyFee)+FfiConverterUInt64.allocationSize(value.minimumFee);}}return new FFIConverter();})();/**
 * Generated factory for {@link Record} record objects.
 */export const Record=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Record}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Record}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeRecord=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{id:FfiConverterTypeRecordId.read(from),revision:FfiConverterUInt64.read(from),schemaVersion:FfiConverterString.read(from),data:FfiConverterMapStringString.read(from)};}write(value,into){FfiConverterTypeRecordId.write(value.id,into);FfiConverterUInt64.write(value.revision,into);FfiConverterString.write(value.schemaVersion,into);FfiConverterMapStringString.write(value.data,into);}allocationSize(value){return FfiConverterTypeRecordId.allocationSize(value.id)+FfiConverterUInt64.allocationSize(value.revision)+FfiConverterString.allocationSize(value.schemaVersion)+FfiConverterMapStringString.allocationSize(value.data);}}return new FFIConverter();})();/**
 * Generated factory for {@link RecordChange} record objects.
 */export const RecordChange=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link RecordChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link RecordChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeRecordChange=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{id:FfiConverterTypeRecordId.read(from),schemaVersion:FfiConverterString.read(from),updatedFields:FfiConverterMapStringString.read(from),localRevision:FfiConverterUInt64.read(from)};}write(value,into){FfiConverterTypeRecordId.write(value.id,into);FfiConverterString.write(value.schemaVersion,into);FfiConverterMapStringString.write(value.updatedFields,into);FfiConverterUInt64.write(value.localRevision,into);}allocationSize(value){return FfiConverterTypeRecordId.allocationSize(value.id)+FfiConverterString.allocationSize(value.schemaVersion)+FfiConverterMapStringString.allocationSize(value.updatedFields)+FfiConverterUInt64.allocationSize(value.localRevision);}}return new FFIConverter();})();/**
 * Generated factory for {@link RecordId} record objects.
 */export const RecordId=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link RecordId}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link RecordId}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeRecordId=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{type:FfiConverterString.read(from),dataId:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.type,into);FfiConverterString.write(value.dataId,into);}allocationSize(value){return FfiConverterString.allocationSize(value.type)+FfiConverterString.allocationSize(value.dataId);}}return new FFIConverter();})();/**
 * FFI-safe representation of a recoverable ECDSA signature (65 bytes: 1 recovery byte + 64 signature bytes)
 *//**
 * Generated factory for {@link RecoverableEcdsaSignatureBytes} record objects.
 */export const RecoverableEcdsaSignatureBytes=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link RecoverableEcdsaSignatureBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link RecoverableEcdsaSignatureBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeRecoverableEcdsaSignatureBytes=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * Generated factory for {@link RefundDepositRequest} record objects.
 */export const RefundDepositRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link RefundDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link RefundDepositRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeRefundDepositRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{txid:FfiConverterString.read(from),vout:FfiConverterUInt32.read(from),destinationAddress:FfiConverterString.read(from),fee:FfiConverterTypeFee.read(from)};}write(value,into){FfiConverterString.write(value.txid,into);FfiConverterUInt32.write(value.vout,into);FfiConverterString.write(value.destinationAddress,into);FfiConverterTypeFee.write(value.fee,into);}allocationSize(value){return FfiConverterString.allocationSize(value.txid)+FfiConverterUInt32.allocationSize(value.vout)+FfiConverterString.allocationSize(value.destinationAddress)+FfiConverterTypeFee.allocationSize(value.fee);}}return new FFIConverter();})();/**
 * Generated factory for {@link RefundDepositResponse} record objects.
 */export const RefundDepositResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link RefundDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link RefundDepositResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeRefundDepositResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{txId:FfiConverterString.read(from),txHex:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.txId,into);FfiConverterString.write(value.txHex,into);}allocationSize(value){return FfiConverterString.allocationSize(value.txId)+FfiConverterString.allocationSize(value.txHex);}}return new FFIConverter();})();/**
 * Generated factory for {@link RegisterLightningAddressRequest} record objects.
 */export const RegisterLightningAddressRequest=(()=>{const defaults=()=>({description:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link RegisterLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link RegisterLightningAddressRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeRegisterLightningAddressRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{username:FfiConverterString.read(from),description:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterString.write(value.username,into);FfiConverterOptionalString.write(value.description,into);}allocationSize(value){return FfiConverterString.allocationSize(value.username)+FfiConverterOptionalString.allocationSize(value.description);}}return new FFIConverter();})();/**
 * Generated factory for {@link RestResponse} record objects.
 */export const RestResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link RestResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link RestResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeRestResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{status:FfiConverterUInt16.read(from),body:FfiConverterString.read(from)};}write(value,into){FfiConverterUInt16.write(value.status,into);FfiConverterString.write(value.body,into);}allocationSize(value){return FfiConverterUInt16.allocationSize(value.status)+FfiConverterString.allocationSize(value.body);}}return new FFIConverter();})();/**
 * FFI-safe representation of a Schnorr signature (64 bytes)
 *//**
 * Generated factory for {@link SchnorrSignatureBytes} record objects.
 */export const SchnorrSignatureBytes=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SchnorrSignatureBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SchnorrSignatureBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSchnorrSignatureBytes=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * FFI-safe representation of a private key (32 bytes)
 *//**
 * Generated factory for {@link SecretBytes} record objects.
 */export const SecretBytes=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SecretBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SecretBytes}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSecretBytes=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{bytes:FfiConverterArrayBuffer.read(from)};}write(value,into){FfiConverterArrayBuffer.write(value.bytes,into);}allocationSize(value){return FfiConverterArrayBuffer.allocationSize(value.bytes);}}return new FFIConverter();})();/**
 * Generated factory for {@link SendOnchainFeeQuote} record objects.
 */export const SendOnchainFeeQuote=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SendOnchainFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SendOnchainFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSendOnchainFeeQuote=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{id:FfiConverterString.read(from),expiresAt:FfiConverterUInt64.read(from),speedFast:FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),speedMedium:FfiConverterTypeSendOnchainSpeedFeeQuote.read(from),speedSlow:FfiConverterTypeSendOnchainSpeedFeeQuote.read(from)};}write(value,into){FfiConverterString.write(value.id,into);FfiConverterUInt64.write(value.expiresAt,into);FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedFast,into);FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedMedium,into);FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedSlow,into);}allocationSize(value){return FfiConverterString.allocationSize(value.id)+FfiConverterUInt64.allocationSize(value.expiresAt)+FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(value.speedFast)+FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(value.speedMedium)+FfiConverterTypeSendOnchainSpeedFeeQuote.allocationSize(value.speedSlow);}}return new FFIConverter();})();/**
 * Generated factory for {@link SendOnchainSpeedFeeQuote} record objects.
 */export const SendOnchainSpeedFeeQuote=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SendOnchainSpeedFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SendOnchainSpeedFeeQuote}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSendOnchainSpeedFeeQuote=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{userFeeSat:FfiConverterUInt64.read(from),l1BroadcastFeeSat:FfiConverterUInt64.read(from)};}write(value,into){FfiConverterUInt64.write(value.userFeeSat,into);FfiConverterUInt64.write(value.l1BroadcastFeeSat,into);}allocationSize(value){return FfiConverterUInt64.allocationSize(value.userFeeSat)+FfiConverterUInt64.allocationSize(value.l1BroadcastFeeSat);}}return new FFIConverter();})();/**
 * Generated factory for {@link SendPaymentRequest} record objects.
 */export const SendPaymentRequest=(()=>{const defaults=()=>({options:undefined,idempotencyKey:undefined});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SendPaymentRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSendPaymentRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{prepareResponse:FfiConverterTypePrepareSendPaymentResponse.read(from),options:FfiConverterOptionalTypeSendPaymentOptions.read(from),idempotencyKey:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterTypePrepareSendPaymentResponse.write(value.prepareResponse,into);FfiConverterOptionalTypeSendPaymentOptions.write(value.options,into);FfiConverterOptionalString.write(value.idempotencyKey,into);}allocationSize(value){return FfiConverterTypePrepareSendPaymentResponse.allocationSize(value.prepareResponse)+FfiConverterOptionalTypeSendPaymentOptions.allocationSize(value.options)+FfiConverterOptionalString.allocationSize(value.idempotencyKey);}}return new FFIConverter();})();/**
 * Generated factory for {@link SendPaymentResponse} record objects.
 */export const SendPaymentResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SendPaymentResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSendPaymentResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{payment:FfiConverterTypePayment.read(from)};}write(value,into){FfiConverterTypePayment.write(value.payment,into);}allocationSize(value){return FfiConverterTypePayment.allocationSize(value.payment);}}return new FFIConverter();})();/**
 * Generated factory for {@link SetLnurlMetadataItem} record objects.
 */export const SetLnurlMetadataItem=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SetLnurlMetadataItem}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SetLnurlMetadataItem}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSetLnurlMetadataItem=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentHash:FfiConverterString.read(from),senderComment:FfiConverterOptionalString.read(from),nostrZapRequest:FfiConverterOptionalString.read(from),nostrZapReceipt:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterString.write(value.paymentHash,into);FfiConverterOptionalString.write(value.senderComment,into);FfiConverterOptionalString.write(value.nostrZapRequest,into);FfiConverterOptionalString.write(value.nostrZapReceipt,into);}allocationSize(value){return FfiConverterString.allocationSize(value.paymentHash)+FfiConverterOptionalString.allocationSize(value.senderComment)+FfiConverterOptionalString.allocationSize(value.nostrZapRequest)+FfiConverterOptionalString.allocationSize(value.nostrZapReceipt);}}return new FFIConverter();})();/**
 * Generated factory for {@link SignMessageRequest} record objects.
 */export const SignMessageRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SignMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SignMessageRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSignMessageRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{message:FfiConverterString.read(from),compact:FfiConverterBool.read(from)};}write(value,into){FfiConverterString.write(value.message,into);FfiConverterBool.write(value.compact,into);}allocationSize(value){return FfiConverterString.allocationSize(value.message)+FfiConverterBool.allocationSize(value.compact);}}return new FFIConverter();})();/**
 * Generated factory for {@link SignMessageResponse} record objects.
 */export const SignMessageResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SignMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SignMessageResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSignMessageResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{pubkey:FfiConverterString.read(from),signature:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.pubkey,into);FfiConverterString.write(value.signature,into);}allocationSize(value){return FfiConverterString.allocationSize(value.pubkey)+FfiConverterString.allocationSize(value.signature);}}return new FFIConverter();})();/**
 * Generated factory for {@link SilentPaymentAddressDetails} record objects.
 */export const SilentPaymentAddressDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SilentPaymentAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SilentPaymentAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSilentPaymentAddressDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{address:FfiConverterString.read(from),network:FfiConverterTypeBitcoinNetwork.read(from),source:FfiConverterTypePaymentRequestSource.read(from)};}write(value,into){FfiConverterString.write(value.address,into);FfiConverterTypeBitcoinNetwork.write(value.network,into);FfiConverterTypePaymentRequestSource.write(value.source,into);}allocationSize(value){return FfiConverterString.allocationSize(value.address)+FfiConverterTypeBitcoinNetwork.allocationSize(value.network)+FfiConverterTypePaymentRequestSource.allocationSize(value.source);}}return new FFIConverter();})();/**
 * Generated factory for {@link SparkAddressDetails} record objects.
 */export const SparkAddressDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SparkAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SparkAddressDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSparkAddressDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{address:FfiConverterString.read(from),identityPublicKey:FfiConverterString.read(from),network:FfiConverterTypeBitcoinNetwork.read(from),source:FfiConverterTypePaymentRequestSource.read(from)};}write(value,into){FfiConverterString.write(value.address,into);FfiConverterString.write(value.identityPublicKey,into);FfiConverterTypeBitcoinNetwork.write(value.network,into);FfiConverterTypePaymentRequestSource.write(value.source,into);}allocationSize(value){return FfiConverterString.allocationSize(value.address)+FfiConverterString.allocationSize(value.identityPublicKey)+FfiConverterTypeBitcoinNetwork.allocationSize(value.network)+FfiConverterTypePaymentRequestSource.allocationSize(value.source);}}return new FFIConverter();})();/**
 * Generated factory for {@link SparkHtlcDetails} record objects.
 */export const SparkHtlcDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SparkHtlcDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SparkHtlcDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSparkHtlcDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentHash:FfiConverterString.read(from),preimage:FfiConverterOptionalString.read(from),expiryTime:FfiConverterUInt64.read(from),status:FfiConverterTypeSparkHtlcStatus.read(from)};}write(value,into){FfiConverterString.write(value.paymentHash,into);FfiConverterOptionalString.write(value.preimage,into);FfiConverterUInt64.write(value.expiryTime,into);FfiConverterTypeSparkHtlcStatus.write(value.status,into);}allocationSize(value){return FfiConverterString.allocationSize(value.paymentHash)+FfiConverterOptionalString.allocationSize(value.preimage)+FfiConverterUInt64.allocationSize(value.expiryTime)+FfiConverterTypeSparkHtlcStatus.allocationSize(value.status);}}return new FFIConverter();})();/**
 * Generated factory for {@link SparkHtlcOptions} record objects.
 */export const SparkHtlcOptions=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SparkHtlcOptions}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SparkHtlcOptions}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSparkHtlcOptions=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{paymentHash:FfiConverterString.read(from),expiryDurationSecs:FfiConverterUInt64.read(from)};}write(value,into){FfiConverterString.write(value.paymentHash,into);FfiConverterUInt64.write(value.expiryDurationSecs,into);}allocationSize(value){return FfiConverterString.allocationSize(value.paymentHash)+FfiConverterUInt64.allocationSize(value.expiryDurationSecs);}}return new FFIConverter();})();/**
 * Generated factory for {@link SparkInvoiceDetails} record objects.
 */export const SparkInvoiceDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SparkInvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SparkInvoiceDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSparkInvoiceDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{invoice:FfiConverterString.read(from),identityPublicKey:FfiConverterString.read(from),network:FfiConverterTypeBitcoinNetwork.read(from),amount:FfiConverterOptionalTypeu128.read(from),tokenIdentifier:FfiConverterOptionalString.read(from),expiryTime:FfiConverterOptionalUInt64.read(from),description:FfiConverterOptionalString.read(from),senderPublicKey:FfiConverterOptionalString.read(from)};}write(value,into){FfiConverterString.write(value.invoice,into);FfiConverterString.write(value.identityPublicKey,into);FfiConverterTypeBitcoinNetwork.write(value.network,into);FfiConverterOptionalTypeu128.write(value.amount,into);FfiConverterOptionalString.write(value.tokenIdentifier,into);FfiConverterOptionalUInt64.write(value.expiryTime,into);FfiConverterOptionalString.write(value.description,into);FfiConverterOptionalString.write(value.senderPublicKey,into);}allocationSize(value){return FfiConverterString.allocationSize(value.invoice)+FfiConverterString.allocationSize(value.identityPublicKey)+FfiConverterTypeBitcoinNetwork.allocationSize(value.network)+FfiConverterOptionalTypeu128.allocationSize(value.amount)+FfiConverterOptionalString.allocationSize(value.tokenIdentifier)+FfiConverterOptionalUInt64.allocationSize(value.expiryTime)+FfiConverterOptionalString.allocationSize(value.description)+FfiConverterOptionalString.allocationSize(value.senderPublicKey);}}return new FFIConverter();})();/**
 * Generated factory for {@link SparkInvoicePaymentDetails} record objects.
 */export const SparkInvoicePaymentDetails=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SparkInvoicePaymentDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SparkInvoicePaymentDetails}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSparkInvoicePaymentDetails=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{description:FfiConverterOptionalString.read(from),invoice:FfiConverterString.read(from)};}write(value,into){FfiConverterOptionalString.write(value.description,into);FfiConverterString.write(value.invoice,into);}allocationSize(value){return FfiConverterOptionalString.allocationSize(value.description)+FfiConverterString.allocationSize(value.invoice);}}return new FFIConverter();})();/**
 * The status of the Spark network services relevant to the SDK.
 *//**
 * Generated factory for {@link SparkStatus} record objects.
 */export const SparkStatus=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SparkStatus}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SparkStatus}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSparkStatus=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{status:FfiConverterTypeServiceStatus.read(from),lastUpdated:FfiConverterUInt64.read(from)};}write(value,into){FfiConverterTypeServiceStatus.write(value.status,into);FfiConverterUInt64.write(value.lastUpdated,into);}allocationSize(value){return FfiConverterTypeServiceStatus.allocationSize(value.status)+FfiConverterUInt64.allocationSize(value.lastUpdated);}}return new FFIConverter();})();/**
 * Settings for the symbol representation of a currency
 *//**
 * Generated factory for {@link Symbol} record objects.
 */export const Symbol=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Symbol}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Symbol}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSymbol=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{grapheme:FfiConverterOptionalString.read(from),template:FfiConverterOptionalString.read(from),rtl:FfiConverterOptionalBool.read(from),position:FfiConverterOptionalUInt32.read(from)};}write(value,into){FfiConverterOptionalString.write(value.grapheme,into);FfiConverterOptionalString.write(value.template,into);FfiConverterOptionalBool.write(value.rtl,into);FfiConverterOptionalUInt32.write(value.position,into);}allocationSize(value){return FfiConverterOptionalString.allocationSize(value.grapheme)+FfiConverterOptionalString.allocationSize(value.template)+FfiConverterOptionalBool.allocationSize(value.rtl)+FfiConverterOptionalUInt32.allocationSize(value.position);}}return new FFIConverter();})();/**
 * Request to sync the wallet with the Spark network
 *//**
 * Generated factory for {@link SyncWalletRequest} record objects.
 */export const SyncWalletRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SyncWalletRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SyncWalletRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSyncWalletRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{};}write(value,into){}allocationSize(value){return 0;}}return new FFIConverter();})();/**
 * Response from synchronizing the wallet
 *//**
 * Generated factory for {@link SyncWalletResponse} record objects.
 */export const SyncWalletResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link SyncWalletResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link SyncWalletResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeSyncWalletResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{};}write(value,into){}allocationSize(value){return 0;}}return new FFIConverter();})();/**
 * Generated factory for {@link TokenBalance} record objects.
 */export const TokenBalance=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link TokenBalance}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link TokenBalance}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeTokenBalance=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{balance:FfiConverterTypeu128.read(from),tokenMetadata:FfiConverterTypeTokenMetadata.read(from)};}write(value,into){FfiConverterTypeu128.write(value.balance,into);FfiConverterTypeTokenMetadata.write(value.tokenMetadata,into);}allocationSize(value){return FfiConverterTypeu128.allocationSize(value.balance)+FfiConverterTypeTokenMetadata.allocationSize(value.tokenMetadata);}}return new FFIConverter();})();/**
 * Generated factory for {@link TokenMetadata} record objects.
 */export const TokenMetadata=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link TokenMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link TokenMetadata}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeTokenMetadata=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{identifier:FfiConverterString.read(from),issuerPublicKey:FfiConverterString.read(from),name:FfiConverterString.read(from),ticker:FfiConverterString.read(from),decimals:FfiConverterUInt32.read(from),maxSupply:FfiConverterTypeu128.read(from),isFreezable:FfiConverterBool.read(from)};}write(value,into){FfiConverterString.write(value.identifier,into);FfiConverterString.write(value.issuerPublicKey,into);FfiConverterString.write(value.name,into);FfiConverterString.write(value.ticker,into);FfiConverterUInt32.write(value.decimals,into);FfiConverterTypeu128.write(value.maxSupply,into);FfiConverterBool.write(value.isFreezable,into);}allocationSize(value){return FfiConverterString.allocationSize(value.identifier)+FfiConverterString.allocationSize(value.issuerPublicKey)+FfiConverterString.allocationSize(value.name)+FfiConverterString.allocationSize(value.ticker)+FfiConverterUInt32.allocationSize(value.decimals)+FfiConverterTypeu128.allocationSize(value.maxSupply)+FfiConverterBool.allocationSize(value.isFreezable);}}return new FFIConverter();})();/**
 * Generated factory for {@link TxStatus} record objects.
 */export const TxStatus=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link TxStatus}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link TxStatus}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeTxStatus=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{confirmed:FfiConverterBool.read(from),blockHeight:FfiConverterOptionalUInt32.read(from),blockTime:FfiConverterOptionalUInt64.read(from)};}write(value,into){FfiConverterBool.write(value.confirmed,into);FfiConverterOptionalUInt32.write(value.blockHeight,into);FfiConverterOptionalUInt64.write(value.blockTime,into);}allocationSize(value){return FfiConverterBool.allocationSize(value.confirmed)+FfiConverterOptionalUInt32.allocationSize(value.blockHeight)+FfiConverterOptionalUInt64.allocationSize(value.blockTime);}}return new FFIConverter();})();/**
 * Generated factory for {@link UnfreezeIssuerTokenRequest} record objects.
 */export const UnfreezeIssuerTokenRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link UnfreezeIssuerTokenRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link UnfreezeIssuerTokenRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeUnfreezeIssuerTokenRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{address:FfiConverterString.read(from)};}write(value,into){FfiConverterString.write(value.address,into);}allocationSize(value){return FfiConverterString.allocationSize(value.address);}}return new FFIConverter();})();/**
 * Generated factory for {@link UnfreezeIssuerTokenResponse} record objects.
 */export const UnfreezeIssuerTokenResponse=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link UnfreezeIssuerTokenResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link UnfreezeIssuerTokenResponse}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeUnfreezeIssuerTokenResponse=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{impactedOutputIds:FfiConverterArrayString.read(from),impactedTokenAmount:FfiConverterTypeu128.read(from)};}write(value,into){FfiConverterArrayString.write(value.impactedOutputIds,into);FfiConverterTypeu128.write(value.impactedTokenAmount,into);}allocationSize(value){return FfiConverterArrayString.allocationSize(value.impactedOutputIds)+FfiConverterTypeu128.allocationSize(value.impactedTokenAmount);}}return new FFIConverter();})();/**
 * Generated factory for {@link UnversionedRecordChange} record objects.
 */export const UnversionedRecordChange=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link UnversionedRecordChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link UnversionedRecordChange}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeUnversionedRecordChange=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{id:FfiConverterTypeRecordId.read(from),schemaVersion:FfiConverterString.read(from),updatedFields:FfiConverterMapStringString.read(from)};}write(value,into){FfiConverterTypeRecordId.write(value.id,into);FfiConverterString.write(value.schemaVersion,into);FfiConverterMapStringString.write(value.updatedFields,into);}allocationSize(value){return FfiConverterTypeRecordId.allocationSize(value.id)+FfiConverterString.allocationSize(value.schemaVersion)+FfiConverterMapStringString.allocationSize(value.updatedFields);}}return new FFIConverter();})();/**
 * Generated factory for {@link UpdateUserSettingsRequest} record objects.
 */export const UpdateUserSettingsRequest=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link UpdateUserSettingsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link UpdateUserSettingsRequest}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeUpdateUserSettingsRequest=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{sparkPrivateModeEnabled:FfiConverterOptionalBool.read(from)};}write(value,into){FfiConverterOptionalBool.write(value.sparkPrivateModeEnabled,into);}allocationSize(value){return FfiConverterOptionalBool.allocationSize(value.sparkPrivateModeEnabled);}}return new FFIConverter();})();/**
 * Generated factory for {@link UrlSuccessActionData} record objects.
 */export const UrlSuccessActionData=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link UrlSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link UrlSuccessActionData}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeUrlSuccessActionData=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{description:FfiConverterString.read(from),url:FfiConverterString.read(from),matchesCallbackDomain:FfiConverterBool.read(from)};}write(value,into){FfiConverterString.write(value.description,into);FfiConverterString.write(value.url,into);FfiConverterBool.write(value.matchesCallbackDomain,into);}allocationSize(value){return FfiConverterString.allocationSize(value.description)+FfiConverterString.allocationSize(value.url)+FfiConverterBool.allocationSize(value.matchesCallbackDomain);}}return new FFIConverter();})();/**
 * Generated factory for {@link UserSettings} record objects.
 */export const UserSettings=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link UserSettings}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link UserSettings}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeUserSettings=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{sparkPrivateModeEnabled:FfiConverterBool.read(from)};}write(value,into){FfiConverterBool.write(value.sparkPrivateModeEnabled,into);}allocationSize(value){return FfiConverterBool.allocationSize(value.sparkPrivateModeEnabled);}}return new FFIConverter();})();/**
 * Generated factory for {@link Utxo} record objects.
 */export const Utxo=(()=>{const defaults=()=>({});const create=(()=>{return uniffiCreateRecord(defaults);})();return Object.freeze({/**
     * Create a frozen instance of {@link Utxo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */create,/**
     * Create a frozen instance of {@link Utxo}, with defaults specified
     * in Rust, in the {@link breez_sdk_spark} crate.
     */new:create,/**
     * Defaults specified in the {@link breez_sdk_spark} crate.
     */defaults:()=>Object.freeze(defaults())});})();const FfiConverterTypeUtxo=(()=>{class FFIConverter extends AbstractFfiConverterByteArray{read(from){return{txid:FfiConverterString.read(from),vout:FfiConverterUInt32.read(from),value:FfiConverterUInt64.read(from),status:FfiConverterTypeTxStatus.read(from)};}write(value,into){FfiConverterString.write(value.txid,into);FfiConverterUInt32.write(value.vout,into);FfiConverterUInt64.write(value.value,into);FfiConverterTypeTxStatus.write(value.status,into);}allocationSize(value){return FfiConverterString.allocationSize(value.txid)+FfiConverterUInt32.allocationSize(value.vout)+FfiConverterUInt64.allocationSize(value.value)+FfiConverterTypeTxStatus.allocationSize(value.status);}}return new FFIConverter();})();const stringConverter={stringToBytes:s=>uniffiCaller.rustCall(status=>nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(s,status)),bytesToString:ab=>uniffiCaller.rustCall(status=>nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(ab,status)),stringByteLength:s=>uniffiCaller.rustCall(status=>nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(s,status))};const FfiConverterString=uniffiCreateFfiConverterString(stringConverter);/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */// FfiConverter for U128
const FfiConverterTypeu128=(()=>{const intermediateConverter=FfiConverterString;class FFIConverter{lift(value){const intermediate=intermediateConverter.lift(value);return BigInt(intermediate);}lower(value){const intermediate=value.toString();return intermediateConverter.lower(intermediate);}read(from){const intermediate=intermediateConverter.read(from);return BigInt(intermediate);}write(value,into){const intermediate=value.toString();intermediateConverter.write(intermediate,into);}allocationSize(value){const intermediate=value.toString();return intermediateConverter.allocationSize(intermediate);}}return new FFIConverter();})();// Enum: AesSuccessActionDataResult
export let AesSuccessActionDataResult_Tags=/*#__PURE__*/function(AesSuccessActionDataResult_Tags){AesSuccessActionDataResult_Tags["Decrypted"]="Decrypted";AesSuccessActionDataResult_Tags["ErrorStatus"]="ErrorStatus";return AesSuccessActionDataResult_Tags;}({});/**
 * Result of decryption of [`AesSuccessActionData`] payload
 */export const AesSuccessActionDataResult=(()=>{class Decrypted_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='AesSuccessActionDataResult';tag=AesSuccessActionDataResult_Tags.Decrypted;constructor(inner){super('AesSuccessActionDataResult','Decrypted');this.inner=Object.freeze(inner);}static new(inner){return new Decrypted_(inner);}static instanceOf(obj){return obj.tag===AesSuccessActionDataResult_Tags.Decrypted;}}class ErrorStatus_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='AesSuccessActionDataResult';tag=AesSuccessActionDataResult_Tags.ErrorStatus;constructor(inner){super('AesSuccessActionDataResult','ErrorStatus');this.inner=Object.freeze(inner);}static new(inner){return new ErrorStatus_(inner);}static instanceOf(obj){return obj.tag===AesSuccessActionDataResult_Tags.ErrorStatus;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='AesSuccessActionDataResult';}return Object.freeze({instanceOf,Decrypted:Decrypted_,ErrorStatus:ErrorStatus_});})();/**
 * Result of decryption of [`AesSuccessActionData`] payload
 */// FfiConverter for enum AesSuccessActionDataResult
const FfiConverterTypeAesSuccessActionDataResult=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new AesSuccessActionDataResult.Decrypted({data:FfiConverterTypeAesSuccessActionDataDecrypted.read(from)});case 2:return new AesSuccessActionDataResult.ErrorStatus({reason:FfiConverterString.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case AesSuccessActionDataResult_Tags.Decrypted:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterTypeAesSuccessActionDataDecrypted.write(inner.data,into);return;}case AesSuccessActionDataResult_Tags.ErrorStatus:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner.reason,into);return;}default:// Throwing from here means that AesSuccessActionDataResult_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case AesSuccessActionDataResult_Tags.Decrypted:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterTypeAesSuccessActionDataDecrypted.allocationSize(inner.data);return size;}case AesSuccessActionDataResult_Tags.ErrorStatus:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner.reason);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: Amount
export let Amount_Tags=/*#__PURE__*/function(Amount_Tags){Amount_Tags["Bitcoin"]="Bitcoin";Amount_Tags["Currency"]="Currency";return Amount_Tags;}({});export const Amount=(()=>{class Bitcoin_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='Amount';tag=Amount_Tags.Bitcoin;constructor(inner){super('Amount','Bitcoin');this.inner=Object.freeze(inner);}static new(inner){return new Bitcoin_(inner);}static instanceOf(obj){return obj.tag===Amount_Tags.Bitcoin;}}/**
   * An amount of currency specified using ISO 4712.
   */class Currency_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='Amount';tag=Amount_Tags.Currency;constructor(inner){super('Amount','Currency');this.inner=Object.freeze(inner);}static new(inner){return new Currency_(inner);}static instanceOf(obj){return obj.tag===Amount_Tags.Currency;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='Amount';}return Object.freeze({instanceOf,Bitcoin:Bitcoin_,Currency:Currency_});})();// FfiConverter for enum Amount
const FfiConverterTypeAmount=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new Amount.Bitcoin({amountMsat:FfiConverterUInt64.read(from)});case 2:return new Amount.Currency({iso4217Code:FfiConverterString.read(from),fractionalAmount:FfiConverterUInt64.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case Amount_Tags.Bitcoin:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterUInt64.write(inner.amountMsat,into);return;}case Amount_Tags.Currency:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner.iso4217Code,into);FfiConverterUInt64.write(inner.fractionalAmount,into);return;}default:// Throwing from here means that Amount_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case Amount_Tags.Bitcoin:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterUInt64.allocationSize(inner.amountMsat);return size;}case Amount_Tags.Currency:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner.iso4217Code);size+=FfiConverterUInt64.allocationSize(inner.fractionalAmount);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: AssetFilter
export let AssetFilter_Tags=/*#__PURE__*/function(AssetFilter_Tags){AssetFilter_Tags["Bitcoin"]="Bitcoin";AssetFilter_Tags["Token"]="Token";return AssetFilter_Tags;}({});/**
 * A field of [`ListPaymentsRequest`] when listing payments filtered by asset
 */export const AssetFilter=(()=>{class Bitcoin_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='AssetFilter';tag=AssetFilter_Tags.Bitcoin;constructor(){super('AssetFilter','Bitcoin');}static new(){return new Bitcoin_();}static instanceOf(obj){return obj.tag===AssetFilter_Tags.Bitcoin;}}class Token_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='AssetFilter';tag=AssetFilter_Tags.Token;constructor(inner){super('AssetFilter','Token');this.inner=Object.freeze(inner);}static new(inner){return new Token_(inner);}static instanceOf(obj){return obj.tag===AssetFilter_Tags.Token;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='AssetFilter';}return Object.freeze({instanceOf,Bitcoin:Bitcoin_,Token:Token_});})();/**
 * A field of [`ListPaymentsRequest`] when listing payments filtered by asset
 */// FfiConverter for enum AssetFilter
const FfiConverterTypeAssetFilter=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new AssetFilter.Bitcoin();case 2:return new AssetFilter.Token({tokenIdentifier:FfiConverterOptionalString.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case AssetFilter_Tags.Bitcoin:{ordinalConverter.write(1,into);return;}case AssetFilter_Tags.Token:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterOptionalString.write(inner.tokenIdentifier,into);return;}default:// Throwing from here means that AssetFilter_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case AssetFilter_Tags.Bitcoin:{return ordinalConverter.allocationSize(1);}case AssetFilter_Tags.Token:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterOptionalString.allocationSize(inner.tokenIdentifier);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();export let BitcoinNetwork=/*#__PURE__*/function(BitcoinNetwork){/**
   * Mainnet
   */BitcoinNetwork[BitcoinNetwork["Bitcoin"]=0]="Bitcoin";BitcoinNetwork[BitcoinNetwork["Testnet3"]=1]="Testnet3";BitcoinNetwork[BitcoinNetwork["Testnet4"]=2]="Testnet4";BitcoinNetwork[BitcoinNetwork["Signet"]=3]="Signet";BitcoinNetwork[BitcoinNetwork["Regtest"]=4]="Regtest";return BitcoinNetwork;}({});const FfiConverterTypeBitcoinNetwork=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return BitcoinNetwork.Bitcoin;case 2:return BitcoinNetwork.Testnet3;case 3:return BitcoinNetwork.Testnet4;case 4:return BitcoinNetwork.Signet;case 5:return BitcoinNetwork.Regtest;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case BitcoinNetwork.Bitcoin:return ordinalConverter.write(1,into);case BitcoinNetwork.Testnet3:return ordinalConverter.write(2,into);case BitcoinNetwork.Testnet4:return ordinalConverter.write(3,into);case BitcoinNetwork.Signet:return ordinalConverter.write(4,into);case BitcoinNetwork.Regtest:return ordinalConverter.write(5,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();export let ChainApiType=/*#__PURE__*/function(ChainApiType){ChainApiType[ChainApiType["Esplora"]=0]="Esplora";ChainApiType[ChainApiType["MempoolSpace"]=1]="MempoolSpace";return ChainApiType;}({});const FfiConverterTypeChainApiType=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return ChainApiType.Esplora;case 2:return ChainApiType.MempoolSpace;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case ChainApiType.Esplora:return ordinalConverter.write(1,into);case ChainApiType.MempoolSpace:return ordinalConverter.write(2,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();// Error type: ChainServiceError
// Enum: ChainServiceError
export let ChainServiceError_Tags=/*#__PURE__*/function(ChainServiceError_Tags){ChainServiceError_Tags["InvalidAddress"]="InvalidAddress";ChainServiceError_Tags["ServiceConnectivity"]="ServiceConnectivity";ChainServiceError_Tags["Generic"]="Generic";return ChainServiceError_Tags;}({});export const ChainServiceError=(()=>{class InvalidAddress_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ChainServiceError';tag=ChainServiceError_Tags.InvalidAddress;constructor(v0){super('ChainServiceError','InvalidAddress');this.inner=Object.freeze([v0]);}static new(v0){return new InvalidAddress_(v0);}static instanceOf(obj){return obj.tag===ChainServiceError_Tags.InvalidAddress;}static hasInner(obj){return InvalidAddress_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class ServiceConnectivity_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ChainServiceError';tag=ChainServiceError_Tags.ServiceConnectivity;constructor(v0){super('ChainServiceError','ServiceConnectivity');this.inner=Object.freeze([v0]);}static new(v0){return new ServiceConnectivity_(v0);}static instanceOf(obj){return obj.tag===ChainServiceError_Tags.ServiceConnectivity;}static hasInner(obj){return ServiceConnectivity_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Generic_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ChainServiceError';tag=ChainServiceError_Tags.Generic;constructor(v0){super('ChainServiceError','Generic');this.inner=Object.freeze([v0]);}static new(v0){return new Generic_(v0);}static instanceOf(obj){return obj.tag===ChainServiceError_Tags.Generic;}static hasInner(obj){return Generic_.instanceOf(obj);}static getInner(obj){return obj.inner;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='ChainServiceError';}return Object.freeze({instanceOf,InvalidAddress:InvalidAddress_,ServiceConnectivity:ServiceConnectivity_,Generic:Generic_});})();// FfiConverter for enum ChainServiceError
const FfiConverterTypeChainServiceError=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new ChainServiceError.InvalidAddress(FfiConverterString.read(from));case 2:return new ChainServiceError.ServiceConnectivity(FfiConverterString.read(from));case 3:return new ChainServiceError.Generic(FfiConverterString.read(from));default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case ChainServiceError_Tags.InvalidAddress:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case ChainServiceError_Tags.ServiceConnectivity:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case ChainServiceError_Tags.Generic:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}default:// Throwing from here means that ChainServiceError_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case ChainServiceError_Tags.InvalidAddress:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterString.allocationSize(inner[0]);return size;}case ChainServiceError_Tags.ServiceConnectivity:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner[0]);return size;}case ChainServiceError_Tags.Generic:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterString.allocationSize(inner[0]);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: ConversionPurpose
export let ConversionPurpose_Tags=/*#__PURE__*/function(ConversionPurpose_Tags){ConversionPurpose_Tags["OngoingPayment"]="OngoingPayment";ConversionPurpose_Tags["SelfTransfer"]="SelfTransfer";return ConversionPurpose_Tags;}({});/**
 * The purpose of the conversion, which is used to provide context for the conversion
 * if its related to an ongoing payment or a self-transfer.
 */export const ConversionPurpose=(()=>{/**
   * Conversion is associated with an ongoing payment
   */class OngoingPayment_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ConversionPurpose';tag=ConversionPurpose_Tags.OngoingPayment;constructor(inner){super('ConversionPurpose','OngoingPayment');this.inner=Object.freeze(inner);}static new(inner){return new OngoingPayment_(inner);}static instanceOf(obj){return obj.tag===ConversionPurpose_Tags.OngoingPayment;}}/**
   * Conversion is for self-transfer
   */class SelfTransfer_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ConversionPurpose';tag=ConversionPurpose_Tags.SelfTransfer;constructor(){super('ConversionPurpose','SelfTransfer');}static new(){return new SelfTransfer_();}static instanceOf(obj){return obj.tag===ConversionPurpose_Tags.SelfTransfer;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='ConversionPurpose';}return Object.freeze({instanceOf,OngoingPayment:OngoingPayment_,SelfTransfer:SelfTransfer_});})();/**
 * The purpose of the conversion, which is used to provide context for the conversion
 * if its related to an ongoing payment or a self-transfer.
 */// FfiConverter for enum ConversionPurpose
const FfiConverterTypeConversionPurpose=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new ConversionPurpose.OngoingPayment({paymentRequest:FfiConverterString.read(from)});case 2:return new ConversionPurpose.SelfTransfer();default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case ConversionPurpose_Tags.OngoingPayment:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterString.write(inner.paymentRequest,into);return;}case ConversionPurpose_Tags.SelfTransfer:{ordinalConverter.write(2,into);return;}default:// Throwing from here means that ConversionPurpose_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case ConversionPurpose_Tags.OngoingPayment:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterString.allocationSize(inner.paymentRequest);return size;}case ConversionPurpose_Tags.SelfTransfer:{return ordinalConverter.allocationSize(2);}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();/**
 * The status of the conversion
 */export let ConversionStatus=/*#__PURE__*/function(ConversionStatus){/**
   * The conversion was successful
   */ConversionStatus[ConversionStatus["Completed"]=0]="Completed";/**
   * The conversion failed and no refund was made yet, which requires action by the SDK to
   * perform the refund. This can happen if there was a failure during the conversion process.
   */ConversionStatus[ConversionStatus["RefundNeeded"]=1]="RefundNeeded";/**
   * The conversion failed and a refund was made
   */ConversionStatus[ConversionStatus["Refunded"]=2]="Refunded";return ConversionStatus;}({});const FfiConverterTypeConversionStatus=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return ConversionStatus.Completed;case 2:return ConversionStatus.RefundNeeded;case 3:return ConversionStatus.Refunded;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case ConversionStatus.Completed:return ordinalConverter.write(1,into);case ConversionStatus.RefundNeeded:return ordinalConverter.write(2,into);case ConversionStatus.Refunded:return ordinalConverter.write(3,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();// Enum: ConversionType
export let ConversionType_Tags=/*#__PURE__*/function(ConversionType_Tags){ConversionType_Tags["FromBitcoin"]="FromBitcoin";ConversionType_Tags["ToBitcoin"]="ToBitcoin";return ConversionType_Tags;}({});export const ConversionType=(()=>{/**
   * Converting from Bitcoin to a token
   */class FromBitcoin_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ConversionType';tag=ConversionType_Tags.FromBitcoin;constructor(){super('ConversionType','FromBitcoin');}static new(){return new FromBitcoin_();}static instanceOf(obj){return obj.tag===ConversionType_Tags.FromBitcoin;}}/**
   * Converting from a token to Bitcoin
   */class ToBitcoin_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ConversionType';tag=ConversionType_Tags.ToBitcoin;constructor(inner){super('ConversionType','ToBitcoin');this.inner=Object.freeze(inner);}static new(inner){return new ToBitcoin_(inner);}static instanceOf(obj){return obj.tag===ConversionType_Tags.ToBitcoin;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='ConversionType';}return Object.freeze({instanceOf,FromBitcoin:FromBitcoin_,ToBitcoin:ToBitcoin_});})();// FfiConverter for enum ConversionType
const FfiConverterTypeConversionType=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new ConversionType.FromBitcoin();case 2:return new ConversionType.ToBitcoin({fromTokenIdentifier:FfiConverterString.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case ConversionType_Tags.FromBitcoin:{ordinalConverter.write(1,into);return;}case ConversionType_Tags.ToBitcoin:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner.fromTokenIdentifier,into);return;}default:// Throwing from here means that ConversionType_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case ConversionType_Tags.FromBitcoin:{return ordinalConverter.allocationSize(1);}case ConversionType_Tags.ToBitcoin:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner.fromTokenIdentifier);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: DepositClaimError
export let DepositClaimError_Tags=/*#__PURE__*/function(DepositClaimError_Tags){DepositClaimError_Tags["MaxDepositClaimFeeExceeded"]="MaxDepositClaimFeeExceeded";DepositClaimError_Tags["MissingUtxo"]="MissingUtxo";DepositClaimError_Tags["Generic"]="Generic";return DepositClaimError_Tags;}({});export const DepositClaimError=(()=>{class MaxDepositClaimFeeExceeded_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='DepositClaimError';tag=DepositClaimError_Tags.MaxDepositClaimFeeExceeded;constructor(inner){super('DepositClaimError','MaxDepositClaimFeeExceeded');this.inner=Object.freeze(inner);}static new(inner){return new MaxDepositClaimFeeExceeded_(inner);}static instanceOf(obj){return obj.tag===DepositClaimError_Tags.MaxDepositClaimFeeExceeded;}}class MissingUtxo_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='DepositClaimError';tag=DepositClaimError_Tags.MissingUtxo;constructor(inner){super('DepositClaimError','MissingUtxo');this.inner=Object.freeze(inner);}static new(inner){return new MissingUtxo_(inner);}static instanceOf(obj){return obj.tag===DepositClaimError_Tags.MissingUtxo;}}class Generic_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='DepositClaimError';tag=DepositClaimError_Tags.Generic;constructor(inner){super('DepositClaimError','Generic');this.inner=Object.freeze(inner);}static new(inner){return new Generic_(inner);}static instanceOf(obj){return obj.tag===DepositClaimError_Tags.Generic;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='DepositClaimError';}return Object.freeze({instanceOf,MaxDepositClaimFeeExceeded:MaxDepositClaimFeeExceeded_,MissingUtxo:MissingUtxo_,Generic:Generic_});})();// FfiConverter for enum DepositClaimError
const FfiConverterTypeDepositClaimError=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new DepositClaimError.MaxDepositClaimFeeExceeded({tx:FfiConverterString.read(from),vout:FfiConverterUInt32.read(from),maxFee:FfiConverterOptionalTypeFee.read(from),requiredFeeSats:FfiConverterUInt64.read(from),requiredFeeRateSatPerVbyte:FfiConverterUInt64.read(from)});case 2:return new DepositClaimError.MissingUtxo({tx:FfiConverterString.read(from),vout:FfiConverterUInt32.read(from)});case 3:return new DepositClaimError.Generic({message:FfiConverterString.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case DepositClaimError_Tags.MaxDepositClaimFeeExceeded:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterString.write(inner.tx,into);FfiConverterUInt32.write(inner.vout,into);FfiConverterOptionalTypeFee.write(inner.maxFee,into);FfiConverterUInt64.write(inner.requiredFeeSats,into);FfiConverterUInt64.write(inner.requiredFeeRateSatPerVbyte,into);return;}case DepositClaimError_Tags.MissingUtxo:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner.tx,into);FfiConverterUInt32.write(inner.vout,into);return;}case DepositClaimError_Tags.Generic:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterString.write(inner.message,into);return;}default:// Throwing from here means that DepositClaimError_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case DepositClaimError_Tags.MaxDepositClaimFeeExceeded:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterString.allocationSize(inner.tx);size+=FfiConverterUInt32.allocationSize(inner.vout);size+=FfiConverterOptionalTypeFee.allocationSize(inner.maxFee);size+=FfiConverterUInt64.allocationSize(inner.requiredFeeSats);size+=FfiConverterUInt64.allocationSize(inner.requiredFeeRateSatPerVbyte);return size;}case DepositClaimError_Tags.MissingUtxo:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner.tx);size+=FfiConverterUInt32.allocationSize(inner.vout);return size;}case DepositClaimError_Tags.Generic:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterString.allocationSize(inner.message);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: ExternalSecretSource
export let ExternalSecretSource_Tags=/*#__PURE__*/function(ExternalSecretSource_Tags){ExternalSecretSource_Tags["Derived"]="Derived";ExternalSecretSource_Tags["Encrypted"]="Encrypted";return ExternalSecretSource_Tags;}({});/**
 * FFI-safe representation of `spark_wallet::SecretSource`
 */export const ExternalSecretSource=(()=>{/**
   * Private key derived from a tree node
   */class Derived_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ExternalSecretSource';tag=ExternalSecretSource_Tags.Derived;constructor(inner){super('ExternalSecretSource','Derived');this.inner=Object.freeze(inner);}static new(inner){return new Derived_(inner);}static instanceOf(obj){return obj.tag===ExternalSecretSource_Tags.Derived;}}/**
   * Encrypted private key
   */class Encrypted_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ExternalSecretSource';tag=ExternalSecretSource_Tags.Encrypted;constructor(inner){super('ExternalSecretSource','Encrypted');this.inner=Object.freeze(inner);}static new(inner){return new Encrypted_(inner);}static instanceOf(obj){return obj.tag===ExternalSecretSource_Tags.Encrypted;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='ExternalSecretSource';}return Object.freeze({instanceOf,Derived:Derived_,Encrypted:Encrypted_});})();/**
 * FFI-safe representation of `spark_wallet::SecretSource`
 */// FfiConverter for enum ExternalSecretSource
const FfiConverterTypeExternalSecretSource=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new ExternalSecretSource.Derived({nodeId:FfiConverterTypeExternalTreeNodeId.read(from)});case 2:return new ExternalSecretSource.Encrypted({key:FfiConverterTypeExternalEncryptedSecret.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case ExternalSecretSource_Tags.Derived:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterTypeExternalTreeNodeId.write(inner.nodeId,into);return;}case ExternalSecretSource_Tags.Encrypted:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterTypeExternalEncryptedSecret.write(inner.key,into);return;}default:// Throwing from here means that ExternalSecretSource_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case ExternalSecretSource_Tags.Derived:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterTypeExternalTreeNodeId.allocationSize(inner.nodeId);return size;}case ExternalSecretSource_Tags.Encrypted:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterTypeExternalEncryptedSecret.allocationSize(inner.key);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: ExternalSecretToSplit
export let ExternalSecretToSplit_Tags=/*#__PURE__*/function(ExternalSecretToSplit_Tags){ExternalSecretToSplit_Tags["SecretSource"]="SecretSource";ExternalSecretToSplit_Tags["Preimage"]="Preimage";return ExternalSecretToSplit_Tags;}({});/**
 * FFI-safe representation of `spark_wallet::SecretToSplit`
 */export const ExternalSecretToSplit=(()=>{/**
   * A secret source to split
   */class SecretSource_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ExternalSecretToSplit';tag=ExternalSecretToSplit_Tags.SecretSource;constructor(inner){super('ExternalSecretToSplit','SecretSource');this.inner=Object.freeze(inner);}static new(inner){return new SecretSource_(inner);}static instanceOf(obj){return obj.tag===ExternalSecretToSplit_Tags.SecretSource;}}/**
   * A preimage to split (32 bytes)
   */class Preimage_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ExternalSecretToSplit';tag=ExternalSecretToSplit_Tags.Preimage;constructor(inner){super('ExternalSecretToSplit','Preimage');this.inner=Object.freeze(inner);}static new(inner){return new Preimage_(inner);}static instanceOf(obj){return obj.tag===ExternalSecretToSplit_Tags.Preimage;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='ExternalSecretToSplit';}return Object.freeze({instanceOf,SecretSource:SecretSource_,Preimage:Preimage_});})();/**
 * FFI-safe representation of `spark_wallet::SecretToSplit`
 */// FfiConverter for enum ExternalSecretToSplit
const FfiConverterTypeExternalSecretToSplit=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new ExternalSecretToSplit.SecretSource({source:FfiConverterTypeExternalSecretSource.read(from)});case 2:return new ExternalSecretToSplit.Preimage({data:FfiConverterArrayBuffer.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case ExternalSecretToSplit_Tags.SecretSource:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterTypeExternalSecretSource.write(inner.source,into);return;}case ExternalSecretToSplit_Tags.Preimage:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterArrayBuffer.write(inner.data,into);return;}default:// Throwing from here means that ExternalSecretToSplit_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case ExternalSecretToSplit_Tags.SecretSource:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterTypeExternalSecretSource.allocationSize(inner.source);return size;}case ExternalSecretToSplit_Tags.Preimage:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterArrayBuffer.allocationSize(inner.data);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: Fee
export let Fee_Tags=/*#__PURE__*/function(Fee_Tags){Fee_Tags["Fixed"]="Fixed";Fee_Tags["Rate"]="Rate";return Fee_Tags;}({});export const Fee=(()=>{class Fixed_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='Fee';tag=Fee_Tags.Fixed;constructor(inner){super('Fee','Fixed');this.inner=Object.freeze(inner);}static new(inner){return new Fixed_(inner);}static instanceOf(obj){return obj.tag===Fee_Tags.Fixed;}}class Rate_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='Fee';tag=Fee_Tags.Rate;constructor(inner){super('Fee','Rate');this.inner=Object.freeze(inner);}static new(inner){return new Rate_(inner);}static instanceOf(obj){return obj.tag===Fee_Tags.Rate;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='Fee';}return Object.freeze({instanceOf,Fixed:Fixed_,Rate:Rate_});})();// FfiConverter for enum Fee
const FfiConverterTypeFee=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new Fee.Fixed({amount:FfiConverterUInt64.read(from)});case 2:return new Fee.Rate({satPerVbyte:FfiConverterUInt64.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case Fee_Tags.Fixed:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterUInt64.write(inner.amount,into);return;}case Fee_Tags.Rate:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterUInt64.write(inner.satPerVbyte,into);return;}default:// Throwing from here means that Fee_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case Fee_Tags.Fixed:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterUInt64.allocationSize(inner.amount);return size;}case Fee_Tags.Rate:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterUInt64.allocationSize(inner.satPerVbyte);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();/**
 * Specifies how fees are handled in a payment.
 */export let FeePolicy=/*#__PURE__*/function(FeePolicy){/**
   * Fees are added on top of the specified amount (default behavior).
   * The receiver gets the exact amount specified.
   */FeePolicy[FeePolicy["FeesExcluded"]=0]="FeesExcluded";/**
   * Fees are deducted from the specified amount.
   * The receiver gets the amount minus fees.
   */FeePolicy[FeePolicy["FeesIncluded"]=1]="FeesIncluded";return FeePolicy;}({});const FfiConverterTypeFeePolicy=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return FeePolicy.FeesExcluded;case 2:return FeePolicy.FeesIncluded;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case FeePolicy.FeesExcluded:return ordinalConverter.write(1,into);case FeePolicy.FeesIncluded:return ordinalConverter.write(2,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();// Enum: InputType
export let InputType_Tags=/*#__PURE__*/function(InputType_Tags){InputType_Tags["BitcoinAddress"]="BitcoinAddress";InputType_Tags["Bolt11Invoice"]="Bolt11Invoice";InputType_Tags["Bolt12Invoice"]="Bolt12Invoice";InputType_Tags["Bolt12Offer"]="Bolt12Offer";InputType_Tags["LightningAddress"]="LightningAddress";InputType_Tags["LnurlPay"]="LnurlPay";InputType_Tags["SilentPaymentAddress"]="SilentPaymentAddress";InputType_Tags["LnurlAuth"]="LnurlAuth";InputType_Tags["Url"]="Url";InputType_Tags["Bip21"]="Bip21";InputType_Tags["Bolt12InvoiceRequest"]="Bolt12InvoiceRequest";InputType_Tags["LnurlWithdraw"]="LnurlWithdraw";InputType_Tags["SparkAddress"]="SparkAddress";InputType_Tags["SparkInvoice"]="SparkInvoice";return InputType_Tags;}({});export const InputType=(()=>{class BitcoinAddress_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.BitcoinAddress;constructor(v0){super('InputType','BitcoinAddress');this.inner=Object.freeze([v0]);}static new(v0){return new BitcoinAddress_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.BitcoinAddress;}}class Bolt11Invoice_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.Bolt11Invoice;constructor(v0){super('InputType','Bolt11Invoice');this.inner=Object.freeze([v0]);}static new(v0){return new Bolt11Invoice_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.Bolt11Invoice;}}class Bolt12Invoice_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.Bolt12Invoice;constructor(v0){super('InputType','Bolt12Invoice');this.inner=Object.freeze([v0]);}static new(v0){return new Bolt12Invoice_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.Bolt12Invoice;}}class Bolt12Offer_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.Bolt12Offer;constructor(v0){super('InputType','Bolt12Offer');this.inner=Object.freeze([v0]);}static new(v0){return new Bolt12Offer_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.Bolt12Offer;}}class LightningAddress_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.LightningAddress;constructor(v0){super('InputType','LightningAddress');this.inner=Object.freeze([v0]);}static new(v0){return new LightningAddress_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.LightningAddress;}}class LnurlPay_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.LnurlPay;constructor(v0){super('InputType','LnurlPay');this.inner=Object.freeze([v0]);}static new(v0){return new LnurlPay_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.LnurlPay;}}class SilentPaymentAddress_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.SilentPaymentAddress;constructor(v0){super('InputType','SilentPaymentAddress');this.inner=Object.freeze([v0]);}static new(v0){return new SilentPaymentAddress_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.SilentPaymentAddress;}}class LnurlAuth_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.LnurlAuth;constructor(v0){super('InputType','LnurlAuth');this.inner=Object.freeze([v0]);}static new(v0){return new LnurlAuth_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.LnurlAuth;}}class Url_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.Url;constructor(v0){super('InputType','Url');this.inner=Object.freeze([v0]);}static new(v0){return new Url_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.Url;}}class Bip21_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.Bip21;constructor(v0){super('InputType','Bip21');this.inner=Object.freeze([v0]);}static new(v0){return new Bip21_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.Bip21;}}class Bolt12InvoiceRequest_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.Bolt12InvoiceRequest;constructor(v0){super('InputType','Bolt12InvoiceRequest');this.inner=Object.freeze([v0]);}static new(v0){return new Bolt12InvoiceRequest_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.Bolt12InvoiceRequest;}}class LnurlWithdraw_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.LnurlWithdraw;constructor(v0){super('InputType','LnurlWithdraw');this.inner=Object.freeze([v0]);}static new(v0){return new LnurlWithdraw_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.LnurlWithdraw;}}class SparkAddress_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.SparkAddress;constructor(v0){super('InputType','SparkAddress');this.inner=Object.freeze([v0]);}static new(v0){return new SparkAddress_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.SparkAddress;}}class SparkInvoice_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='InputType';tag=InputType_Tags.SparkInvoice;constructor(v0){super('InputType','SparkInvoice');this.inner=Object.freeze([v0]);}static new(v0){return new SparkInvoice_(v0);}static instanceOf(obj){return obj.tag===InputType_Tags.SparkInvoice;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='InputType';}return Object.freeze({instanceOf,BitcoinAddress:BitcoinAddress_,Bolt11Invoice:Bolt11Invoice_,Bolt12Invoice:Bolt12Invoice_,Bolt12Offer:Bolt12Offer_,LightningAddress:LightningAddress_,LnurlPay:LnurlPay_,SilentPaymentAddress:SilentPaymentAddress_,LnurlAuth:LnurlAuth_,Url:Url_,Bip21:Bip21_,Bolt12InvoiceRequest:Bolt12InvoiceRequest_,LnurlWithdraw:LnurlWithdraw_,SparkAddress:SparkAddress_,SparkInvoice:SparkInvoice_});})();// FfiConverter for enum InputType
const FfiConverterTypeInputType=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new InputType.BitcoinAddress(FfiConverterTypeBitcoinAddressDetails.read(from));case 2:return new InputType.Bolt11Invoice(FfiConverterTypeBolt11InvoiceDetails.read(from));case 3:return new InputType.Bolt12Invoice(FfiConverterTypeBolt12InvoiceDetails.read(from));case 4:return new InputType.Bolt12Offer(FfiConverterTypeBolt12OfferDetails.read(from));case 5:return new InputType.LightningAddress(FfiConverterTypeLightningAddressDetails.read(from));case 6:return new InputType.LnurlPay(FfiConverterTypeLnurlPayRequestDetails.read(from));case 7:return new InputType.SilentPaymentAddress(FfiConverterTypeSilentPaymentAddressDetails.read(from));case 8:return new InputType.LnurlAuth(FfiConverterTypeLnurlAuthRequestDetails.read(from));case 9:return new InputType.Url(FfiConverterString.read(from));case 10:return new InputType.Bip21(FfiConverterTypeBip21Details.read(from));case 11:return new InputType.Bolt12InvoiceRequest(FfiConverterTypeBolt12InvoiceRequestDetails.read(from));case 12:return new InputType.LnurlWithdraw(FfiConverterTypeLnurlWithdrawRequestDetails.read(from));case 13:return new InputType.SparkAddress(FfiConverterTypeSparkAddressDetails.read(from));case 14:return new InputType.SparkInvoice(FfiConverterTypeSparkInvoiceDetails.read(from));default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case InputType_Tags.BitcoinAddress:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterTypeBitcoinAddressDetails.write(inner[0],into);return;}case InputType_Tags.Bolt11Invoice:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterTypeBolt11InvoiceDetails.write(inner[0],into);return;}case InputType_Tags.Bolt12Invoice:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterTypeBolt12InvoiceDetails.write(inner[0],into);return;}case InputType_Tags.Bolt12Offer:{ordinalConverter.write(4,into);const inner=value.inner;FfiConverterTypeBolt12OfferDetails.write(inner[0],into);return;}case InputType_Tags.LightningAddress:{ordinalConverter.write(5,into);const inner=value.inner;FfiConverterTypeLightningAddressDetails.write(inner[0],into);return;}case InputType_Tags.LnurlPay:{ordinalConverter.write(6,into);const inner=value.inner;FfiConverterTypeLnurlPayRequestDetails.write(inner[0],into);return;}case InputType_Tags.SilentPaymentAddress:{ordinalConverter.write(7,into);const inner=value.inner;FfiConverterTypeSilentPaymentAddressDetails.write(inner[0],into);return;}case InputType_Tags.LnurlAuth:{ordinalConverter.write(8,into);const inner=value.inner;FfiConverterTypeLnurlAuthRequestDetails.write(inner[0],into);return;}case InputType_Tags.Url:{ordinalConverter.write(9,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case InputType_Tags.Bip21:{ordinalConverter.write(10,into);const inner=value.inner;FfiConverterTypeBip21Details.write(inner[0],into);return;}case InputType_Tags.Bolt12InvoiceRequest:{ordinalConverter.write(11,into);const inner=value.inner;FfiConverterTypeBolt12InvoiceRequestDetails.write(inner[0],into);return;}case InputType_Tags.LnurlWithdraw:{ordinalConverter.write(12,into);const inner=value.inner;FfiConverterTypeLnurlWithdrawRequestDetails.write(inner[0],into);return;}case InputType_Tags.SparkAddress:{ordinalConverter.write(13,into);const inner=value.inner;FfiConverterTypeSparkAddressDetails.write(inner[0],into);return;}case InputType_Tags.SparkInvoice:{ordinalConverter.write(14,into);const inner=value.inner;FfiConverterTypeSparkInvoiceDetails.write(inner[0],into);return;}default:// Throwing from here means that InputType_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case InputType_Tags.BitcoinAddress:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterTypeBitcoinAddressDetails.allocationSize(inner[0]);return size;}case InputType_Tags.Bolt11Invoice:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterTypeBolt11InvoiceDetails.allocationSize(inner[0]);return size;}case InputType_Tags.Bolt12Invoice:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterTypeBolt12InvoiceDetails.allocationSize(inner[0]);return size;}case InputType_Tags.Bolt12Offer:{const inner=value.inner;let size=ordinalConverter.allocationSize(4);size+=FfiConverterTypeBolt12OfferDetails.allocationSize(inner[0]);return size;}case InputType_Tags.LightningAddress:{const inner=value.inner;let size=ordinalConverter.allocationSize(5);size+=FfiConverterTypeLightningAddressDetails.allocationSize(inner[0]);return size;}case InputType_Tags.LnurlPay:{const inner=value.inner;let size=ordinalConverter.allocationSize(6);size+=FfiConverterTypeLnurlPayRequestDetails.allocationSize(inner[0]);return size;}case InputType_Tags.SilentPaymentAddress:{const inner=value.inner;let size=ordinalConverter.allocationSize(7);size+=FfiConverterTypeSilentPaymentAddressDetails.allocationSize(inner[0]);return size;}case InputType_Tags.LnurlAuth:{const inner=value.inner;let size=ordinalConverter.allocationSize(8);size+=FfiConverterTypeLnurlAuthRequestDetails.allocationSize(inner[0]);return size;}case InputType_Tags.Url:{const inner=value.inner;let size=ordinalConverter.allocationSize(9);size+=FfiConverterString.allocationSize(inner[0]);return size;}case InputType_Tags.Bip21:{const inner=value.inner;let size=ordinalConverter.allocationSize(10);size+=FfiConverterTypeBip21Details.allocationSize(inner[0]);return size;}case InputType_Tags.Bolt12InvoiceRequest:{const inner=value.inner;let size=ordinalConverter.allocationSize(11);size+=FfiConverterTypeBolt12InvoiceRequestDetails.allocationSize(inner[0]);return size;}case InputType_Tags.LnurlWithdraw:{const inner=value.inner;let size=ordinalConverter.allocationSize(12);size+=FfiConverterTypeLnurlWithdrawRequestDetails.allocationSize(inner[0]);return size;}case InputType_Tags.SparkAddress:{const inner=value.inner;let size=ordinalConverter.allocationSize(13);size+=FfiConverterTypeSparkAddressDetails.allocationSize(inner[0]);return size;}case InputType_Tags.SparkInvoice:{const inner=value.inner;let size=ordinalConverter.allocationSize(14);size+=FfiConverterTypeSparkInvoiceDetails.allocationSize(inner[0]);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();export let KeySetType=/*#__PURE__*/function(KeySetType){KeySetType[KeySetType["Default"]=0]="Default";KeySetType[KeySetType["Taproot"]=1]="Taproot";KeySetType[KeySetType["NativeSegwit"]=2]="NativeSegwit";KeySetType[KeySetType["WrappedSegwit"]=3]="WrappedSegwit";KeySetType[KeySetType["Legacy"]=4]="Legacy";return KeySetType;}({});const FfiConverterTypeKeySetType=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return KeySetType.Default;case 2:return KeySetType.Taproot;case 3:return KeySetType.NativeSegwit;case 4:return KeySetType.WrappedSegwit;case 5:return KeySetType.Legacy;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case KeySetType.Default:return ordinalConverter.write(1,into);case KeySetType.Taproot:return ordinalConverter.write(2,into);case KeySetType.NativeSegwit:return ordinalConverter.write(3,into);case KeySetType.WrappedSegwit:return ordinalConverter.write(4,into);case KeySetType.Legacy:return ordinalConverter.write(5,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();// Enum: LnurlCallbackStatus
export let LnurlCallbackStatus_Tags=/*#__PURE__*/function(LnurlCallbackStatus_Tags){LnurlCallbackStatus_Tags["Ok"]="Ok";LnurlCallbackStatus_Tags["ErrorStatus"]="ErrorStatus";return LnurlCallbackStatus_Tags;}({});/**
 * The response from a LNURL-auth callback, indicating success or failure.
 */export const LnurlCallbackStatus=(()=>{/**
   * On-wire format is: `{"status": "OK"}`
   */class Ok_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='LnurlCallbackStatus';tag=LnurlCallbackStatus_Tags.Ok;constructor(){super('LnurlCallbackStatus','Ok');}static new(){return new Ok_();}static instanceOf(obj){return obj.tag===LnurlCallbackStatus_Tags.Ok;}}/**
   * On-wire format is: `{"status": "ERROR", "reason": "error details..."}`
   */class ErrorStatus_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='LnurlCallbackStatus';tag=LnurlCallbackStatus_Tags.ErrorStatus;constructor(inner){super('LnurlCallbackStatus','ErrorStatus');this.inner=Object.freeze(inner);}static new(inner){return new ErrorStatus_(inner);}static instanceOf(obj){return obj.tag===LnurlCallbackStatus_Tags.ErrorStatus;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='LnurlCallbackStatus';}return Object.freeze({instanceOf,Ok:Ok_,ErrorStatus:ErrorStatus_});})();/**
 * The response from a LNURL-auth callback, indicating success or failure.
 */// FfiConverter for enum LnurlCallbackStatus
const FfiConverterTypeLnurlCallbackStatus=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new LnurlCallbackStatus.Ok();case 2:return new LnurlCallbackStatus.ErrorStatus({errorDetails:FfiConverterTypeLnurlErrorDetails.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case LnurlCallbackStatus_Tags.Ok:{ordinalConverter.write(1,into);return;}case LnurlCallbackStatus_Tags.ErrorStatus:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterTypeLnurlErrorDetails.write(inner.errorDetails,into);return;}default:// Throwing from here means that LnurlCallbackStatus_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case LnurlCallbackStatus_Tags.Ok:{return ordinalConverter.allocationSize(1);}case LnurlCallbackStatus_Tags.ErrorStatus:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterTypeLnurlErrorDetails.allocationSize(inner.errorDetails);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: MaxFee
export let MaxFee_Tags=/*#__PURE__*/function(MaxFee_Tags){MaxFee_Tags["Fixed"]="Fixed";MaxFee_Tags["Rate"]="Rate";MaxFee_Tags["NetworkRecommended"]="NetworkRecommended";return MaxFee_Tags;}({});export const MaxFee=(()=>{class Fixed_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='MaxFee';tag=MaxFee_Tags.Fixed;constructor(inner){super('MaxFee','Fixed');this.inner=Object.freeze(inner);}static new(inner){return new Fixed_(inner);}static instanceOf(obj){return obj.tag===MaxFee_Tags.Fixed;}}class Rate_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='MaxFee';tag=MaxFee_Tags.Rate;constructor(inner){super('MaxFee','Rate');this.inner=Object.freeze(inner);}static new(inner){return new Rate_(inner);}static instanceOf(obj){return obj.tag===MaxFee_Tags.Rate;}}class NetworkRecommended_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='MaxFee';tag=MaxFee_Tags.NetworkRecommended;constructor(inner){super('MaxFee','NetworkRecommended');this.inner=Object.freeze(inner);}static new(inner){return new NetworkRecommended_(inner);}static instanceOf(obj){return obj.tag===MaxFee_Tags.NetworkRecommended;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='MaxFee';}return Object.freeze({instanceOf,Fixed:Fixed_,Rate:Rate_,NetworkRecommended:NetworkRecommended_});})();// FfiConverter for enum MaxFee
const FfiConverterTypeMaxFee=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new MaxFee.Fixed({amount:FfiConverterUInt64.read(from)});case 2:return new MaxFee.Rate({satPerVbyte:FfiConverterUInt64.read(from)});case 3:return new MaxFee.NetworkRecommended({leewaySatPerVbyte:FfiConverterUInt64.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case MaxFee_Tags.Fixed:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterUInt64.write(inner.amount,into);return;}case MaxFee_Tags.Rate:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterUInt64.write(inner.satPerVbyte,into);return;}case MaxFee_Tags.NetworkRecommended:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterUInt64.write(inner.leewaySatPerVbyte,into);return;}default:// Throwing from here means that MaxFee_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case MaxFee_Tags.Fixed:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterUInt64.allocationSize(inner.amount);return size;}case MaxFee_Tags.Rate:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterUInt64.allocationSize(inner.satPerVbyte);return size;}case MaxFee_Tags.NetworkRecommended:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterUInt64.allocationSize(inner.leewaySatPerVbyte);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();export let Network=/*#__PURE__*/function(Network){Network[Network["Mainnet"]=0]="Mainnet";Network[Network["Regtest"]=1]="Regtest";return Network;}({});const FfiConverterTypeNetwork=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return Network.Mainnet;case 2:return Network.Regtest;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case Network.Mainnet:return ordinalConverter.write(1,into);case Network.Regtest:return ordinalConverter.write(2,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();export let OnchainConfirmationSpeed=/*#__PURE__*/function(OnchainConfirmationSpeed){OnchainConfirmationSpeed[OnchainConfirmationSpeed["Fast"]=0]="Fast";OnchainConfirmationSpeed[OnchainConfirmationSpeed["Medium"]=1]="Medium";OnchainConfirmationSpeed[OnchainConfirmationSpeed["Slow"]=2]="Slow";return OnchainConfirmationSpeed;}({});const FfiConverterTypeOnchainConfirmationSpeed=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return OnchainConfirmationSpeed.Fast;case 2:return OnchainConfirmationSpeed.Medium;case 3:return OnchainConfirmationSpeed.Slow;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case OnchainConfirmationSpeed.Fast:return ordinalConverter.write(1,into);case OnchainConfirmationSpeed.Medium:return ordinalConverter.write(2,into);case OnchainConfirmationSpeed.Slow:return ordinalConverter.write(3,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();// Enum: OptimizationEvent
export let OptimizationEvent_Tags=/*#__PURE__*/function(OptimizationEvent_Tags){OptimizationEvent_Tags["Started"]="Started";OptimizationEvent_Tags["RoundCompleted"]="RoundCompleted";OptimizationEvent_Tags["Completed"]="Completed";OptimizationEvent_Tags["Cancelled"]="Cancelled";OptimizationEvent_Tags["Failed"]="Failed";OptimizationEvent_Tags["Skipped"]="Skipped";return OptimizationEvent_Tags;}({});export const OptimizationEvent=(()=>{/**
   * Optimization has started with the given number of rounds.
   */class Started_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='OptimizationEvent';tag=OptimizationEvent_Tags.Started;constructor(inner){super('OptimizationEvent','Started');this.inner=Object.freeze(inner);}static new(inner){return new Started_(inner);}static instanceOf(obj){return obj.tag===OptimizationEvent_Tags.Started;}}/**
   * A round has completed.
   */class RoundCompleted_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='OptimizationEvent';tag=OptimizationEvent_Tags.RoundCompleted;constructor(inner){super('OptimizationEvent','RoundCompleted');this.inner=Object.freeze(inner);}static new(inner){return new RoundCompleted_(inner);}static instanceOf(obj){return obj.tag===OptimizationEvent_Tags.RoundCompleted;}}/**
   * Optimization completed successfully.
   */class Completed_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='OptimizationEvent';tag=OptimizationEvent_Tags.Completed;constructor(){super('OptimizationEvent','Completed');}static new(){return new Completed_();}static instanceOf(obj){return obj.tag===OptimizationEvent_Tags.Completed;}}/**
   * Optimization was cancelled.
   */class Cancelled_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='OptimizationEvent';tag=OptimizationEvent_Tags.Cancelled;constructor(){super('OptimizationEvent','Cancelled');}static new(){return new Cancelled_();}static instanceOf(obj){return obj.tag===OptimizationEvent_Tags.Cancelled;}}/**
   * Optimization failed with an error.
   */class Failed_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='OptimizationEvent';tag=OptimizationEvent_Tags.Failed;constructor(inner){super('OptimizationEvent','Failed');this.inner=Object.freeze(inner);}static new(inner){return new Failed_(inner);}static instanceOf(obj){return obj.tag===OptimizationEvent_Tags.Failed;}}/**
   * Optimization was skipped because leaves are already optimal.
   */class Skipped_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='OptimizationEvent';tag=OptimizationEvent_Tags.Skipped;constructor(){super('OptimizationEvent','Skipped');}static new(){return new Skipped_();}static instanceOf(obj){return obj.tag===OptimizationEvent_Tags.Skipped;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='OptimizationEvent';}return Object.freeze({instanceOf,Started:Started_,RoundCompleted:RoundCompleted_,Completed:Completed_,Cancelled:Cancelled_,Failed:Failed_,Skipped:Skipped_});})();// FfiConverter for enum OptimizationEvent
const FfiConverterTypeOptimizationEvent=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new OptimizationEvent.Started({totalRounds:FfiConverterUInt32.read(from)});case 2:return new OptimizationEvent.RoundCompleted({currentRound:FfiConverterUInt32.read(from),totalRounds:FfiConverterUInt32.read(from)});case 3:return new OptimizationEvent.Completed();case 4:return new OptimizationEvent.Cancelled();case 5:return new OptimizationEvent.Failed({error:FfiConverterString.read(from)});case 6:return new OptimizationEvent.Skipped();default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case OptimizationEvent_Tags.Started:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterUInt32.write(inner.totalRounds,into);return;}case OptimizationEvent_Tags.RoundCompleted:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterUInt32.write(inner.currentRound,into);FfiConverterUInt32.write(inner.totalRounds,into);return;}case OptimizationEvent_Tags.Completed:{ordinalConverter.write(3,into);return;}case OptimizationEvent_Tags.Cancelled:{ordinalConverter.write(4,into);return;}case OptimizationEvent_Tags.Failed:{ordinalConverter.write(5,into);const inner=value.inner;FfiConverterString.write(inner.error,into);return;}case OptimizationEvent_Tags.Skipped:{ordinalConverter.write(6,into);return;}default:// Throwing from here means that OptimizationEvent_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case OptimizationEvent_Tags.Started:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterUInt32.allocationSize(inner.totalRounds);return size;}case OptimizationEvent_Tags.RoundCompleted:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterUInt32.allocationSize(inner.currentRound);size+=FfiConverterUInt32.allocationSize(inner.totalRounds);return size;}case OptimizationEvent_Tags.Completed:{return ordinalConverter.allocationSize(3);}case OptimizationEvent_Tags.Cancelled:{return ordinalConverter.allocationSize(4);}case OptimizationEvent_Tags.Failed:{const inner=value.inner;let size=ordinalConverter.allocationSize(5);size+=FfiConverterString.allocationSize(inner.error);return size;}case OptimizationEvent_Tags.Skipped:{return ordinalConverter.allocationSize(6);}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: PaymentDetails
export let PaymentDetails_Tags=/*#__PURE__*/function(PaymentDetails_Tags){PaymentDetails_Tags["Spark"]="Spark";PaymentDetails_Tags["Token"]="Token";PaymentDetails_Tags["Lightning"]="Lightning";PaymentDetails_Tags["Withdraw"]="Withdraw";PaymentDetails_Tags["Deposit"]="Deposit";return PaymentDetails_Tags;}({});export const PaymentDetails=(()=>{class Spark_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='PaymentDetails';tag=PaymentDetails_Tags.Spark;constructor(inner){super('PaymentDetails','Spark');this.inner=Object.freeze(inner);}static new(inner){return new Spark_(inner);}static instanceOf(obj){return obj.tag===PaymentDetails_Tags.Spark;}}class Token_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='PaymentDetails';tag=PaymentDetails_Tags.Token;constructor(inner){super('PaymentDetails','Token');this.inner=Object.freeze(inner);}static new(inner){return new Token_(inner);}static instanceOf(obj){return obj.tag===PaymentDetails_Tags.Token;}}class Lightning_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='PaymentDetails';tag=PaymentDetails_Tags.Lightning;constructor(inner){super('PaymentDetails','Lightning');this.inner=Object.freeze(inner);}static new(inner){return new Lightning_(inner);}static instanceOf(obj){return obj.tag===PaymentDetails_Tags.Lightning;}}class Withdraw_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='PaymentDetails';tag=PaymentDetails_Tags.Withdraw;constructor(inner){super('PaymentDetails','Withdraw');this.inner=Object.freeze(inner);}static new(inner){return new Withdraw_(inner);}static instanceOf(obj){return obj.tag===PaymentDetails_Tags.Withdraw;}}class Deposit_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='PaymentDetails';tag=PaymentDetails_Tags.Deposit;constructor(inner){super('PaymentDetails','Deposit');this.inner=Object.freeze(inner);}static new(inner){return new Deposit_(inner);}static instanceOf(obj){return obj.tag===PaymentDetails_Tags.Deposit;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='PaymentDetails';}return Object.freeze({instanceOf,Spark:Spark_,Token:Token_,Lightning:Lightning_,Withdraw:Withdraw_,Deposit:Deposit_});})();// FfiConverter for enum PaymentDetails
const FfiConverterTypePaymentDetails=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new PaymentDetails.Spark({invoiceDetails:FfiConverterOptionalTypeSparkInvoicePaymentDetails.read(from),htlcDetails:FfiConverterOptionalTypeSparkHtlcDetails.read(from),conversionInfo:FfiConverterOptionalTypeConversionInfo.read(from)});case 2:return new PaymentDetails.Token({metadata:FfiConverterTypeTokenMetadata.read(from),txHash:FfiConverterString.read(from),txType:FfiConverterTypeTokenTransactionType.read(from),invoiceDetails:FfiConverterOptionalTypeSparkInvoicePaymentDetails.read(from),conversionInfo:FfiConverterOptionalTypeConversionInfo.read(from)});case 3:return new PaymentDetails.Lightning({description:FfiConverterOptionalString.read(from),preimage:FfiConverterOptionalString.read(from),invoice:FfiConverterString.read(from),paymentHash:FfiConverterString.read(from),destinationPubkey:FfiConverterString.read(from),lnurlPayInfo:FfiConverterOptionalTypeLnurlPayInfo.read(from),lnurlWithdrawInfo:FfiConverterOptionalTypeLnurlWithdrawInfo.read(from),lnurlReceiveMetadata:FfiConverterOptionalTypeLnurlReceiveMetadata.read(from)});case 4:return new PaymentDetails.Withdraw({txId:FfiConverterString.read(from)});case 5:return new PaymentDetails.Deposit({txId:FfiConverterString.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case PaymentDetails_Tags.Spark:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterOptionalTypeSparkInvoicePaymentDetails.write(inner.invoiceDetails,into);FfiConverterOptionalTypeSparkHtlcDetails.write(inner.htlcDetails,into);FfiConverterOptionalTypeConversionInfo.write(inner.conversionInfo,into);return;}case PaymentDetails_Tags.Token:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterTypeTokenMetadata.write(inner.metadata,into);FfiConverterString.write(inner.txHash,into);FfiConverterTypeTokenTransactionType.write(inner.txType,into);FfiConverterOptionalTypeSparkInvoicePaymentDetails.write(inner.invoiceDetails,into);FfiConverterOptionalTypeConversionInfo.write(inner.conversionInfo,into);return;}case PaymentDetails_Tags.Lightning:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterOptionalString.write(inner.description,into);FfiConverterOptionalString.write(inner.preimage,into);FfiConverterString.write(inner.invoice,into);FfiConverterString.write(inner.paymentHash,into);FfiConverterString.write(inner.destinationPubkey,into);FfiConverterOptionalTypeLnurlPayInfo.write(inner.lnurlPayInfo,into);FfiConverterOptionalTypeLnurlWithdrawInfo.write(inner.lnurlWithdrawInfo,into);FfiConverterOptionalTypeLnurlReceiveMetadata.write(inner.lnurlReceiveMetadata,into);return;}case PaymentDetails_Tags.Withdraw:{ordinalConverter.write(4,into);const inner=value.inner;FfiConverterString.write(inner.txId,into);return;}case PaymentDetails_Tags.Deposit:{ordinalConverter.write(5,into);const inner=value.inner;FfiConverterString.write(inner.txId,into);return;}default:// Throwing from here means that PaymentDetails_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case PaymentDetails_Tags.Spark:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterOptionalTypeSparkInvoicePaymentDetails.allocationSize(inner.invoiceDetails);size+=FfiConverterOptionalTypeSparkHtlcDetails.allocationSize(inner.htlcDetails);size+=FfiConverterOptionalTypeConversionInfo.allocationSize(inner.conversionInfo);return size;}case PaymentDetails_Tags.Token:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterTypeTokenMetadata.allocationSize(inner.metadata);size+=FfiConverterString.allocationSize(inner.txHash);size+=FfiConverterTypeTokenTransactionType.allocationSize(inner.txType);size+=FfiConverterOptionalTypeSparkInvoicePaymentDetails.allocationSize(inner.invoiceDetails);size+=FfiConverterOptionalTypeConversionInfo.allocationSize(inner.conversionInfo);return size;}case PaymentDetails_Tags.Lightning:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterOptionalString.allocationSize(inner.description);size+=FfiConverterOptionalString.allocationSize(inner.preimage);size+=FfiConverterString.allocationSize(inner.invoice);size+=FfiConverterString.allocationSize(inner.paymentHash);size+=FfiConverterString.allocationSize(inner.destinationPubkey);size+=FfiConverterOptionalTypeLnurlPayInfo.allocationSize(inner.lnurlPayInfo);size+=FfiConverterOptionalTypeLnurlWithdrawInfo.allocationSize(inner.lnurlWithdrawInfo);size+=FfiConverterOptionalTypeLnurlReceiveMetadata.allocationSize(inner.lnurlReceiveMetadata);return size;}case PaymentDetails_Tags.Withdraw:{const inner=value.inner;let size=ordinalConverter.allocationSize(4);size+=FfiConverterString.allocationSize(inner.txId);return size;}case PaymentDetails_Tags.Deposit:{const inner=value.inner;let size=ordinalConverter.allocationSize(5);size+=FfiConverterString.allocationSize(inner.txId);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: PaymentDetailsFilter
export let PaymentDetailsFilter_Tags=/*#__PURE__*/function(PaymentDetailsFilter_Tags){PaymentDetailsFilter_Tags["Spark"]="Spark";PaymentDetailsFilter_Tags["Token"]="Token";return PaymentDetailsFilter_Tags;}({});export const PaymentDetailsFilter=(()=>{class Spark_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='PaymentDetailsFilter';tag=PaymentDetailsFilter_Tags.Spark;constructor(inner){super('PaymentDetailsFilter','Spark');this.inner=Object.freeze(inner);}static new(inner){return new Spark_(inner);}static instanceOf(obj){return obj.tag===PaymentDetailsFilter_Tags.Spark;}}class Token_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='PaymentDetailsFilter';tag=PaymentDetailsFilter_Tags.Token;constructor(inner){super('PaymentDetailsFilter','Token');this.inner=Object.freeze(inner);}static new(inner){return new Token_(inner);}static instanceOf(obj){return obj.tag===PaymentDetailsFilter_Tags.Token;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='PaymentDetailsFilter';}return Object.freeze({instanceOf,Spark:Spark_,Token:Token_});})();// FfiConverter for enum PaymentDetailsFilter
const FfiConverterTypePaymentDetailsFilter=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new PaymentDetailsFilter.Spark({htlcStatus:FfiConverterOptionalArrayTypeSparkHtlcStatus.read(from),conversionRefundNeeded:FfiConverterOptionalBool.read(from)});case 2:return new PaymentDetailsFilter.Token({conversionRefundNeeded:FfiConverterOptionalBool.read(from),txHash:FfiConverterOptionalString.read(from),txType:FfiConverterOptionalTypeTokenTransactionType.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case PaymentDetailsFilter_Tags.Spark:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterOptionalArrayTypeSparkHtlcStatus.write(inner.htlcStatus,into);FfiConverterOptionalBool.write(inner.conversionRefundNeeded,into);return;}case PaymentDetailsFilter_Tags.Token:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterOptionalBool.write(inner.conversionRefundNeeded,into);FfiConverterOptionalString.write(inner.txHash,into);FfiConverterOptionalTypeTokenTransactionType.write(inner.txType,into);return;}default:// Throwing from here means that PaymentDetailsFilter_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case PaymentDetailsFilter_Tags.Spark:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterOptionalArrayTypeSparkHtlcStatus.allocationSize(inner.htlcStatus);size+=FfiConverterOptionalBool.allocationSize(inner.conversionRefundNeeded);return size;}case PaymentDetailsFilter_Tags.Token:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterOptionalBool.allocationSize(inner.conversionRefundNeeded);size+=FfiConverterOptionalString.allocationSize(inner.txHash);size+=FfiConverterOptionalTypeTokenTransactionType.allocationSize(inner.txType);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();export let PaymentMethod=/*#__PURE__*/function(PaymentMethod){PaymentMethod[PaymentMethod["Lightning"]=0]="Lightning";PaymentMethod[PaymentMethod["Spark"]=1]="Spark";PaymentMethod[PaymentMethod["Token"]=2]="Token";PaymentMethod[PaymentMethod["Deposit"]=3]="Deposit";PaymentMethod[PaymentMethod["Withdraw"]=4]="Withdraw";PaymentMethod[PaymentMethod["Unknown"]=5]="Unknown";return PaymentMethod;}({});const FfiConverterTypePaymentMethod=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return PaymentMethod.Lightning;case 2:return PaymentMethod.Spark;case 3:return PaymentMethod.Token;case 4:return PaymentMethod.Deposit;case 5:return PaymentMethod.Withdraw;case 6:return PaymentMethod.Unknown;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case PaymentMethod.Lightning:return ordinalConverter.write(1,into);case PaymentMethod.Spark:return ordinalConverter.write(2,into);case PaymentMethod.Token:return ordinalConverter.write(3,into);case PaymentMethod.Deposit:return ordinalConverter.write(4,into);case PaymentMethod.Withdraw:return ordinalConverter.write(5,into);case PaymentMethod.Unknown:return ordinalConverter.write(6,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();// Error type: PaymentObserverError
// Enum: PaymentObserverError
export let PaymentObserverError_Tags=/*#__PURE__*/function(PaymentObserverError_Tags){PaymentObserverError_Tags["ServiceConnectivity"]="ServiceConnectivity";PaymentObserverError_Tags["Generic"]="Generic";return PaymentObserverError_Tags;}({});export const PaymentObserverError=(()=>{class ServiceConnectivity_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='PaymentObserverError';tag=PaymentObserverError_Tags.ServiceConnectivity;constructor(v0){super('PaymentObserverError','ServiceConnectivity');this.inner=Object.freeze([v0]);}static new(v0){return new ServiceConnectivity_(v0);}static instanceOf(obj){return obj.tag===PaymentObserverError_Tags.ServiceConnectivity;}static hasInner(obj){return ServiceConnectivity_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Generic_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='PaymentObserverError';tag=PaymentObserverError_Tags.Generic;constructor(v0){super('PaymentObserverError','Generic');this.inner=Object.freeze([v0]);}static new(v0){return new Generic_(v0);}static instanceOf(obj){return obj.tag===PaymentObserverError_Tags.Generic;}static hasInner(obj){return Generic_.instanceOf(obj);}static getInner(obj){return obj.inner;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='PaymentObserverError';}return Object.freeze({instanceOf,ServiceConnectivity:ServiceConnectivity_,Generic:Generic_});})();// FfiConverter for enum PaymentObserverError
const FfiConverterTypePaymentObserverError=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new PaymentObserverError.ServiceConnectivity(FfiConverterString.read(from));case 2:return new PaymentObserverError.Generic(FfiConverterString.read(from));default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case PaymentObserverError_Tags.ServiceConnectivity:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case PaymentObserverError_Tags.Generic:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}default:// Throwing from here means that PaymentObserverError_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case PaymentObserverError_Tags.ServiceConnectivity:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterString.allocationSize(inner[0]);return size;}case PaymentObserverError_Tags.Generic:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner[0]);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();/**
 * The status of a payment
 */export let PaymentStatus=/*#__PURE__*/function(PaymentStatus){/**
   * Payment is completed successfully
   */PaymentStatus[PaymentStatus["Completed"]=0]="Completed";/**
   * Payment is in progress
   */PaymentStatus[PaymentStatus["Pending"]=1]="Pending";/**
   * Payment has failed
   */PaymentStatus[PaymentStatus["Failed"]=2]="Failed";return PaymentStatus;}({});const FfiConverterTypePaymentStatus=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return PaymentStatus.Completed;case 2:return PaymentStatus.Pending;case 3:return PaymentStatus.Failed;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case PaymentStatus.Completed:return ordinalConverter.write(1,into);case PaymentStatus.Pending:return ordinalConverter.write(2,into);case PaymentStatus.Failed:return ordinalConverter.write(3,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();/**
 * The type of payment
 */export let PaymentType=/*#__PURE__*/function(PaymentType){/**
   * Payment sent from this wallet
   */PaymentType[PaymentType["Send"]=0]="Send";/**
   * Payment received to this wallet
   */PaymentType[PaymentType["Receive"]=1]="Receive";return PaymentType;}({});const FfiConverterTypePaymentType=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return PaymentType.Send;case 2:return PaymentType.Receive;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case PaymentType.Send:return ordinalConverter.write(1,into);case PaymentType.Receive:return ordinalConverter.write(2,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();// Enum: ProvisionalPaymentDetails
export let ProvisionalPaymentDetails_Tags=/*#__PURE__*/function(ProvisionalPaymentDetails_Tags){ProvisionalPaymentDetails_Tags["Bitcoin"]="Bitcoin";ProvisionalPaymentDetails_Tags["Lightning"]="Lightning";ProvisionalPaymentDetails_Tags["Spark"]="Spark";ProvisionalPaymentDetails_Tags["Token"]="Token";return ProvisionalPaymentDetails_Tags;}({});export const ProvisionalPaymentDetails=(()=>{class Bitcoin_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ProvisionalPaymentDetails';tag=ProvisionalPaymentDetails_Tags.Bitcoin;constructor(inner){super('ProvisionalPaymentDetails','Bitcoin');this.inner=Object.freeze(inner);}static new(inner){return new Bitcoin_(inner);}static instanceOf(obj){return obj.tag===ProvisionalPaymentDetails_Tags.Bitcoin;}}class Lightning_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ProvisionalPaymentDetails';tag=ProvisionalPaymentDetails_Tags.Lightning;constructor(inner){super('ProvisionalPaymentDetails','Lightning');this.inner=Object.freeze(inner);}static new(inner){return new Lightning_(inner);}static instanceOf(obj){return obj.tag===ProvisionalPaymentDetails_Tags.Lightning;}}class Spark_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ProvisionalPaymentDetails';tag=ProvisionalPaymentDetails_Tags.Spark;constructor(inner){super('ProvisionalPaymentDetails','Spark');this.inner=Object.freeze(inner);}static new(inner){return new Spark_(inner);}static instanceOf(obj){return obj.tag===ProvisionalPaymentDetails_Tags.Spark;}}class Token_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ProvisionalPaymentDetails';tag=ProvisionalPaymentDetails_Tags.Token;constructor(inner){super('ProvisionalPaymentDetails','Token');this.inner=Object.freeze(inner);}static new(inner){return new Token_(inner);}static instanceOf(obj){return obj.tag===ProvisionalPaymentDetails_Tags.Token;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='ProvisionalPaymentDetails';}return Object.freeze({instanceOf,Bitcoin:Bitcoin_,Lightning:Lightning_,Spark:Spark_,Token:Token_});})();// FfiConverter for enum ProvisionalPaymentDetails
const FfiConverterTypeProvisionalPaymentDetails=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new ProvisionalPaymentDetails.Bitcoin({withdrawalAddress:FfiConverterString.read(from)});case 2:return new ProvisionalPaymentDetails.Lightning({invoice:FfiConverterString.read(from)});case 3:return new ProvisionalPaymentDetails.Spark({payRequest:FfiConverterString.read(from)});case 4:return new ProvisionalPaymentDetails.Token({tokenId:FfiConverterString.read(from),payRequest:FfiConverterString.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case ProvisionalPaymentDetails_Tags.Bitcoin:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterString.write(inner.withdrawalAddress,into);return;}case ProvisionalPaymentDetails_Tags.Lightning:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner.invoice,into);return;}case ProvisionalPaymentDetails_Tags.Spark:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterString.write(inner.payRequest,into);return;}case ProvisionalPaymentDetails_Tags.Token:{ordinalConverter.write(4,into);const inner=value.inner;FfiConverterString.write(inner.tokenId,into);FfiConverterString.write(inner.payRequest,into);return;}default:// Throwing from here means that ProvisionalPaymentDetails_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case ProvisionalPaymentDetails_Tags.Bitcoin:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterString.allocationSize(inner.withdrawalAddress);return size;}case ProvisionalPaymentDetails_Tags.Lightning:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner.invoice);return size;}case ProvisionalPaymentDetails_Tags.Spark:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterString.allocationSize(inner.payRequest);return size;}case ProvisionalPaymentDetails_Tags.Token:{const inner=value.inner;let size=ordinalConverter.allocationSize(4);size+=FfiConverterString.allocationSize(inner.tokenId);size+=FfiConverterString.allocationSize(inner.payRequest);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: ReceivePaymentMethod
export let ReceivePaymentMethod_Tags=/*#__PURE__*/function(ReceivePaymentMethod_Tags){ReceivePaymentMethod_Tags["SparkAddress"]="SparkAddress";ReceivePaymentMethod_Tags["SparkInvoice"]="SparkInvoice";ReceivePaymentMethod_Tags["BitcoinAddress"]="BitcoinAddress";ReceivePaymentMethod_Tags["Bolt11Invoice"]="Bolt11Invoice";return ReceivePaymentMethod_Tags;}({});export const ReceivePaymentMethod=(()=>{class SparkAddress_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ReceivePaymentMethod';tag=ReceivePaymentMethod_Tags.SparkAddress;constructor(){super('ReceivePaymentMethod','SparkAddress');}static new(){return new SparkAddress_();}static instanceOf(obj){return obj.tag===ReceivePaymentMethod_Tags.SparkAddress;}}class SparkInvoice_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ReceivePaymentMethod';tag=ReceivePaymentMethod_Tags.SparkInvoice;constructor(inner){super('ReceivePaymentMethod','SparkInvoice');this.inner=Object.freeze(inner);}static new(inner){return new SparkInvoice_(inner);}static instanceOf(obj){return obj.tag===ReceivePaymentMethod_Tags.SparkInvoice;}}class BitcoinAddress_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ReceivePaymentMethod';tag=ReceivePaymentMethod_Tags.BitcoinAddress;constructor(){super('ReceivePaymentMethod','BitcoinAddress');}static new(){return new BitcoinAddress_();}static instanceOf(obj){return obj.tag===ReceivePaymentMethod_Tags.BitcoinAddress;}}class Bolt11Invoice_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ReceivePaymentMethod';tag=ReceivePaymentMethod_Tags.Bolt11Invoice;constructor(inner){super('ReceivePaymentMethod','Bolt11Invoice');this.inner=Object.freeze(inner);}static new(inner){return new Bolt11Invoice_(inner);}static instanceOf(obj){return obj.tag===ReceivePaymentMethod_Tags.Bolt11Invoice;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='ReceivePaymentMethod';}return Object.freeze({instanceOf,SparkAddress:SparkAddress_,SparkInvoice:SparkInvoice_,BitcoinAddress:BitcoinAddress_,Bolt11Invoice:Bolt11Invoice_});})();// FfiConverter for enum ReceivePaymentMethod
const FfiConverterTypeReceivePaymentMethod=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new ReceivePaymentMethod.SparkAddress();case 2:return new ReceivePaymentMethod.SparkInvoice({amount:FfiConverterOptionalTypeu128.read(from),tokenIdentifier:FfiConverterOptionalString.read(from),expiryTime:FfiConverterOptionalUInt64.read(from),description:FfiConverterOptionalString.read(from),senderPublicKey:FfiConverterOptionalString.read(from)});case 3:return new ReceivePaymentMethod.BitcoinAddress();case 4:return new ReceivePaymentMethod.Bolt11Invoice({description:FfiConverterString.read(from),amountSats:FfiConverterOptionalUInt64.read(from),expirySecs:FfiConverterOptionalUInt32.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case ReceivePaymentMethod_Tags.SparkAddress:{ordinalConverter.write(1,into);return;}case ReceivePaymentMethod_Tags.SparkInvoice:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterOptionalTypeu128.write(inner.amount,into);FfiConverterOptionalString.write(inner.tokenIdentifier,into);FfiConverterOptionalUInt64.write(inner.expiryTime,into);FfiConverterOptionalString.write(inner.description,into);FfiConverterOptionalString.write(inner.senderPublicKey,into);return;}case ReceivePaymentMethod_Tags.BitcoinAddress:{ordinalConverter.write(3,into);return;}case ReceivePaymentMethod_Tags.Bolt11Invoice:{ordinalConverter.write(4,into);const inner=value.inner;FfiConverterString.write(inner.description,into);FfiConverterOptionalUInt64.write(inner.amountSats,into);FfiConverterOptionalUInt32.write(inner.expirySecs,into);return;}default:// Throwing from here means that ReceivePaymentMethod_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case ReceivePaymentMethod_Tags.SparkAddress:{return ordinalConverter.allocationSize(1);}case ReceivePaymentMethod_Tags.SparkInvoice:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterOptionalTypeu128.allocationSize(inner.amount);size+=FfiConverterOptionalString.allocationSize(inner.tokenIdentifier);size+=FfiConverterOptionalUInt64.allocationSize(inner.expiryTime);size+=FfiConverterOptionalString.allocationSize(inner.description);size+=FfiConverterOptionalString.allocationSize(inner.senderPublicKey);return size;}case ReceivePaymentMethod_Tags.BitcoinAddress:{return ordinalConverter.allocationSize(3);}case ReceivePaymentMethod_Tags.Bolt11Invoice:{const inner=value.inner;let size=ordinalConverter.allocationSize(4);size+=FfiConverterString.allocationSize(inner.description);size+=FfiConverterOptionalUInt64.allocationSize(inner.amountSats);size+=FfiConverterOptionalUInt32.allocationSize(inner.expirySecs);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Error type: SdkError
// Enum: SdkError
export let SdkError_Tags=/*#__PURE__*/function(SdkError_Tags){SdkError_Tags["SparkError"]="SparkError";SdkError_Tags["InsufficientFunds"]="InsufficientFunds";SdkError_Tags["InvalidUuid"]="InvalidUuid";SdkError_Tags["InvalidInput"]="InvalidInput";SdkError_Tags["NetworkError"]="NetworkError";SdkError_Tags["StorageError"]="StorageError";SdkError_Tags["ChainServiceError"]="ChainServiceError";SdkError_Tags["MaxDepositClaimFeeExceeded"]="MaxDepositClaimFeeExceeded";SdkError_Tags["MissingUtxo"]="MissingUtxo";SdkError_Tags["LnurlError"]="LnurlError";SdkError_Tags["Signer"]="Signer";SdkError_Tags["Generic"]="Generic";return SdkError_Tags;}({});/**
 * Error type for the `BreezSdk`
 */export const SdkError=(()=>{class SparkError_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.SparkError;constructor(v0){super('SdkError','SparkError');this.inner=Object.freeze([v0]);}static new(v0){return new SparkError_(v0);}static instanceOf(obj){return obj.tag===SdkError_Tags.SparkError;}static hasInner(obj){return SparkError_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class InsufficientFunds_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.InsufficientFunds;constructor(){super('SdkError','InsufficientFunds');}static new(){return new InsufficientFunds_();}static instanceOf(obj){return obj.tag===SdkError_Tags.InsufficientFunds;}static hasInner(obj){return false;}}class InvalidUuid_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.InvalidUuid;constructor(v0){super('SdkError','InvalidUuid');this.inner=Object.freeze([v0]);}static new(v0){return new InvalidUuid_(v0);}static instanceOf(obj){return obj.tag===SdkError_Tags.InvalidUuid;}static hasInner(obj){return InvalidUuid_.instanceOf(obj);}static getInner(obj){return obj.inner;}}/**
   * Invalid input error
   */class InvalidInput_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.InvalidInput;constructor(v0){super('SdkError','InvalidInput');this.inner=Object.freeze([v0]);}static new(v0){return new InvalidInput_(v0);}static instanceOf(obj){return obj.tag===SdkError_Tags.InvalidInput;}static hasInner(obj){return InvalidInput_.instanceOf(obj);}static getInner(obj){return obj.inner;}}/**
   * Network error
   */class NetworkError_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.NetworkError;constructor(v0){super('SdkError','NetworkError');this.inner=Object.freeze([v0]);}static new(v0){return new NetworkError_(v0);}static instanceOf(obj){return obj.tag===SdkError_Tags.NetworkError;}static hasInner(obj){return NetworkError_.instanceOf(obj);}static getInner(obj){return obj.inner;}}/**
   * Storage error
   */class StorageError_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.StorageError;constructor(v0){super('SdkError','StorageError');this.inner=Object.freeze([v0]);}static new(v0){return new StorageError_(v0);}static instanceOf(obj){return obj.tag===SdkError_Tags.StorageError;}static hasInner(obj){return StorageError_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class ChainServiceError_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.ChainServiceError;constructor(v0){super('SdkError','ChainServiceError');this.inner=Object.freeze([v0]);}static new(v0){return new ChainServiceError_(v0);}static instanceOf(obj){return obj.tag===SdkError_Tags.ChainServiceError;}static hasInner(obj){return ChainServiceError_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class MaxDepositClaimFeeExceeded_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.MaxDepositClaimFeeExceeded;constructor(inner){super('SdkError','MaxDepositClaimFeeExceeded');this.inner=Object.freeze(inner);}static new(inner){return new MaxDepositClaimFeeExceeded_(inner);}static instanceOf(obj){return obj.tag===SdkError_Tags.MaxDepositClaimFeeExceeded;}static hasInner(obj){return MaxDepositClaimFeeExceeded_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class MissingUtxo_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.MissingUtxo;constructor(inner){super('SdkError','MissingUtxo');this.inner=Object.freeze(inner);}static new(inner){return new MissingUtxo_(inner);}static instanceOf(obj){return obj.tag===SdkError_Tags.MissingUtxo;}static hasInner(obj){return MissingUtxo_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class LnurlError_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.LnurlError;constructor(v0){super('SdkError','LnurlError');this.inner=Object.freeze([v0]);}static new(v0){return new LnurlError_(v0);}static instanceOf(obj){return obj.tag===SdkError_Tags.LnurlError;}static hasInner(obj){return LnurlError_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Signer_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.Signer;constructor(v0){super('SdkError','Signer');this.inner=Object.freeze([v0]);}static new(v0){return new Signer_(v0);}static instanceOf(obj){return obj.tag===SdkError_Tags.Signer;}static hasInner(obj){return Signer_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Generic_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkError';tag=SdkError_Tags.Generic;constructor(v0){super('SdkError','Generic');this.inner=Object.freeze([v0]);}static new(v0){return new Generic_(v0);}static instanceOf(obj){return obj.tag===SdkError_Tags.Generic;}static hasInner(obj){return Generic_.instanceOf(obj);}static getInner(obj){return obj.inner;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='SdkError';}return Object.freeze({instanceOf,SparkError:SparkError_,InsufficientFunds:InsufficientFunds_,InvalidUuid:InvalidUuid_,InvalidInput:InvalidInput_,NetworkError:NetworkError_,StorageError:StorageError_,ChainServiceError:ChainServiceError_,MaxDepositClaimFeeExceeded:MaxDepositClaimFeeExceeded_,MissingUtxo:MissingUtxo_,LnurlError:LnurlError_,Signer:Signer_,Generic:Generic_});})();/**
 * Error type for the `BreezSdk`
 */// FfiConverter for enum SdkError
const FfiConverterTypeSdkError=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new SdkError.SparkError(FfiConverterString.read(from));case 2:return new SdkError.InsufficientFunds();case 3:return new SdkError.InvalidUuid(FfiConverterString.read(from));case 4:return new SdkError.InvalidInput(FfiConverterString.read(from));case 5:return new SdkError.NetworkError(FfiConverterString.read(from));case 6:return new SdkError.StorageError(FfiConverterString.read(from));case 7:return new SdkError.ChainServiceError(FfiConverterString.read(from));case 8:return new SdkError.MaxDepositClaimFeeExceeded({tx:FfiConverterString.read(from),vout:FfiConverterUInt32.read(from),maxFee:FfiConverterOptionalTypeFee.read(from),requiredFeeSats:FfiConverterUInt64.read(from),requiredFeeRateSatPerVbyte:FfiConverterUInt64.read(from)});case 9:return new SdkError.MissingUtxo({tx:FfiConverterString.read(from),vout:FfiConverterUInt32.read(from)});case 10:return new SdkError.LnurlError(FfiConverterString.read(from));case 11:return new SdkError.Signer(FfiConverterString.read(from));case 12:return new SdkError.Generic(FfiConverterString.read(from));default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case SdkError_Tags.SparkError:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SdkError_Tags.InsufficientFunds:{ordinalConverter.write(2,into);return;}case SdkError_Tags.InvalidUuid:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SdkError_Tags.InvalidInput:{ordinalConverter.write(4,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SdkError_Tags.NetworkError:{ordinalConverter.write(5,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SdkError_Tags.StorageError:{ordinalConverter.write(6,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SdkError_Tags.ChainServiceError:{ordinalConverter.write(7,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SdkError_Tags.MaxDepositClaimFeeExceeded:{ordinalConverter.write(8,into);const inner=value.inner;FfiConverterString.write(inner.tx,into);FfiConverterUInt32.write(inner.vout,into);FfiConverterOptionalTypeFee.write(inner.maxFee,into);FfiConverterUInt64.write(inner.requiredFeeSats,into);FfiConverterUInt64.write(inner.requiredFeeRateSatPerVbyte,into);return;}case SdkError_Tags.MissingUtxo:{ordinalConverter.write(9,into);const inner=value.inner;FfiConverterString.write(inner.tx,into);FfiConverterUInt32.write(inner.vout,into);return;}case SdkError_Tags.LnurlError:{ordinalConverter.write(10,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SdkError_Tags.Signer:{ordinalConverter.write(11,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SdkError_Tags.Generic:{ordinalConverter.write(12,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}default:// Throwing from here means that SdkError_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case SdkError_Tags.SparkError:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SdkError_Tags.InsufficientFunds:{return ordinalConverter.allocationSize(2);}case SdkError_Tags.InvalidUuid:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SdkError_Tags.InvalidInput:{const inner=value.inner;let size=ordinalConverter.allocationSize(4);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SdkError_Tags.NetworkError:{const inner=value.inner;let size=ordinalConverter.allocationSize(5);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SdkError_Tags.StorageError:{const inner=value.inner;let size=ordinalConverter.allocationSize(6);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SdkError_Tags.ChainServiceError:{const inner=value.inner;let size=ordinalConverter.allocationSize(7);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SdkError_Tags.MaxDepositClaimFeeExceeded:{const inner=value.inner;let size=ordinalConverter.allocationSize(8);size+=FfiConverterString.allocationSize(inner.tx);size+=FfiConverterUInt32.allocationSize(inner.vout);size+=FfiConverterOptionalTypeFee.allocationSize(inner.maxFee);size+=FfiConverterUInt64.allocationSize(inner.requiredFeeSats);size+=FfiConverterUInt64.allocationSize(inner.requiredFeeRateSatPerVbyte);return size;}case SdkError_Tags.MissingUtxo:{const inner=value.inner;let size=ordinalConverter.allocationSize(9);size+=FfiConverterString.allocationSize(inner.tx);size+=FfiConverterUInt32.allocationSize(inner.vout);return size;}case SdkError_Tags.LnurlError:{const inner=value.inner;let size=ordinalConverter.allocationSize(10);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SdkError_Tags.Signer:{const inner=value.inner;let size=ordinalConverter.allocationSize(11);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SdkError_Tags.Generic:{const inner=value.inner;let size=ordinalConverter.allocationSize(12);size+=FfiConverterString.allocationSize(inner[0]);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: SdkEvent
export let SdkEvent_Tags=/*#__PURE__*/function(SdkEvent_Tags){SdkEvent_Tags["Synced"]="Synced";SdkEvent_Tags["UnclaimedDeposits"]="UnclaimedDeposits";SdkEvent_Tags["ClaimedDeposits"]="ClaimedDeposits";SdkEvent_Tags["PaymentSucceeded"]="PaymentSucceeded";SdkEvent_Tags["PaymentPending"]="PaymentPending";SdkEvent_Tags["PaymentFailed"]="PaymentFailed";SdkEvent_Tags["Optimization"]="Optimization";return SdkEvent_Tags;}({});/**
 * Events emitted by the SDK
 */export const SdkEvent=(()=>{/**
   * Emitted when the wallet has been synchronized with the network
   */class Synced_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkEvent';tag=SdkEvent_Tags.Synced;constructor(){super('SdkEvent','Synced');}static new(){return new Synced_();}static instanceOf(obj){return obj.tag===SdkEvent_Tags.Synced;}}/**
   * Emitted when the SDK was unable to claim deposits
   */class UnclaimedDeposits_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkEvent';tag=SdkEvent_Tags.UnclaimedDeposits;constructor(inner){super('SdkEvent','UnclaimedDeposits');this.inner=Object.freeze(inner);}static new(inner){return new UnclaimedDeposits_(inner);}static instanceOf(obj){return obj.tag===SdkEvent_Tags.UnclaimedDeposits;}}class ClaimedDeposits_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkEvent';tag=SdkEvent_Tags.ClaimedDeposits;constructor(inner){super('SdkEvent','ClaimedDeposits');this.inner=Object.freeze(inner);}static new(inner){return new ClaimedDeposits_(inner);}static instanceOf(obj){return obj.tag===SdkEvent_Tags.ClaimedDeposits;}}class PaymentSucceeded_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkEvent';tag=SdkEvent_Tags.PaymentSucceeded;constructor(inner){super('SdkEvent','PaymentSucceeded');this.inner=Object.freeze(inner);}static new(inner){return new PaymentSucceeded_(inner);}static instanceOf(obj){return obj.tag===SdkEvent_Tags.PaymentSucceeded;}}class PaymentPending_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkEvent';tag=SdkEvent_Tags.PaymentPending;constructor(inner){super('SdkEvent','PaymentPending');this.inner=Object.freeze(inner);}static new(inner){return new PaymentPending_(inner);}static instanceOf(obj){return obj.tag===SdkEvent_Tags.PaymentPending;}}class PaymentFailed_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkEvent';tag=SdkEvent_Tags.PaymentFailed;constructor(inner){super('SdkEvent','PaymentFailed');this.inner=Object.freeze(inner);}static new(inner){return new PaymentFailed_(inner);}static instanceOf(obj){return obj.tag===SdkEvent_Tags.PaymentFailed;}}class Optimization_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SdkEvent';tag=SdkEvent_Tags.Optimization;constructor(inner){super('SdkEvent','Optimization');this.inner=Object.freeze(inner);}static new(inner){return new Optimization_(inner);}static instanceOf(obj){return obj.tag===SdkEvent_Tags.Optimization;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='SdkEvent';}return Object.freeze({instanceOf,Synced:Synced_,UnclaimedDeposits:UnclaimedDeposits_,ClaimedDeposits:ClaimedDeposits_,PaymentSucceeded:PaymentSucceeded_,PaymentPending:PaymentPending_,PaymentFailed:PaymentFailed_,Optimization:Optimization_});})();/**
 * Events emitted by the SDK
 */// FfiConverter for enum SdkEvent
const FfiConverterTypeSdkEvent=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new SdkEvent.Synced();case 2:return new SdkEvent.UnclaimedDeposits({unclaimedDeposits:FfiConverterArrayTypeDepositInfo.read(from)});case 3:return new SdkEvent.ClaimedDeposits({claimedDeposits:FfiConverterArrayTypeDepositInfo.read(from)});case 4:return new SdkEvent.PaymentSucceeded({payment:FfiConverterTypePayment.read(from)});case 5:return new SdkEvent.PaymentPending({payment:FfiConverterTypePayment.read(from)});case 6:return new SdkEvent.PaymentFailed({payment:FfiConverterTypePayment.read(from)});case 7:return new SdkEvent.Optimization({optimizationEvent:FfiConverterTypeOptimizationEvent.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case SdkEvent_Tags.Synced:{ordinalConverter.write(1,into);return;}case SdkEvent_Tags.UnclaimedDeposits:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterArrayTypeDepositInfo.write(inner.unclaimedDeposits,into);return;}case SdkEvent_Tags.ClaimedDeposits:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterArrayTypeDepositInfo.write(inner.claimedDeposits,into);return;}case SdkEvent_Tags.PaymentSucceeded:{ordinalConverter.write(4,into);const inner=value.inner;FfiConverterTypePayment.write(inner.payment,into);return;}case SdkEvent_Tags.PaymentPending:{ordinalConverter.write(5,into);const inner=value.inner;FfiConverterTypePayment.write(inner.payment,into);return;}case SdkEvent_Tags.PaymentFailed:{ordinalConverter.write(6,into);const inner=value.inner;FfiConverterTypePayment.write(inner.payment,into);return;}case SdkEvent_Tags.Optimization:{ordinalConverter.write(7,into);const inner=value.inner;FfiConverterTypeOptimizationEvent.write(inner.optimizationEvent,into);return;}default:// Throwing from here means that SdkEvent_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case SdkEvent_Tags.Synced:{return ordinalConverter.allocationSize(1);}case SdkEvent_Tags.UnclaimedDeposits:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterArrayTypeDepositInfo.allocationSize(inner.unclaimedDeposits);return size;}case SdkEvent_Tags.ClaimedDeposits:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterArrayTypeDepositInfo.allocationSize(inner.claimedDeposits);return size;}case SdkEvent_Tags.PaymentSucceeded:{const inner=value.inner;let size=ordinalConverter.allocationSize(4);size+=FfiConverterTypePayment.allocationSize(inner.payment);return size;}case SdkEvent_Tags.PaymentPending:{const inner=value.inner;let size=ordinalConverter.allocationSize(5);size+=FfiConverterTypePayment.allocationSize(inner.payment);return size;}case SdkEvent_Tags.PaymentFailed:{const inner=value.inner;let size=ordinalConverter.allocationSize(6);size+=FfiConverterTypePayment.allocationSize(inner.payment);return size;}case SdkEvent_Tags.Optimization:{const inner=value.inner;let size=ordinalConverter.allocationSize(7);size+=FfiConverterTypeOptimizationEvent.allocationSize(inner.optimizationEvent);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: Seed
export let Seed_Tags=/*#__PURE__*/function(Seed_Tags){Seed_Tags["Mnemonic"]="Mnemonic";Seed_Tags["Entropy"]="Entropy";return Seed_Tags;}({});/**
 * Represents the seed for wallet generation, either as a mnemonic phrase with an optional
 * passphrase or as raw entropy bytes.
 */export const Seed=(()=>{/**
   * A BIP-39 mnemonic phrase with an optional passphrase.
   */class Mnemonic_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='Seed';tag=Seed_Tags.Mnemonic;constructor(inner){super('Seed','Mnemonic');this.inner=Object.freeze(inner);}static new(inner){return new Mnemonic_(inner);}static instanceOf(obj){return obj.tag===Seed_Tags.Mnemonic;}}/**
   * Raw entropy bytes.
   */class Entropy_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='Seed';tag=Seed_Tags.Entropy;constructor(v0){super('Seed','Entropy');this.inner=Object.freeze([v0]);}static new(v0){return new Entropy_(v0);}static instanceOf(obj){return obj.tag===Seed_Tags.Entropy;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='Seed';}return Object.freeze({instanceOf,Mnemonic:Mnemonic_,Entropy:Entropy_});})();/**
 * Represents the seed for wallet generation, either as a mnemonic phrase with an optional
 * passphrase or as raw entropy bytes.
 */// FfiConverter for enum Seed
const FfiConverterTypeSeed=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new Seed.Mnemonic({mnemonic:FfiConverterString.read(from),passphrase:FfiConverterOptionalString.read(from)});case 2:return new Seed.Entropy(FfiConverterArrayBuffer.read(from));default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case Seed_Tags.Mnemonic:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterString.write(inner.mnemonic,into);FfiConverterOptionalString.write(inner.passphrase,into);return;}case Seed_Tags.Entropy:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterArrayBuffer.write(inner[0],into);return;}default:// Throwing from here means that Seed_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case Seed_Tags.Mnemonic:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterString.allocationSize(inner.mnemonic);size+=FfiConverterOptionalString.allocationSize(inner.passphrase);return size;}case Seed_Tags.Entropy:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterArrayBuffer.allocationSize(inner[0]);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: SendPaymentMethod
export let SendPaymentMethod_Tags=/*#__PURE__*/function(SendPaymentMethod_Tags){SendPaymentMethod_Tags["BitcoinAddress"]="BitcoinAddress";SendPaymentMethod_Tags["Bolt11Invoice"]="Bolt11Invoice";SendPaymentMethod_Tags["SparkAddress"]="SparkAddress";SendPaymentMethod_Tags["SparkInvoice"]="SparkInvoice";return SendPaymentMethod_Tags;}({});export const SendPaymentMethod=(()=>{class BitcoinAddress_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SendPaymentMethod';tag=SendPaymentMethod_Tags.BitcoinAddress;constructor(inner){super('SendPaymentMethod','BitcoinAddress');this.inner=Object.freeze(inner);}static new(inner){return new BitcoinAddress_(inner);}static instanceOf(obj){return obj.tag===SendPaymentMethod_Tags.BitcoinAddress;}}class Bolt11Invoice_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SendPaymentMethod';tag=SendPaymentMethod_Tags.Bolt11Invoice;constructor(inner){super('SendPaymentMethod','Bolt11Invoice');this.inner=Object.freeze(inner);}static new(inner){return new Bolt11Invoice_(inner);}static instanceOf(obj){return obj.tag===SendPaymentMethod_Tags.Bolt11Invoice;}}class SparkAddress_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SendPaymentMethod';tag=SendPaymentMethod_Tags.SparkAddress;constructor(inner){super('SendPaymentMethod','SparkAddress');this.inner=Object.freeze(inner);}static new(inner){return new SparkAddress_(inner);}static instanceOf(obj){return obj.tag===SendPaymentMethod_Tags.SparkAddress;}}class SparkInvoice_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SendPaymentMethod';tag=SendPaymentMethod_Tags.SparkInvoice;constructor(inner){super('SendPaymentMethod','SparkInvoice');this.inner=Object.freeze(inner);}static new(inner){return new SparkInvoice_(inner);}static instanceOf(obj){return obj.tag===SendPaymentMethod_Tags.SparkInvoice;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='SendPaymentMethod';}return Object.freeze({instanceOf,BitcoinAddress:BitcoinAddress_,Bolt11Invoice:Bolt11Invoice_,SparkAddress:SparkAddress_,SparkInvoice:SparkInvoice_});})();// FfiConverter for enum SendPaymentMethod
const FfiConverterTypeSendPaymentMethod=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new SendPaymentMethod.BitcoinAddress({address:FfiConverterTypeBitcoinAddressDetails.read(from),feeQuote:FfiConverterTypeSendOnchainFeeQuote.read(from)});case 2:return new SendPaymentMethod.Bolt11Invoice({invoiceDetails:FfiConverterTypeBolt11InvoiceDetails.read(from),sparkTransferFeeSats:FfiConverterOptionalUInt64.read(from),lightningFeeSats:FfiConverterUInt64.read(from)});case 3:return new SendPaymentMethod.SparkAddress({address:FfiConverterString.read(from),fee:FfiConverterTypeu128.read(from),tokenIdentifier:FfiConverterOptionalString.read(from)});case 4:return new SendPaymentMethod.SparkInvoice({sparkInvoiceDetails:FfiConverterTypeSparkInvoiceDetails.read(from),fee:FfiConverterTypeu128.read(from),tokenIdentifier:FfiConverterOptionalString.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case SendPaymentMethod_Tags.BitcoinAddress:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterTypeBitcoinAddressDetails.write(inner.address,into);FfiConverterTypeSendOnchainFeeQuote.write(inner.feeQuote,into);return;}case SendPaymentMethod_Tags.Bolt11Invoice:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterTypeBolt11InvoiceDetails.write(inner.invoiceDetails,into);FfiConverterOptionalUInt64.write(inner.sparkTransferFeeSats,into);FfiConverterUInt64.write(inner.lightningFeeSats,into);return;}case SendPaymentMethod_Tags.SparkAddress:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterString.write(inner.address,into);FfiConverterTypeu128.write(inner.fee,into);FfiConverterOptionalString.write(inner.tokenIdentifier,into);return;}case SendPaymentMethod_Tags.SparkInvoice:{ordinalConverter.write(4,into);const inner=value.inner;FfiConverterTypeSparkInvoiceDetails.write(inner.sparkInvoiceDetails,into);FfiConverterTypeu128.write(inner.fee,into);FfiConverterOptionalString.write(inner.tokenIdentifier,into);return;}default:// Throwing from here means that SendPaymentMethod_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case SendPaymentMethod_Tags.BitcoinAddress:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterTypeBitcoinAddressDetails.allocationSize(inner.address);size+=FfiConverterTypeSendOnchainFeeQuote.allocationSize(inner.feeQuote);return size;}case SendPaymentMethod_Tags.Bolt11Invoice:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterTypeBolt11InvoiceDetails.allocationSize(inner.invoiceDetails);size+=FfiConverterOptionalUInt64.allocationSize(inner.sparkTransferFeeSats);size+=FfiConverterUInt64.allocationSize(inner.lightningFeeSats);return size;}case SendPaymentMethod_Tags.SparkAddress:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterString.allocationSize(inner.address);size+=FfiConverterTypeu128.allocationSize(inner.fee);size+=FfiConverterOptionalString.allocationSize(inner.tokenIdentifier);return size;}case SendPaymentMethod_Tags.SparkInvoice:{const inner=value.inner;let size=ordinalConverter.allocationSize(4);size+=FfiConverterTypeSparkInvoiceDetails.allocationSize(inner.sparkInvoiceDetails);size+=FfiConverterTypeu128.allocationSize(inner.fee);size+=FfiConverterOptionalString.allocationSize(inner.tokenIdentifier);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: SendPaymentOptions
export let SendPaymentOptions_Tags=/*#__PURE__*/function(SendPaymentOptions_Tags){SendPaymentOptions_Tags["BitcoinAddress"]="BitcoinAddress";SendPaymentOptions_Tags["Bolt11Invoice"]="Bolt11Invoice";SendPaymentOptions_Tags["SparkAddress"]="SparkAddress";return SendPaymentOptions_Tags;}({});export const SendPaymentOptions=(()=>{class BitcoinAddress_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SendPaymentOptions';tag=SendPaymentOptions_Tags.BitcoinAddress;constructor(inner){super('SendPaymentOptions','BitcoinAddress');this.inner=Object.freeze(inner);}static new(inner){return new BitcoinAddress_(inner);}static instanceOf(obj){return obj.tag===SendPaymentOptions_Tags.BitcoinAddress;}}class Bolt11Invoice_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SendPaymentOptions';tag=SendPaymentOptions_Tags.Bolt11Invoice;constructor(inner){super('SendPaymentOptions','Bolt11Invoice');this.inner=Object.freeze(inner);}static new(inner){return new Bolt11Invoice_(inner);}static instanceOf(obj){return obj.tag===SendPaymentOptions_Tags.Bolt11Invoice;}}class SparkAddress_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SendPaymentOptions';tag=SendPaymentOptions_Tags.SparkAddress;constructor(inner){super('SendPaymentOptions','SparkAddress');this.inner=Object.freeze(inner);}static new(inner){return new SparkAddress_(inner);}static instanceOf(obj){return obj.tag===SendPaymentOptions_Tags.SparkAddress;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='SendPaymentOptions';}return Object.freeze({instanceOf,BitcoinAddress:BitcoinAddress_,Bolt11Invoice:Bolt11Invoice_,SparkAddress:SparkAddress_});})();// FfiConverter for enum SendPaymentOptions
const FfiConverterTypeSendPaymentOptions=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new SendPaymentOptions.BitcoinAddress({confirmationSpeed:FfiConverterTypeOnchainConfirmationSpeed.read(from)});case 2:return new SendPaymentOptions.Bolt11Invoice({preferSpark:FfiConverterBool.read(from),completionTimeoutSecs:FfiConverterOptionalUInt32.read(from)});case 3:return new SendPaymentOptions.SparkAddress({htlcOptions:FfiConverterOptionalTypeSparkHtlcOptions.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case SendPaymentOptions_Tags.BitcoinAddress:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterTypeOnchainConfirmationSpeed.write(inner.confirmationSpeed,into);return;}case SendPaymentOptions_Tags.Bolt11Invoice:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterBool.write(inner.preferSpark,into);FfiConverterOptionalUInt32.write(inner.completionTimeoutSecs,into);return;}case SendPaymentOptions_Tags.SparkAddress:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterOptionalTypeSparkHtlcOptions.write(inner.htlcOptions,into);return;}default:// Throwing from here means that SendPaymentOptions_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case SendPaymentOptions_Tags.BitcoinAddress:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterTypeOnchainConfirmationSpeed.allocationSize(inner.confirmationSpeed);return size;}case SendPaymentOptions_Tags.Bolt11Invoice:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterBool.allocationSize(inner.preferSpark);size+=FfiConverterOptionalUInt32.allocationSize(inner.completionTimeoutSecs);return size;}case SendPaymentOptions_Tags.SparkAddress:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterOptionalTypeSparkHtlcOptions.allocationSize(inner.htlcOptions);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Error type: ServiceConnectivityError
// Enum: ServiceConnectivityError
export let ServiceConnectivityError_Tags=/*#__PURE__*/function(ServiceConnectivityError_Tags){ServiceConnectivityError_Tags["Builder"]="Builder";ServiceConnectivityError_Tags["Redirect"]="Redirect";ServiceConnectivityError_Tags["Status"]="Status";ServiceConnectivityError_Tags["Timeout"]="Timeout";ServiceConnectivityError_Tags["Request"]="Request";ServiceConnectivityError_Tags["Connect"]="Connect";ServiceConnectivityError_Tags["Body"]="Body";ServiceConnectivityError_Tags["Decode"]="Decode";ServiceConnectivityError_Tags["Json"]="Json";ServiceConnectivityError_Tags["Other"]="Other";return ServiceConnectivityError_Tags;}({});export const ServiceConnectivityError=(()=>{class Builder_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ServiceConnectivityError';tag=ServiceConnectivityError_Tags.Builder;constructor(v0){super('ServiceConnectivityError','Builder');this.inner=Object.freeze([v0]);}static new(v0){return new Builder_(v0);}static instanceOf(obj){return obj.tag===ServiceConnectivityError_Tags.Builder;}static hasInner(obj){return Builder_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Redirect_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ServiceConnectivityError';tag=ServiceConnectivityError_Tags.Redirect;constructor(v0){super('ServiceConnectivityError','Redirect');this.inner=Object.freeze([v0]);}static new(v0){return new Redirect_(v0);}static instanceOf(obj){return obj.tag===ServiceConnectivityError_Tags.Redirect;}static hasInner(obj){return Redirect_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Status_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ServiceConnectivityError';tag=ServiceConnectivityError_Tags.Status;constructor(inner){super('ServiceConnectivityError','Status');this.inner=Object.freeze(inner);}static new(inner){return new Status_(inner);}static instanceOf(obj){return obj.tag===ServiceConnectivityError_Tags.Status;}static hasInner(obj){return Status_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Timeout_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ServiceConnectivityError';tag=ServiceConnectivityError_Tags.Timeout;constructor(v0){super('ServiceConnectivityError','Timeout');this.inner=Object.freeze([v0]);}static new(v0){return new Timeout_(v0);}static instanceOf(obj){return obj.tag===ServiceConnectivityError_Tags.Timeout;}static hasInner(obj){return Timeout_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Request_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ServiceConnectivityError';tag=ServiceConnectivityError_Tags.Request;constructor(v0){super('ServiceConnectivityError','Request');this.inner=Object.freeze([v0]);}static new(v0){return new Request_(v0);}static instanceOf(obj){return obj.tag===ServiceConnectivityError_Tags.Request;}static hasInner(obj){return Request_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Connect_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ServiceConnectivityError';tag=ServiceConnectivityError_Tags.Connect;constructor(v0){super('ServiceConnectivityError','Connect');this.inner=Object.freeze([v0]);}static new(v0){return new Connect_(v0);}static instanceOf(obj){return obj.tag===ServiceConnectivityError_Tags.Connect;}static hasInner(obj){return Connect_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Body_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ServiceConnectivityError';tag=ServiceConnectivityError_Tags.Body;constructor(v0){super('ServiceConnectivityError','Body');this.inner=Object.freeze([v0]);}static new(v0){return new Body_(v0);}static instanceOf(obj){return obj.tag===ServiceConnectivityError_Tags.Body;}static hasInner(obj){return Body_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Decode_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ServiceConnectivityError';tag=ServiceConnectivityError_Tags.Decode;constructor(v0){super('ServiceConnectivityError','Decode');this.inner=Object.freeze([v0]);}static new(v0){return new Decode_(v0);}static instanceOf(obj){return obj.tag===ServiceConnectivityError_Tags.Decode;}static hasInner(obj){return Decode_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Json_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ServiceConnectivityError';tag=ServiceConnectivityError_Tags.Json;constructor(v0){super('ServiceConnectivityError','Json');this.inner=Object.freeze([v0]);}static new(v0){return new Json_(v0);}static instanceOf(obj){return obj.tag===ServiceConnectivityError_Tags.Json;}static hasInner(obj){return Json_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Other_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='ServiceConnectivityError';tag=ServiceConnectivityError_Tags.Other;constructor(v0){super('ServiceConnectivityError','Other');this.inner=Object.freeze([v0]);}static new(v0){return new Other_(v0);}static instanceOf(obj){return obj.tag===ServiceConnectivityError_Tags.Other;}static hasInner(obj){return Other_.instanceOf(obj);}static getInner(obj){return obj.inner;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='ServiceConnectivityError';}return Object.freeze({instanceOf,Builder:Builder_,Redirect:Redirect_,Status:Status_,Timeout:Timeout_,Request:Request_,Connect:Connect_,Body:Body_,Decode:Decode_,Json:Json_,Other:Other_});})();// FfiConverter for enum ServiceConnectivityError
const FfiConverterTypeServiceConnectivityError=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new ServiceConnectivityError.Builder(FfiConverterString.read(from));case 2:return new ServiceConnectivityError.Redirect(FfiConverterString.read(from));case 3:return new ServiceConnectivityError.Status({status:FfiConverterUInt16.read(from),body:FfiConverterString.read(from)});case 4:return new ServiceConnectivityError.Timeout(FfiConverterString.read(from));case 5:return new ServiceConnectivityError.Request(FfiConverterString.read(from));case 6:return new ServiceConnectivityError.Connect(FfiConverterString.read(from));case 7:return new ServiceConnectivityError.Body(FfiConverterString.read(from));case 8:return new ServiceConnectivityError.Decode(FfiConverterString.read(from));case 9:return new ServiceConnectivityError.Json(FfiConverterString.read(from));case 10:return new ServiceConnectivityError.Other(FfiConverterString.read(from));default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case ServiceConnectivityError_Tags.Builder:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case ServiceConnectivityError_Tags.Redirect:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case ServiceConnectivityError_Tags.Status:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterUInt16.write(inner.status,into);FfiConverterString.write(inner.body,into);return;}case ServiceConnectivityError_Tags.Timeout:{ordinalConverter.write(4,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case ServiceConnectivityError_Tags.Request:{ordinalConverter.write(5,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case ServiceConnectivityError_Tags.Connect:{ordinalConverter.write(6,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case ServiceConnectivityError_Tags.Body:{ordinalConverter.write(7,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case ServiceConnectivityError_Tags.Decode:{ordinalConverter.write(8,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case ServiceConnectivityError_Tags.Json:{ordinalConverter.write(9,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case ServiceConnectivityError_Tags.Other:{ordinalConverter.write(10,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}default:// Throwing from here means that ServiceConnectivityError_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case ServiceConnectivityError_Tags.Builder:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterString.allocationSize(inner[0]);return size;}case ServiceConnectivityError_Tags.Redirect:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner[0]);return size;}case ServiceConnectivityError_Tags.Status:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterUInt16.allocationSize(inner.status);size+=FfiConverterString.allocationSize(inner.body);return size;}case ServiceConnectivityError_Tags.Timeout:{const inner=value.inner;let size=ordinalConverter.allocationSize(4);size+=FfiConverterString.allocationSize(inner[0]);return size;}case ServiceConnectivityError_Tags.Request:{const inner=value.inner;let size=ordinalConverter.allocationSize(5);size+=FfiConverterString.allocationSize(inner[0]);return size;}case ServiceConnectivityError_Tags.Connect:{const inner=value.inner;let size=ordinalConverter.allocationSize(6);size+=FfiConverterString.allocationSize(inner[0]);return size;}case ServiceConnectivityError_Tags.Body:{const inner=value.inner;let size=ordinalConverter.allocationSize(7);size+=FfiConverterString.allocationSize(inner[0]);return size;}case ServiceConnectivityError_Tags.Decode:{const inner=value.inner;let size=ordinalConverter.allocationSize(8);size+=FfiConverterString.allocationSize(inner[0]);return size;}case ServiceConnectivityError_Tags.Json:{const inner=value.inner;let size=ordinalConverter.allocationSize(9);size+=FfiConverterString.allocationSize(inner[0]);return size;}case ServiceConnectivityError_Tags.Other:{const inner=value.inner;let size=ordinalConverter.allocationSize(10);size+=FfiConverterString.allocationSize(inner[0]);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();/**
 * The operational status of a Spark service.
 */export let ServiceStatus=/*#__PURE__*/function(ServiceStatus){/**
   * Service is fully operational.
   */ServiceStatus[ServiceStatus["Operational"]=0]="Operational";/**
   * Service is experiencing degraded performance.
   */ServiceStatus[ServiceStatus["Degraded"]=1]="Degraded";/**
   * Service is partially unavailable.
   */ServiceStatus[ServiceStatus["Partial"]=2]="Partial";/**
   * Service status is unknown.
   */ServiceStatus[ServiceStatus["Unknown"]=3]="Unknown";/**
   * Service is experiencing a major outage.
   */ServiceStatus[ServiceStatus["Major"]=4]="Major";return ServiceStatus;}({});const FfiConverterTypeServiceStatus=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return ServiceStatus.Operational;case 2:return ServiceStatus.Degraded;case 3:return ServiceStatus.Partial;case 4:return ServiceStatus.Unknown;case 5:return ServiceStatus.Major;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case ServiceStatus.Operational:return ordinalConverter.write(1,into);case ServiceStatus.Degraded:return ordinalConverter.write(2,into);case ServiceStatus.Partial:return ordinalConverter.write(3,into);case ServiceStatus.Unknown:return ordinalConverter.write(4,into);case ServiceStatus.Major:return ordinalConverter.write(5,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();// Error type: SignerError
// Enum: SignerError
export let SignerError_Tags=/*#__PURE__*/function(SignerError_Tags){SignerError_Tags["KeyDerivation"]="KeyDerivation";SignerError_Tags["Signing"]="Signing";SignerError_Tags["Encryption"]="Encryption";SignerError_Tags["Decryption"]="Decryption";SignerError_Tags["Frost"]="Frost";SignerError_Tags["InvalidInput"]="InvalidInput";SignerError_Tags["Generic"]="Generic";return SignerError_Tags;}({});/**
 * Error type for signer operations
 */export const SignerError=(()=>{class KeyDerivation_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SignerError';tag=SignerError_Tags.KeyDerivation;constructor(v0){super('SignerError','KeyDerivation');this.inner=Object.freeze([v0]);}static new(v0){return new KeyDerivation_(v0);}static instanceOf(obj){return obj.tag===SignerError_Tags.KeyDerivation;}static hasInner(obj){return KeyDerivation_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Signing_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SignerError';tag=SignerError_Tags.Signing;constructor(v0){super('SignerError','Signing');this.inner=Object.freeze([v0]);}static new(v0){return new Signing_(v0);}static instanceOf(obj){return obj.tag===SignerError_Tags.Signing;}static hasInner(obj){return Signing_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Encryption_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SignerError';tag=SignerError_Tags.Encryption;constructor(v0){super('SignerError','Encryption');this.inner=Object.freeze([v0]);}static new(v0){return new Encryption_(v0);}static instanceOf(obj){return obj.tag===SignerError_Tags.Encryption;}static hasInner(obj){return Encryption_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Decryption_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SignerError';tag=SignerError_Tags.Decryption;constructor(v0){super('SignerError','Decryption');this.inner=Object.freeze([v0]);}static new(v0){return new Decryption_(v0);}static instanceOf(obj){return obj.tag===SignerError_Tags.Decryption;}static hasInner(obj){return Decryption_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Frost_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SignerError';tag=SignerError_Tags.Frost;constructor(v0){super('SignerError','Frost');this.inner=Object.freeze([v0]);}static new(v0){return new Frost_(v0);}static instanceOf(obj){return obj.tag===SignerError_Tags.Frost;}static hasInner(obj){return Frost_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class InvalidInput_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SignerError';tag=SignerError_Tags.InvalidInput;constructor(v0){super('SignerError','InvalidInput');this.inner=Object.freeze([v0]);}static new(v0){return new InvalidInput_(v0);}static instanceOf(obj){return obj.tag===SignerError_Tags.InvalidInput;}static hasInner(obj){return InvalidInput_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Generic_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SignerError';tag=SignerError_Tags.Generic;constructor(v0){super('SignerError','Generic');this.inner=Object.freeze([v0]);}static new(v0){return new Generic_(v0);}static instanceOf(obj){return obj.tag===SignerError_Tags.Generic;}static hasInner(obj){return Generic_.instanceOf(obj);}static getInner(obj){return obj.inner;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='SignerError';}return Object.freeze({instanceOf,KeyDerivation:KeyDerivation_,Signing:Signing_,Encryption:Encryption_,Decryption:Decryption_,Frost:Frost_,InvalidInput:InvalidInput_,Generic:Generic_});})();/**
 * Error type for signer operations
 */// FfiConverter for enum SignerError
const FfiConverterTypeSignerError=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new SignerError.KeyDerivation(FfiConverterString.read(from));case 2:return new SignerError.Signing(FfiConverterString.read(from));case 3:return new SignerError.Encryption(FfiConverterString.read(from));case 4:return new SignerError.Decryption(FfiConverterString.read(from));case 5:return new SignerError.Frost(FfiConverterString.read(from));case 6:return new SignerError.InvalidInput(FfiConverterString.read(from));case 7:return new SignerError.Generic(FfiConverterString.read(from));default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case SignerError_Tags.KeyDerivation:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SignerError_Tags.Signing:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SignerError_Tags.Encryption:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SignerError_Tags.Decryption:{ordinalConverter.write(4,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SignerError_Tags.Frost:{ordinalConverter.write(5,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SignerError_Tags.InvalidInput:{ordinalConverter.write(6,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case SignerError_Tags.Generic:{ordinalConverter.write(7,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}default:// Throwing from here means that SignerError_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case SignerError_Tags.KeyDerivation:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SignerError_Tags.Signing:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SignerError_Tags.Encryption:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SignerError_Tags.Decryption:{const inner=value.inner;let size=ordinalConverter.allocationSize(4);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SignerError_Tags.Frost:{const inner=value.inner;let size=ordinalConverter.allocationSize(5);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SignerError_Tags.InvalidInput:{const inner=value.inner;let size=ordinalConverter.allocationSize(6);size+=FfiConverterString.allocationSize(inner[0]);return size;}case SignerError_Tags.Generic:{const inner=value.inner;let size=ordinalConverter.allocationSize(7);size+=FfiConverterString.allocationSize(inner[0]);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();export let SparkHtlcStatus=/*#__PURE__*/function(SparkHtlcStatus){/**
   * The HTLC is waiting for the preimage to be shared by the receiver
   */SparkHtlcStatus[SparkHtlcStatus["WaitingForPreimage"]=0]="WaitingForPreimage";/**
   * The HTLC preimage has been shared and the transfer can be or has been claimed by the receiver
   */SparkHtlcStatus[SparkHtlcStatus["PreimageShared"]=1]="PreimageShared";/**
   * The HTLC has been returned to the sender due to expiry
   */SparkHtlcStatus[SparkHtlcStatus["Returned"]=2]="Returned";return SparkHtlcStatus;}({});const FfiConverterTypeSparkHtlcStatus=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return SparkHtlcStatus.WaitingForPreimage;case 2:return SparkHtlcStatus.PreimageShared;case 3:return SparkHtlcStatus.Returned;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case SparkHtlcStatus.WaitingForPreimage:return ordinalConverter.write(1,into);case SparkHtlcStatus.PreimageShared:return ordinalConverter.write(2,into);case SparkHtlcStatus.Returned:return ordinalConverter.write(3,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();// Error type: StorageError
// Enum: StorageError
export let StorageError_Tags=/*#__PURE__*/function(StorageError_Tags){StorageError_Tags["Connection"]="Connection";StorageError_Tags["Implementation"]="Implementation";StorageError_Tags["InitializationError"]="InitializationError";StorageError_Tags["Serialization"]="Serialization";return StorageError_Tags;}({});/**
 * Errors that can occur during storage operations
 */export const StorageError=(()=>{/**
   * Connection-related errors (pool exhaustion, timeouts, connection refused).
   * These are often transient and may be retried.
   */class Connection_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='StorageError';tag=StorageError_Tags.Connection;constructor(v0){super('StorageError','Connection');this.inner=Object.freeze([v0]);}static new(v0){return new Connection_(v0);}static instanceOf(obj){return obj.tag===StorageError_Tags.Connection;}static hasInner(obj){return Connection_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Implementation_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='StorageError';tag=StorageError_Tags.Implementation;constructor(v0){super('StorageError','Implementation');this.inner=Object.freeze([v0]);}static new(v0){return new Implementation_(v0);}static instanceOf(obj){return obj.tag===StorageError_Tags.Implementation;}static hasInner(obj){return Implementation_.instanceOf(obj);}static getInner(obj){return obj.inner;}}/**
   * Database initialization error
   */class InitializationError_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='StorageError';tag=StorageError_Tags.InitializationError;constructor(v0){super('StorageError','InitializationError');this.inner=Object.freeze([v0]);}static new(v0){return new InitializationError_(v0);}static instanceOf(obj){return obj.tag===StorageError_Tags.InitializationError;}static hasInner(obj){return InitializationError_.instanceOf(obj);}static getInner(obj){return obj.inner;}}class Serialization_ extends UniffiError{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='StorageError';tag=StorageError_Tags.Serialization;constructor(v0){super('StorageError','Serialization');this.inner=Object.freeze([v0]);}static new(v0){return new Serialization_(v0);}static instanceOf(obj){return obj.tag===StorageError_Tags.Serialization;}static hasInner(obj){return Serialization_.instanceOf(obj);}static getInner(obj){return obj.inner;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='StorageError';}return Object.freeze({instanceOf,Connection:Connection_,Implementation:Implementation_,InitializationError:InitializationError_,Serialization:Serialization_});})();/**
 * Errors that can occur during storage operations
 */// FfiConverter for enum StorageError
const FfiConverterTypeStorageError=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new StorageError.Connection(FfiConverterString.read(from));case 2:return new StorageError.Implementation(FfiConverterString.read(from));case 3:return new StorageError.InitializationError(FfiConverterString.read(from));case 4:return new StorageError.Serialization(FfiConverterString.read(from));default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case StorageError_Tags.Connection:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case StorageError_Tags.Implementation:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case StorageError_Tags.InitializationError:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}case StorageError_Tags.Serialization:{ordinalConverter.write(4,into);const inner=value.inner;FfiConverterString.write(inner[0],into);return;}default:// Throwing from here means that StorageError_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case StorageError_Tags.Connection:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterString.allocationSize(inner[0]);return size;}case StorageError_Tags.Implementation:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner[0]);return size;}case StorageError_Tags.InitializationError:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterString.allocationSize(inner[0]);return size;}case StorageError_Tags.Serialization:{const inner=value.inner;let size=ordinalConverter.allocationSize(4);size+=FfiConverterString.allocationSize(inner[0]);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: SuccessAction
export let SuccessAction_Tags=/*#__PURE__*/function(SuccessAction_Tags){SuccessAction_Tags["Aes"]="Aes";SuccessAction_Tags["Message"]="Message";SuccessAction_Tags["Url"]="Url";return SuccessAction_Tags;}({});/**
 * Supported success action types
 *
 * Receiving any other (unsupported) success action type will result in a failed parsing,
 * which will abort the LNURL-pay workflow, as per LUD-09.
 */export const SuccessAction=(()=>{/**
   * AES type, described in LUD-10
   */class Aes_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SuccessAction';tag=SuccessAction_Tags.Aes;constructor(inner){super('SuccessAction','Aes');this.inner=Object.freeze(inner);}static new(inner){return new Aes_(inner);}static instanceOf(obj){return obj.tag===SuccessAction_Tags.Aes;}}/**
   * Message type, described in LUD-09
   */class Message_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SuccessAction';tag=SuccessAction_Tags.Message;constructor(inner){super('SuccessAction','Message');this.inner=Object.freeze(inner);}static new(inner){return new Message_(inner);}static instanceOf(obj){return obj.tag===SuccessAction_Tags.Message;}}/**
   * URL type, described in LUD-09
   */class Url_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SuccessAction';tag=SuccessAction_Tags.Url;constructor(inner){super('SuccessAction','Url');this.inner=Object.freeze(inner);}static new(inner){return new Url_(inner);}static instanceOf(obj){return obj.tag===SuccessAction_Tags.Url;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='SuccessAction';}return Object.freeze({instanceOf,Aes:Aes_,Message:Message_,Url:Url_});})();/**
 * Supported success action types
 *
 * Receiving any other (unsupported) success action type will result in a failed parsing,
 * which will abort the LNURL-pay workflow, as per LUD-09.
 */// FfiConverter for enum SuccessAction
const FfiConverterTypeSuccessAction=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new SuccessAction.Aes({data:FfiConverterTypeAesSuccessActionData.read(from)});case 2:return new SuccessAction.Message({data:FfiConverterTypeMessageSuccessActionData.read(from)});case 3:return new SuccessAction.Url({data:FfiConverterTypeUrlSuccessActionData.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case SuccessAction_Tags.Aes:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterTypeAesSuccessActionData.write(inner.data,into);return;}case SuccessAction_Tags.Message:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterTypeMessageSuccessActionData.write(inner.data,into);return;}case SuccessAction_Tags.Url:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterTypeUrlSuccessActionData.write(inner.data,into);return;}default:// Throwing from here means that SuccessAction_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case SuccessAction_Tags.Aes:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterTypeAesSuccessActionData.allocationSize(inner.data);return size;}case SuccessAction_Tags.Message:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterTypeMessageSuccessActionData.allocationSize(inner.data);return size;}case SuccessAction_Tags.Url:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterTypeUrlSuccessActionData.allocationSize(inner.data);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// Enum: SuccessActionProcessed
export let SuccessActionProcessed_Tags=/*#__PURE__*/function(SuccessActionProcessed_Tags){SuccessActionProcessed_Tags["Aes"]="Aes";SuccessActionProcessed_Tags["Message"]="Message";SuccessActionProcessed_Tags["Url"]="Url";return SuccessActionProcessed_Tags;}({});/**
 * [`SuccessAction`] where contents are ready to be consumed by the caller
 *
 * Contents are identical to [`SuccessAction`], except for AES where the ciphertext is decrypted.
 */export const SuccessActionProcessed=(()=>{/**
   * See [`SuccessAction::Aes`] for received payload
   *
   * See [`AesSuccessActionDataDecrypted`] for decrypted payload
   */class Aes_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SuccessActionProcessed';tag=SuccessActionProcessed_Tags.Aes;constructor(inner){super('SuccessActionProcessed','Aes');this.inner=Object.freeze(inner);}static new(inner){return new Aes_(inner);}static instanceOf(obj){return obj.tag===SuccessActionProcessed_Tags.Aes;}}/**
   * See [`SuccessAction::Message`]
   */class Message_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SuccessActionProcessed';tag=SuccessActionProcessed_Tags.Message;constructor(inner){super('SuccessActionProcessed','Message');this.inner=Object.freeze(inner);}static new(inner){return new Message_(inner);}static instanceOf(obj){return obj.tag===SuccessActionProcessed_Tags.Message;}}/**
   * See [`SuccessAction::Url`]
   */class Url_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='SuccessActionProcessed';tag=SuccessActionProcessed_Tags.Url;constructor(inner){super('SuccessActionProcessed','Url');this.inner=Object.freeze(inner);}static new(inner){return new Url_(inner);}static instanceOf(obj){return obj.tag===SuccessActionProcessed_Tags.Url;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='SuccessActionProcessed';}return Object.freeze({instanceOf,Aes:Aes_,Message:Message_,Url:Url_});})();/**
 * [`SuccessAction`] where contents are ready to be consumed by the caller
 *
 * Contents are identical to [`SuccessAction`], except for AES where the ciphertext is decrypted.
 */// FfiConverter for enum SuccessActionProcessed
const FfiConverterTypeSuccessActionProcessed=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new SuccessActionProcessed.Aes({result:FfiConverterTypeAesSuccessActionDataResult.read(from)});case 2:return new SuccessActionProcessed.Message({data:FfiConverterTypeMessageSuccessActionData.read(from)});case 3:return new SuccessActionProcessed.Url({data:FfiConverterTypeUrlSuccessActionData.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case SuccessActionProcessed_Tags.Aes:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterTypeAesSuccessActionDataResult.write(inner.result,into);return;}case SuccessActionProcessed_Tags.Message:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterTypeMessageSuccessActionData.write(inner.data,into);return;}case SuccessActionProcessed_Tags.Url:{ordinalConverter.write(3,into);const inner=value.inner;FfiConverterTypeUrlSuccessActionData.write(inner.data,into);return;}default:// Throwing from here means that SuccessActionProcessed_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case SuccessActionProcessed_Tags.Aes:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterTypeAesSuccessActionDataResult.allocationSize(inner.result);return size;}case SuccessActionProcessed_Tags.Message:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterTypeMessageSuccessActionData.allocationSize(inner.data);return size;}case SuccessActionProcessed_Tags.Url:{const inner=value.inner;let size=ordinalConverter.allocationSize(3);size+=FfiConverterTypeUrlSuccessActionData.allocationSize(inner.data);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();export let TokenTransactionType=/*#__PURE__*/function(TokenTransactionType){TokenTransactionType[TokenTransactionType["Transfer"]=0]="Transfer";TokenTransactionType[TokenTransactionType["Mint"]=1]="Mint";TokenTransactionType[TokenTransactionType["Burn"]=2]="Burn";return TokenTransactionType;}({});const FfiConverterTypeTokenTransactionType=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return TokenTransactionType.Transfer;case 2:return TokenTransactionType.Mint;case 3:return TokenTransactionType.Burn;default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value){case TokenTransactionType.Transfer:return ordinalConverter.write(1,into);case TokenTransactionType.Mint:return ordinalConverter.write(2,into);case TokenTransactionType.Burn:return ordinalConverter.write(3,into);}}allocationSize(value){return ordinalConverter.allocationSize(0);}}return new FFIConverter();})();// Enum: UpdateDepositPayload
export let UpdateDepositPayload_Tags=/*#__PURE__*/function(UpdateDepositPayload_Tags){UpdateDepositPayload_Tags["ClaimError"]="ClaimError";UpdateDepositPayload_Tags["Refund"]="Refund";return UpdateDepositPayload_Tags;}({});export const UpdateDepositPayload=(()=>{class ClaimError_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='UpdateDepositPayload';tag=UpdateDepositPayload_Tags.ClaimError;constructor(inner){super('UpdateDepositPayload','ClaimError');this.inner=Object.freeze(inner);}static new(inner){return new ClaimError_(inner);}static instanceOf(obj){return obj.tag===UpdateDepositPayload_Tags.ClaimError;}}class Refund_ extends UniffiEnum{/**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */[uniffiTypeNameSymbol]='UpdateDepositPayload';tag=UpdateDepositPayload_Tags.Refund;constructor(inner){super('UpdateDepositPayload','Refund');this.inner=Object.freeze(inner);}static new(inner){return new Refund_(inner);}static instanceOf(obj){return obj.tag===UpdateDepositPayload_Tags.Refund;}}function instanceOf(obj){return obj[uniffiTypeNameSymbol]==='UpdateDepositPayload';}return Object.freeze({instanceOf,ClaimError:ClaimError_,Refund:Refund_});})();// FfiConverter for enum UpdateDepositPayload
const FfiConverterTypeUpdateDepositPayload=(()=>{const ordinalConverter=FfiConverterInt32;class FFIConverter extends AbstractFfiConverterByteArray{read(from){switch(ordinalConverter.read(from)){case 1:return new UpdateDepositPayload.ClaimError({error:FfiConverterTypeDepositClaimError.read(from)});case 2:return new UpdateDepositPayload.Refund({refundTxid:FfiConverterString.read(from),refundTx:FfiConverterString.read(from)});default:throw new UniffiInternalError.UnexpectedEnumCase();}}write(value,into){switch(value.tag){case UpdateDepositPayload_Tags.ClaimError:{ordinalConverter.write(1,into);const inner=value.inner;FfiConverterTypeDepositClaimError.write(inner.error,into);return;}case UpdateDepositPayload_Tags.Refund:{ordinalConverter.write(2,into);const inner=value.inner;FfiConverterString.write(inner.refundTxid,into);FfiConverterString.write(inner.refundTx,into);return;}default:// Throwing from here means that UpdateDepositPayload_Tags hasn't matched an ordinal.
throw new UniffiInternalError.UnexpectedEnumCase();}}allocationSize(value){switch(value.tag){case UpdateDepositPayload_Tags.ClaimError:{const inner=value.inner;let size=ordinalConverter.allocationSize(1);size+=FfiConverterTypeDepositClaimError.allocationSize(inner.error);return size;}case UpdateDepositPayload_Tags.Refund:{const inner=value.inner;let size=ordinalConverter.allocationSize(2);size+=FfiConverterString.allocationSize(inner.refundTxid);size+=FfiConverterString.allocationSize(inner.refundTx);return size;}default:throw new UniffiInternalError.UnexpectedEnumCase();}}}return new FFIConverter();})();// FfiConverter for Map<string, TokenBalance>
const FfiConverterMapStringTypeTokenBalance=new FfiConverterMap(FfiConverterString,FfiConverterTypeTokenBalance);// FfiConverter for Map<string, string>
const FfiConverterMapStringString=new FfiConverterMap(FfiConverterString,FfiConverterString);export class BitcoinChainServiceImpl extends UniffiAbstractObject{[uniffiTypeNameSymbol]='BitcoinChainServiceImpl';// No primary constructor declared for this class.
constructor(pointer){super();this[pointerLiteralSymbol]=pointer;this[destructorGuardSymbol]=uniffiTypeBitcoinChainServiceImplObjectFactory.bless(pointer);}async getAddressUtxos(address,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),FfiConverterString.lower(address));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayTypeUtxo.lift.bind(FfiConverterArrayTypeUtxo),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeChainServiceError.lift.bind(FfiConverterTypeChainServiceError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async getTransactionStatus(txid,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),FfiConverterString.lower(txid));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeTxStatus.lift.bind(FfiConverterTypeTxStatus),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeChainServiceError.lift.bind(FfiConverterTypeChainServiceError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async getTransactionHex(txid,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),FfiConverterString.lower(txid));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterString.lift.bind(FfiConverterString),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeChainServiceError.lift.bind(FfiConverterTypeChainServiceError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async broadcastTransaction(tx,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this),FfiConverterString.lower(tx));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeChainServiceError.lift.bind(FfiConverterTypeChainServiceError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async recommendedFees(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_fees(uniffiTypeBitcoinChainServiceImplObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeRecommendedFees.lift.bind(FfiConverterTypeRecommendedFees),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeChainServiceError.lift.bind(FfiConverterTypeChainServiceError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */uniffiDestroy(){const ptr=this[destructorGuardSymbol];if(ptr!==undefined){const pointer=uniffiTypeBitcoinChainServiceImplObjectFactory.pointer(this);uniffiTypeBitcoinChainServiceImplObjectFactory.freePointer(pointer);uniffiTypeBitcoinChainServiceImplObjectFactory.unbless(ptr);delete this[destructorGuardSymbol];}}static instanceOf(obj){return uniffiTypeBitcoinChainServiceImplObjectFactory.isConcreteType(obj);}}const uniffiTypeBitcoinChainServiceImplObjectFactory={create(pointer){const instance=Object.create(BitcoinChainServiceImpl.prototype);instance[pointerLiteralSymbol]=pointer;instance[destructorGuardSymbol]=this.bless(pointer);instance[uniffiTypeNameSymbol]='BitcoinChainServiceImpl';return instance;},bless(p){return uniffiCaller.rustCall(/*caller:*/status=>nativeModule().ubrn_uniffi_internal_fn_method_bitcoinchainservice_ffi__bless_pointer(p,status),/*liftString:*/FfiConverterString.lift);},unbless(ptr){ptr.markDestroyed();},pointer(obj){if(obj[destructorGuardSymbol]===undefined){throw new UniffiInternalError.UnexpectedNullPointer();}return obj[pointerLiteralSymbol];},clonePointer(obj){const pointer=this.pointer(obj);return uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},freePointer(pointer){uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},isConcreteType(obj){return obj[destructorGuardSymbol]&&obj[uniffiTypeNameSymbol]==='BitcoinChainServiceImpl';}};// FfiConverter for BitcoinChainService
const FfiConverterTypeBitcoinChainService=new FfiConverterObjectWithCallbacks(uniffiTypeBitcoinChainServiceImplObjectFactory);// Add a vtavble for the callbacks that go in BitcoinChainService.
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceBitcoinChainService={// Create the VTable using a series of closures.
// ts automatically converts these into C callback functions.
vtable:{getAddressUtxos:(uniffiHandle,address,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeBitcoinChainService.lift(uniffiHandle);return await jsCallback.getAddressUtxos(FfiConverterString.lift(address),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayTypeUtxo.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/ChainServiceError.instanceOf,/*lowerError:*/FfiConverterTypeChainServiceError.lower.bind(FfiConverterTypeChainServiceError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getTransactionStatus:(uniffiHandle,txid,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeBitcoinChainService.lift(uniffiHandle);return await jsCallback.getTransactionStatus(FfiConverterString.lift(txid),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeTxStatus.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/ChainServiceError.instanceOf,/*lowerError:*/FfiConverterTypeChainServiceError.lower.bind(FfiConverterTypeChainServiceError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getTransactionHex:(uniffiHandle,txid,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeBitcoinChainService.lift(uniffiHandle);return await jsCallback.getTransactionHex(FfiConverterString.lift(txid),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterString.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/ChainServiceError.instanceOf,/*lowerError:*/FfiConverterTypeChainServiceError.lower.bind(FfiConverterTypeChainServiceError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},broadcastTransaction:(uniffiHandle,tx,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeBitcoinChainService.lift(uniffiHandle);return await jsCallback.broadcastTransaction(FfiConverterString.lift(tx),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/ChainServiceError.instanceOf,/*lowerError:*/FfiConverterTypeChainServiceError.lower.bind(FfiConverterTypeChainServiceError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},recommendedFees:(uniffiHandle,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeBitcoinChainService.lift(uniffiHandle);return await jsCallback.recommendedFees({signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeRecommendedFees.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/ChainServiceError.instanceOf,/*lowerError:*/FfiConverterTypeChainServiceError.lower.bind(FfiConverterTypeChainServiceError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},uniffiFree:uniffiHandle=>{// BitcoinChainService: this will throw a stale handle error if the handle isn't found.
FfiConverterTypeBitcoinChainService.drop(uniffiHandle);}},register:()=>{nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(uniffiCallbackInterfaceBitcoinChainService.vtable);}};/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 *//**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */export class BreezSdk extends UniffiAbstractObject{[uniffiTypeNameSymbol]='BreezSdk';// No primary constructor declared for this class.
constructor(pointer){super();this[pointerLiteralSymbol]=pointer;this[destructorGuardSymbol]=uniffiTypeBreezSdkObjectFactory.bless(pointer);}/**
   * Registers a listener to receive SDK events
   *
   * # Arguments
   *
   * * `listener` - An implementation of the `EventListener` trait
   *
   * # Returns
   *
   * A unique identifier for the listener, which can be used to remove it later
   */async addEventListener(listener,asyncOpts_){const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeEventListener.lower(listener));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterString.lift.bind(FfiConverterString),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_);}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Initiates a Bitcoin purchase flow via an external provider (`MoonPay`).
   *
   * This method generates a URL that the user can open in a browser to complete
   * the Bitcoin purchase. The purchased Bitcoin will be sent to an automatically
   * generated deposit address.
   *
   * # Arguments
   *
   * * `request` - The purchase request containing optional amount and redirect URL
   *
   * # Returns
   *
   * A response containing the URL to open in a browser to complete the purchase
   */async buyBitcoin(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_buy_bitcoin(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeBuyBitcoinRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeBuyBitcoinResponse.lift.bind(FfiConverterTypeBuyBitcoinResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Cancels the ongoing leaf optimization.
   *
   * This method cancels the ongoing optimization and waits for it to fully stop.
   * The current round will complete before stopping. This method blocks
   * until the optimization has fully stopped and leaves reserved for optimization
   * are available again.
   *
   * If no optimization is running, this method returns immediately.
   */async cancelLeafOptimization(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_cancel_leaf_optimization(uniffiTypeBreezSdkObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async checkLightningAddressAvailable(req,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeCheckLightningAddressRequest.lower(req));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_i8,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_i8,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_i8,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_i8,/*liftFunc:*/FfiConverterBool.lift.bind(FfiConverterBool),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Verifies a message signature against the provided public key. The message
   * is SHA256 hashed before verification. The signature can be hex encoded
   * in either DER or compact format.
   */async checkMessage(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeCheckMessageRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeCheckMessageResponse.lift.bind(FfiConverterTypeCheckMessageResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async claimDeposit(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeClaimDepositRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeClaimDepositResponse.lift.bind(FfiConverterTypeClaimDepositResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async claimHtlcPayment(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeClaimHtlcPaymentRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeClaimHtlcPaymentResponse.lift.bind(FfiConverterTypeClaimHtlcPaymentResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async deleteLightningAddress(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(uniffiTypeBreezSdkObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Stops the SDK's background tasks
   *
   * This method stops the background tasks started by the `start()` method.
   * It should be called before your application terminates to ensure proper cleanup.
   *
   * # Returns
   *
   * Result containing either success or an `SdkError` if the background task couldn't be stopped
   */async disconnect(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(uniffiTypeBreezSdkObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async fetchConversionLimits(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_fetch_conversion_limits(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeFetchConversionLimitsRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeFetchConversionLimitsResponse.lift.bind(FfiConverterTypeFetchConversionLimitsResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Returns the balance of the wallet in satoshis
   */async getInfo(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeGetInfoRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeGetInfoResponse.lift.bind(FfiConverterTypeGetInfoResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Returns the current optimization progress snapshot.
   */getLeafOptimizationProgress(){return FfiConverterTypeOptimizationProgress.lift(uniffiCaller.rustCall(/*caller:*/callStatus=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_leaf_optimization_progress(uniffiTypeBreezSdkObjectFactory.clonePointer(this),callStatus);},/*liftString:*/FfiConverterString.lift));}async getLightningAddress(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(uniffiTypeBreezSdkObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterOptionalTypeLightningAddressInfo.lift.bind(FfiConverterOptionalTypeLightningAddressInfo),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async getPayment(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeGetPaymentRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeGetPaymentResponse.lift.bind(FfiConverterTypeGetPaymentResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Returns an instance of the [`TokenIssuer`] for managing token issuance.
   */getTokenIssuer(){return FfiConverterTypeTokenIssuer.lift(uniffiCaller.rustCall(/*caller:*/callStatus=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer(uniffiTypeBreezSdkObjectFactory.clonePointer(this),callStatus);},/*liftString:*/FfiConverterString.lift));}/**
   * Returns the metadata for the given token identifiers.
   *
   * Results are not guaranteed to be in the same order as the input token identifiers.
   *
   * If the metadata is not found locally in cache, it will be queried from
   * the Spark network and then cached.
   */async getTokensMetadata(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeGetTokensMetadataRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeGetTokensMetadataResponse.lift.bind(FfiConverterTypeGetTokensMetadataResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Returns the user settings for the wallet.
   *
   * Some settings are fetched from the Spark network so network requests are performed.
   */async getUserSettings(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings(uniffiTypeBreezSdkObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeUserSettings.lift.bind(FfiConverterTypeUserSettings),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * List fiat currencies for which there is a known exchange rate,
   * sorted by the canonical name of the currency.
   */async listFiatCurrencies(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(uniffiTypeBreezSdkObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeListFiatCurrenciesResponse.lift.bind(FfiConverterTypeListFiatCurrenciesResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * List the latest rates of fiat currencies, sorted by name.
   */async listFiatRates(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(uniffiTypeBreezSdkObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeListFiatRatesResponse.lift.bind(FfiConverterTypeListFiatRatesResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Lists payments from the storage with pagination
   *
   * This method provides direct access to the payment history stored in the database.
   * It returns payments in reverse chronological order (newest first).
   *
   * # Arguments
   *
   * * `request` - Contains pagination parameters (offset and limit)
   *
   * # Returns
   *
   * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
   * * `Err(SdkError)` - If there was an error accessing the storage
   */async listPayments(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeListPaymentsRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeListPaymentsResponse.lift.bind(FfiConverterTypeListPaymentsResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async listUnclaimedDeposits(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeListUnclaimedDepositsRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeListUnclaimedDepositsResponse.lift.bind(FfiConverterTypeListUnclaimedDepositsResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Performs LNURL-auth with the service.
   *
   * This method implements the LNURL-auth protocol as specified in LUD-04 and LUD-05.
   * It derives a domain-specific linking key, signs the challenge, and sends the
   * authentication request to the service.
   */async lnurlAuth(requestData,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_auth(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeLnurlAuthRequestDetails.lower(requestData));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeLnurlCallbackStatus.lift.bind(FfiConverterTypeLnurlCallbackStatus),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async lnurlPay(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeLnurlPayRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeLnurlPayResponse.lift.bind(FfiConverterTypeLnurlPayResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Performs an LNURL withdraw operation for the amount of satoshis to
   * withdraw and the LNURL withdraw request details. The LNURL withdraw request
   * details can be obtained from calling [`BreezSdk::parse`].
   *
   * The method generates a Lightning invoice for the withdraw amount, stores
   * the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
   * invoice.
   *
   * If the `completion_timeout_secs` parameter is provided and greater than 0, the
   * method will wait for the payment to be completed within that period. If the
   * withdraw is completed within the timeout, the `payment` field in the response
   * will be set with the payment details. If the `completion_timeout_secs`
   * parameter is not provided or set to 0, the method will not wait for the payment
   * to be completed. If the withdraw is not completed within the
   * timeout, the `payment` field will be empty.
   *
   * # Arguments
   *
   * * `request` - The LNURL withdraw request
   *
   * # Returns
   *
   * Result containing either:
   * * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
   * * `SdkError` - If there was an error during the withdraw process
   */async lnurlWithdraw(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeLnurlWithdrawRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeLnurlWithdrawResponse.lift.bind(FfiConverterTypeLnurlWithdrawResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async parse(input,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_parse(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterString.lower(input));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeInputType.lift.bind(FfiConverterTypeInputType),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async prepareLnurlPay(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypePrepareLnurlPayRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypePrepareLnurlPayResponse.lift.bind(FfiConverterTypePrepareLnurlPayResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async prepareSendPayment(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypePrepareSendPaymentRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypePrepareSendPaymentResponse.lift.bind(FfiConverterTypePrepareSendPaymentResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async receivePayment(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeReceivePaymentRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeReceivePaymentResponse.lift.bind(FfiConverterTypeReceivePaymentResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Get the recommended BTC fees based on the configured chain service.
   */async recommendedFees(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees(uniffiTypeBreezSdkObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeRecommendedFees.lift.bind(FfiConverterTypeRecommendedFees),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async refundDeposit(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeRefundDepositRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeRefundDepositResponse.lift.bind(FfiConverterTypeRefundDepositResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async registerLightningAddress(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeRegisterLightningAddressRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeLightningAddressInfo.lift.bind(FfiConverterTypeLightningAddressInfo),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Removes a previously registered event listener
   *
   * # Arguments
   *
   * * `id` - The listener ID returned from `add_event_listener`
   *
   * # Returns
   *
   * `true` if the listener was found and removed, `false` otherwise
   */async removeEventListener(id,asyncOpts_){const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterString.lower(id));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_i8,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_i8,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_i8,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_i8,/*liftFunc:*/FfiConverterBool.lift.bind(FfiConverterBool),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_);}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async sendPayment(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeSendPaymentRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeSendPaymentResponse.lift.bind(FfiConverterTypeSendPaymentResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Signs a message with the wallet's identity key. The message is SHA256
   * hashed before signing. The returned signature will be hex encoded in
   * DER format by default, or compact format if specified.
   */async signMessage(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeSignMessageRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeSignMessageResponse.lift.bind(FfiConverterTypeSignMessageResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Starts leaf optimization in the background.
   *
   * This method spawns the optimization work in a background task and returns
   * immediately. Progress is reported via events.
   * If optimization is already running, no new task will be started.
   */startLeafOptimization(){uniffiCaller.rustCall(/*caller:*/callStatus=>{nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_start_leaf_optimization(uniffiTypeBreezSdkObjectFactory.clonePointer(this),callStatus);},/*liftString:*/FfiConverterString.lift);}/**
   * Synchronizes the wallet with the Spark network
   */async syncWallet(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeSyncWalletRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeSyncWalletResponse.lift.bind(FfiConverterTypeSyncWalletResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Updates the user settings for the wallet.
   *
   * Some settings are updated on the Spark network so network requests may be performed.
   */async updateUserSettings(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings(uniffiTypeBreezSdkObjectFactory.clonePointer(this),FfiConverterTypeUpdateUserSettingsRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */uniffiDestroy(){const ptr=this[destructorGuardSymbol];if(ptr!==undefined){const pointer=uniffiTypeBreezSdkObjectFactory.pointer(this);uniffiTypeBreezSdkObjectFactory.freePointer(pointer);uniffiTypeBreezSdkObjectFactory.unbless(ptr);delete this[destructorGuardSymbol];}}static instanceOf(obj){return uniffiTypeBreezSdkObjectFactory.isConcreteType(obj);}}const uniffiTypeBreezSdkObjectFactory={create(pointer){const instance=Object.create(BreezSdk.prototype);instance[pointerLiteralSymbol]=pointer;instance[destructorGuardSymbol]=this.bless(pointer);instance[uniffiTypeNameSymbol]='BreezSdk';return instance;},bless(p){return uniffiCaller.rustCall(/*caller:*/status=>nativeModule().ubrn_uniffi_internal_fn_method_breezsdk_ffi__bless_pointer(p,status),/*liftString:*/FfiConverterString.lift);},unbless(ptr){ptr.markDestroyed();},pointer(obj){if(obj[destructorGuardSymbol]===undefined){throw new UniffiInternalError.UnexpectedNullPointer();}return obj[pointerLiteralSymbol];},clonePointer(obj){const pointer=this.pointer(obj);return uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_breezsdk(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},freePointer(pointer){uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_breezsdk(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},isConcreteType(obj){return obj[destructorGuardSymbol]&&obj[uniffiTypeNameSymbol]==='BreezSdk';}};// FfiConverter for BreezSdkInterface
const FfiConverterTypeBreezSdk=new FfiConverterObject(uniffiTypeBreezSdkObjectFactory);/**
 * External signer trait that can be implemented by users and passed to the SDK.
 *
 * This trait mirrors the `BreezSigner` trait but uses FFI-compatible types (bytes, strings)
 * instead of Rust-specific types. This allows it to be exposed through FFI and WASM bindings.
 *
 * All methods accept and return simple types:
 * - Derivation paths as strings (e.g., "m/44'/0'/0'")
 * - Public keys, signatures, and other crypto primitives as Vec<u8>
 * - Spark-specific types as serialized representations
 *
 * Errors are returned as `SignerError` for FFI compatibility.
 *//**
 * External signer trait that can be implemented by users and passed to the SDK.
 *
 * This trait mirrors the `BreezSigner` trait but uses FFI-compatible types (bytes, strings)
 * instead of Rust-specific types. This allows it to be exposed through FFI and WASM bindings.
 *
 * All methods accept and return simple types:
 * - Derivation paths as strings (e.g., "m/44'/0'/0'")
 * - Public keys, signatures, and other crypto primitives as Vec<u8>
 * - Spark-specific types as serialized representations
 *
 * Errors are returned as `SignerError` for FFI compatibility.
 */export class ExternalSignerImpl extends UniffiAbstractObject{[uniffiTypeNameSymbol]='ExternalSignerImpl';// No primary constructor declared for this class.
constructor(pointer){super();this[pointerLiteralSymbol]=pointer;this[destructorGuardSymbol]=uniffiTypeExternalSignerImplObjectFactory.bless(pointer);}/**
   * Returns the identity public key as 33 bytes (compressed secp256k1 key).
   *
   * See also: [JavaScript `getIdentityPublicKey`](https://docs.spark.money/wallets/spark-signer#get-identity-public-key)
   */identityPublicKey()/*throws*/{return FfiConverterTypePublicKeyBytes.lift(uniffiCaller.rustCallWithError(/*liftError:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError),/*caller:*/callStatus=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_identity_public_key(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),callStatus);},/*liftString:*/FfiConverterString.lift));}/**
   * Derives a public key for the given BIP32 derivation path.
   *
   * # Arguments
   * * `path` - BIP32 derivation path as a string (e.g., "m/44'/0'/0'/0/0")
   *
   * # Returns
   * The derived public key as 33 bytes, or a `SignerError`
   *
   * See also: [JavaScript `getPublicKeyFromDerivation`](https://docs.spark.money/wallets/spark-signer#get-public-key-from-derivation)
   */async derivePublicKey(path,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_derive_public_key(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterString.lower(path));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypePublicKeyBytes.lift.bind(FfiConverterTypePublicKeyBytes),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Signs a message using ECDSA at the given derivation path.
   *
   * The message should be a 32-byte digest (typically a hash of the original data).
   *
   * # Arguments
   * * `message` - The 32-byte message digest to sign
   * * `path` - BIP32 derivation path as a string
   *
   * # Returns
   * 64-byte compact ECDSA signature, or a `SignerError`
   */async signEcdsa(message,path,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterTypeMessageBytes.lower(message),FfiConverterString.lower(path));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeEcdsaSignatureBytes.lift.bind(FfiConverterTypeEcdsaSignatureBytes),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Signs a message using recoverable ECDSA at the given derivation path.
   *
   * The message should be a 32-byte digest (typically a hash of the original data).
   *
   * # Arguments
   * * `message` - The 32-byte message digest to sign
   * * `path` - BIP32 derivation path as a string
   *
   * # Returns
   * 65 bytes: recovery ID (31 + `recovery_id`) + 64-byte signature, or a `SignerError`
   */async signEcdsaRecoverable(message,path,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa_recoverable(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterTypeMessageBytes.lower(message),FfiConverterString.lower(path));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeRecoverableEcdsaSignatureBytes.lift.bind(FfiConverterTypeRecoverableEcdsaSignatureBytes),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Encrypts a message using ECIES at the given derivation path.
   *
   * # Arguments
   * * `message` - The message to encrypt
   * * `path` - BIP32 derivation path for the encryption key
   *
   * # Returns
   * Encrypted data, or a `SignerError`
   */async encryptEcies(message,path,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_ecies(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterArrayBuffer.lower(message),FfiConverterString.lower(path));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayBuffer.lift.bind(FfiConverterArrayBuffer),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Decrypts a message using ECIES at the given derivation path.
   *
   * # Arguments
   * * `message` - The encrypted message
   * * `path` - BIP32 derivation path for the decryption key
   *
   * # Returns
   * Decrypted data, or a `SignerError`
   *
   * See also: [JavaScript `decryptEcies`](https://docs.spark.money/wallets/spark-signer#decrypt-ecies)
   */async decryptEcies(message,path,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_decrypt_ecies(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterArrayBuffer.lower(message),FfiConverterString.lower(path));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayBuffer.lift.bind(FfiConverterArrayBuffer),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Signs a hash using Schnorr signature at the given derivation path.
   *
   * # Arguments
   * * `hash` - The 32-byte hash to sign (must be 32 bytes)
   * * `path` - BIP32 derivation path as a string
   *
   * # Returns
   * 64-byte Schnorr signature, or a `SignerError`
   */async signHashSchnorr(hash,path,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_hash_schnorr(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterArrayBuffer.lower(hash),FfiConverterString.lower(path));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeSchnorrSignatureBytes.lift.bind(FfiConverterTypeSchnorrSignatureBytes),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * HMAC-SHA256 of a message at the given derivation path.
   *
   * # Arguments
   * * `message` - The message to hash
   * * `path` - BIP32 derivation path as a string
   *
   * # Returns
   * 32-byte HMAC-SHA256, or a `SignerError`
   *
   * See also: [JavaScript `htlcHMAC`](https://docs.spark.money/wallets/spark-signer#generate-htlc-hmac)
   */async hmacSha256(message,path,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_hmac_sha256(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterArrayBuffer.lower(message),FfiConverterString.lower(path));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeHashedMessageBytes.lift.bind(FfiConverterTypeHashedMessageBytes),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Generates Frost signing commitments for multi-party signing.
   *
   * # Returns
   * Frost commitments with nonces, or a `SignerError`
   *
   * See also: [JavaScript `getRandomSigningCommitment`](https://docs.spark.money/wallets/spark-signer#get-random-signing-commitment)
   */async generateRandomSigningCommitment(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_signing_commitment(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeExternalFrostCommitments.lift.bind(FfiConverterTypeExternalFrostCommitments),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Gets the public key for a specific tree node in the Spark wallet.
   *
   * # Arguments
   * * `id` - The tree node identifier
   *
   * # Returns
   * The public key for the node, or a `SignerError`
   */async getPublicKeyForNode(id,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_for_node(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterTypeExternalTreeNodeId.lower(id));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypePublicKeyBytes.lift.bind(FfiConverterTypePublicKeyBytes),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Generates a random secret that is encrypted and known only to the signer.
   *
   * This method creates a new random secret and returns it in encrypted form.
   * The plaintext secret never leaves the signer boundary, providing a secure way
   * to create secrets that can be referenced in subsequent operations without
   * exposing them.
   *
   * This is conceptually similar to Spark's key derivation system where secrets
   * are represented by opaque references (like tree node IDs or Random) rather than raw values.
   * The encrypted secret can be passed to other signer methods that need to operate
   * on it, while keeping the actual secret material protected within the signer.
   *
   * # Returns
   * An encrypted secret that can be used in subsequent signer operations,
   * or a `SignerError` if generation fails.
   *
   * See also: [Key Derivation System](https://docs.spark.money/wallets/spark-signer#the-keyderivation-system)
   */async generateRandomSecret(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_secret(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeExternalEncryptedSecret.lift.bind(FfiConverterTypeExternalEncryptedSecret),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Gets an encrypted static deposit secret by index.
   *
   * # Arguments
   * * `index` - The index of the static deposit secret
   *
   * # Returns
   * The encrypted secret, or a `SignerError`
   *
   * This is the encrypted version of: [JavaScript `getStaticDepositSecretKey`](https://docs.spark.money/wallets/spark-signer#get-static-deposit-secret-key)
   */async staticDepositSecretEncrypted(index,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_static_deposit_secret_encrypted(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterUInt32.lower(index));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeExternalSecretSource.lift.bind(FfiConverterTypeExternalSecretSource),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Gets a static deposit secret by index.
   *
   * # Arguments
   * * `index` - The index of the static deposit secret
   *
   * # Returns
   * The 32-byte secret, or a `SignerError`
   *
   * See also: [JavaScript `getStaticDepositSecretKey`](https://docs.spark.money/wallets/spark-signer#get-static-deposit-secret-key)
   */async staticDepositSecret(index,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_static_deposit_secret(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterUInt32.lower(index));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeSecretBytes.lift.bind(FfiConverterTypeSecretBytes),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Gets a static deposit signing public key by index.
   *
   * # Arguments
   * * `index` - The index of the static deposit public signing key
   *
   * # Returns
   * The 33-byte public key, or a `SignerError`
   *
   * See also: [JavaScript `getStaticDepositSigningKey`](https://docs.spark.money/wallets/spark-signer#get-static-deposit-signing-key)
   */async staticDepositSigningKey(index,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_static_deposit_signing_key(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterUInt32.lower(index));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypePublicKeyBytes.lift.bind(FfiConverterTypePublicKeyBytes),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Subtracts one secret from another.
   *
   * This is a lower-level primitive used as part of key tweaking operations.
   *
   * # Arguments
   * * `signing_key` - The first secret
   * * `new_signing_key` - The second secret to subtract
   *
   * # Returns
   * The resulting secret, or a `SignerError`
   *
   * See also: [JavaScript `subtractSplitAndEncrypt`](https://docs.spark.money/wallets/spark-signer#subtract,-split,-and-encrypt)
   * (this method provides the subtraction step of that higher-level operation)
   */async subtractSecrets(signingKey,newSigningKey,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_subtract_secrets(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterTypeExternalSecretSource.lower(signingKey),FfiConverterTypeExternalSecretSource.lower(newSigningKey));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeExternalSecretSource.lift.bind(FfiConverterTypeExternalSecretSource),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Splits a secret with proofs using Shamir's Secret Sharing.
   *
   * # Arguments
   * * `secret` - The secret to split
   * * `threshold` - Minimum number of shares needed to reconstruct
   * * `num_shares` - Total number of shares to create
   *
   * # Returns
   * Vector of verifiable secret shares, or a `SignerError`
   *
   * See also: [JavaScript `splitSecretWithProofs`](https://docs.spark.money/wallets/spark-signer#split-secret-with-proofs)
   */async splitSecretWithProofs(secret,threshold,numShares,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_split_secret_with_proofs(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterTypeExternalSecretToSplit.lower(secret),FfiConverterUInt32.lower(threshold),FfiConverterUInt32.lower(numShares));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayTypeExternalVerifiableSecretShare.lift.bind(FfiConverterArrayTypeExternalVerifiableSecretShare),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Encrypts a secret for a specific receiver's public key.
   *
   * # Arguments
   * * `encrypted_secret` - The encrypted secret to re-encrypt
   * * `receiver_public_key` - The receiver's 33-byte public key
   *
   * # Returns
   * Encrypted data for the receiver, or a `SignerError`
   */async encryptSecretForReceiver(encryptedSecret,receiverPublicKey,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_secret_for_receiver(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterTypeExternalEncryptedSecret.lower(encryptedSecret),FfiConverterTypePublicKeyBytes.lower(receiverPublicKey));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayBuffer.lift.bind(FfiConverterArrayBuffer),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Gets the public key from a secret.
   *
   * # Arguments
   * * `secret` - The secret
   *
   * # Returns
   * The corresponding 33-byte public key, or a `SignerError`
   *
   * See also: [JavaScript `getPublicKeyFromDerivation`](https://docs.spark.money/wallets/spark-signer#get-public-key-from-derivation)
   */async publicKeyFromSecret(secret,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_public_key_from_secret(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterTypeExternalSecretSource.lower(secret));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypePublicKeyBytes.lift.bind(FfiConverterTypePublicKeyBytes),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Signs using Frost protocol (multi-party signing).
   *
   * # Arguments
   * * `request` - The Frost signing request
   *
   * # Returns
   * A signature share, or a `SignerError`
   *
   * See also: [JavaScript `signFrost`](https://docs.spark.money/wallets/spark-signer#frost-signing)
   */async signFrost(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_sign_frost(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterTypeExternalSignFrostRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeExternalFrostSignatureShare.lift.bind(FfiConverterTypeExternalFrostSignatureShare),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Aggregates Frost signature shares into a final signature.
   *
   * # Arguments
   * * `request` - The Frost aggregation request
   *
   * # Returns
   * The aggregated Frost signature, or a `SignerError`
   *
   * See also: [JavaScript `aggregateFrost`](https://docs.spark.money/wallets/spark-signer#aggregate-frost-signatures)
   */async aggregateFrost(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_externalsigner_aggregate_frost(uniffiTypeExternalSignerImplObjectFactory.clonePointer(this),FfiConverterTypeExternalAggregateFrostRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeExternalFrostSignature.lift.bind(FfiConverterTypeExternalFrostSignature),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSignerError.lift.bind(FfiConverterTypeSignerError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */uniffiDestroy(){const ptr=this[destructorGuardSymbol];if(ptr!==undefined){const pointer=uniffiTypeExternalSignerImplObjectFactory.pointer(this);uniffiTypeExternalSignerImplObjectFactory.freePointer(pointer);uniffiTypeExternalSignerImplObjectFactory.unbless(ptr);delete this[destructorGuardSymbol];}}static instanceOf(obj){return uniffiTypeExternalSignerImplObjectFactory.isConcreteType(obj);}}const uniffiTypeExternalSignerImplObjectFactory={create(pointer){const instance=Object.create(ExternalSignerImpl.prototype);instance[pointerLiteralSymbol]=pointer;instance[destructorGuardSymbol]=this.bless(pointer);instance[uniffiTypeNameSymbol]='ExternalSignerImpl';return instance;},bless(p){return uniffiCaller.rustCall(/*caller:*/status=>nativeModule().ubrn_uniffi_internal_fn_method_externalsigner_ffi__bless_pointer(p,status),/*liftString:*/FfiConverterString.lift);},unbless(ptr){ptr.markDestroyed();},pointer(obj){if(obj[destructorGuardSymbol]===undefined){throw new UniffiInternalError.UnexpectedNullPointer();}return obj[pointerLiteralSymbol];},clonePointer(obj){const pointer=this.pointer(obj);return uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_externalsigner(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},freePointer(pointer){uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_externalsigner(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},isConcreteType(obj){return obj[destructorGuardSymbol]&&obj[uniffiTypeNameSymbol]==='ExternalSignerImpl';}};// FfiConverter for ExternalSigner
const FfiConverterTypeExternalSigner=new FfiConverterObjectWithCallbacks(uniffiTypeExternalSignerImplObjectFactory);// Add a vtavble for the callbacks that go in ExternalSigner.
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceExternalSigner={// Create the VTable using a series of closures.
// ts automatically converts these into C callback functions.
vtable:{identityPublicKey:uniffiHandle=>{const uniffiMakeCall=()=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return jsCallback.identityPublicKey();};const uniffiResult=UniffiResult.ready();const uniffiHandleSuccess=obj=>{UniffiResult.writeSuccess(uniffiResult,FfiConverterTypePublicKeyBytes.lower(obj));};const uniffiHandleError=(code,errBuf)=>{UniffiResult.writeError(uniffiResult,code,errBuf);};uniffiTraitInterfaceCallWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return uniffiResult;},derivePublicKey:(uniffiHandle,path,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.derivePublicKey(FfiConverterString.lift(path),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypePublicKeyBytes.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},signEcdsa:(uniffiHandle,message,path,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.signEcdsa(FfiConverterTypeMessageBytes.lift(message),FfiConverterString.lift(path),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeEcdsaSignatureBytes.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},signEcdsaRecoverable:(uniffiHandle,message,path,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.signEcdsaRecoverable(FfiConverterTypeMessageBytes.lift(message),FfiConverterString.lift(path),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeRecoverableEcdsaSignatureBytes.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},encryptEcies:(uniffiHandle,message,path,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.encryptEcies(FfiConverterArrayBuffer.lift(message),FfiConverterString.lift(path),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayBuffer.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},decryptEcies:(uniffiHandle,message,path,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.decryptEcies(FfiConverterArrayBuffer.lift(message),FfiConverterString.lift(path),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayBuffer.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},signHashSchnorr:(uniffiHandle,hash,path,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.signHashSchnorr(FfiConverterArrayBuffer.lift(hash),FfiConverterString.lift(path),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeSchnorrSignatureBytes.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},hmacSha256:(uniffiHandle,message,path,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.hmacSha256(FfiConverterArrayBuffer.lift(message),FfiConverterString.lift(path),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeHashedMessageBytes.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},generateRandomSigningCommitment:(uniffiHandle,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.generateRandomSigningCommitment({signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeExternalFrostCommitments.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getPublicKeyForNode:(uniffiHandle,id,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.getPublicKeyForNode(FfiConverterTypeExternalTreeNodeId.lift(id),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypePublicKeyBytes.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},generateRandomSecret:(uniffiHandle,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.generateRandomSecret({signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeExternalEncryptedSecret.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},staticDepositSecretEncrypted:(uniffiHandle,index,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.staticDepositSecretEncrypted(FfiConverterUInt32.lift(index),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeExternalSecretSource.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},staticDepositSecret:(uniffiHandle,index,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.staticDepositSecret(FfiConverterUInt32.lift(index),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeSecretBytes.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},staticDepositSigningKey:(uniffiHandle,index,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.staticDepositSigningKey(FfiConverterUInt32.lift(index),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypePublicKeyBytes.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},subtractSecrets:(uniffiHandle,signingKey,newSigningKey,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.subtractSecrets(FfiConverterTypeExternalSecretSource.lift(signingKey),FfiConverterTypeExternalSecretSource.lift(newSigningKey),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeExternalSecretSource.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},splitSecretWithProofs:(uniffiHandle,secret,threshold,numShares,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.splitSecretWithProofs(FfiConverterTypeExternalSecretToSplit.lift(secret),FfiConverterUInt32.lift(threshold),FfiConverterUInt32.lift(numShares),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayTypeExternalVerifiableSecretShare.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},encryptSecretForReceiver:(uniffiHandle,encryptedSecret,receiverPublicKey,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.encryptSecretForReceiver(FfiConverterTypeExternalEncryptedSecret.lift(encryptedSecret),FfiConverterTypePublicKeyBytes.lift(receiverPublicKey),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayBuffer.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},publicKeyFromSecret:(uniffiHandle,secret,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.publicKeyFromSecret(FfiConverterTypeExternalSecretSource.lift(secret),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypePublicKeyBytes.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},signFrost:(uniffiHandle,request,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.signFrost(FfiConverterTypeExternalSignFrostRequest.lift(request),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeExternalFrostSignatureShare.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},aggregateFrost:(uniffiHandle,request,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeExternalSigner.lift(uniffiHandle);return await jsCallback.aggregateFrost(FfiConverterTypeExternalAggregateFrostRequest.lift(request),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeExternalFrostSignature.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/SignerError.instanceOf,/*lowerError:*/FfiConverterTypeSignerError.lower.bind(FfiConverterTypeSignerError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},uniffiFree:uniffiHandle=>{// ExternalSigner: this will throw a stale handle error if the handle isn't found.
FfiConverterTypeExternalSigner.drop(uniffiHandle);}},register:()=>{nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_externalsigner(uniffiCallbackInterfaceExternalSigner.vtable);}};/**
 * Trait covering fiat-related functionality
 *//**
 * Trait covering fiat-related functionality
 */export class FiatServiceImpl extends UniffiAbstractObject{[uniffiTypeNameSymbol]='FiatServiceImpl';// No primary constructor declared for this class.
constructor(pointer){super();this[pointerLiteralSymbol]=pointer;this[destructorGuardSymbol]=uniffiTypeFiatServiceImplObjectFactory.bless(pointer);}/**
   * List all supported fiat currencies for which there is a known exchange rate.
   */async fetchFiatCurrencies(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies(uniffiTypeFiatServiceImplObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayTypeFiatCurrency.lift.bind(FfiConverterArrayTypeFiatCurrency),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeServiceConnectivityError.lift.bind(FfiConverterTypeServiceConnectivityError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Get the live rates from the server.
   */async fetchFiatRates(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates(uniffiTypeFiatServiceImplObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayTypeRate.lift.bind(FfiConverterArrayTypeRate),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeServiceConnectivityError.lift.bind(FfiConverterTypeServiceConnectivityError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */uniffiDestroy(){const ptr=this[destructorGuardSymbol];if(ptr!==undefined){const pointer=uniffiTypeFiatServiceImplObjectFactory.pointer(this);uniffiTypeFiatServiceImplObjectFactory.freePointer(pointer);uniffiTypeFiatServiceImplObjectFactory.unbless(ptr);delete this[destructorGuardSymbol];}}static instanceOf(obj){return uniffiTypeFiatServiceImplObjectFactory.isConcreteType(obj);}}const uniffiTypeFiatServiceImplObjectFactory={create(pointer){const instance=Object.create(FiatServiceImpl.prototype);instance[pointerLiteralSymbol]=pointer;instance[destructorGuardSymbol]=this.bless(pointer);instance[uniffiTypeNameSymbol]='FiatServiceImpl';return instance;},bless(p){return uniffiCaller.rustCall(/*caller:*/status=>nativeModule().ubrn_uniffi_internal_fn_method_fiatservice_ffi__bless_pointer(p,status),/*liftString:*/FfiConverterString.lift);},unbless(ptr){ptr.markDestroyed();},pointer(obj){if(obj[destructorGuardSymbol]===undefined){throw new UniffiInternalError.UnexpectedNullPointer();}return obj[pointerLiteralSymbol];},clonePointer(obj){const pointer=this.pointer(obj);return uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_fiatservice(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},freePointer(pointer){uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_fiatservice(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},isConcreteType(obj){return obj[destructorGuardSymbol]&&obj[uniffiTypeNameSymbol]==='FiatServiceImpl';}};// FfiConverter for FiatService
const FfiConverterTypeFiatService=new FfiConverterObjectWithCallbacks(uniffiTypeFiatServiceImplObjectFactory);// Add a vtavble for the callbacks that go in FiatService.
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFiatService={// Create the VTable using a series of closures.
// ts automatically converts these into C callback functions.
vtable:{fetchFiatCurrencies:(uniffiHandle,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeFiatService.lift(uniffiHandle);return await jsCallback.fetchFiatCurrencies({signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayTypeFiatCurrency.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/ServiceConnectivityError.instanceOf,/*lowerError:*/FfiConverterTypeServiceConnectivityError.lower.bind(FfiConverterTypeServiceConnectivityError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},fetchFiatRates:(uniffiHandle,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeFiatService.lift(uniffiHandle);return await jsCallback.fetchFiatRates({signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayTypeRate.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/ServiceConnectivityError.instanceOf,/*lowerError:*/FfiConverterTypeServiceConnectivityError.lower.bind(FfiConverterTypeServiceConnectivityError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},uniffiFree:uniffiHandle=>{// FiatService: this will throw a stale handle error if the handle isn't found.
FfiConverterTypeFiatService.drop(uniffiHandle);}},register:()=>{nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice(uniffiCallbackInterfaceFiatService.vtable);}};/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 *//**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */export class PaymentObserverImpl extends UniffiAbstractObject{[uniffiTypeNameSymbol]='PaymentObserverImpl';// No primary constructor declared for this class.
constructor(pointer){super();this[pointerLiteralSymbol]=pointer;this[destructorGuardSymbol]=uniffiTypePaymentObserverImplObjectFactory.bless(pointer);}/**
   * Called before Lightning, Spark or onchain Bitcoin payments are made
   */async beforeSend(payments,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(uniffiTypePaymentObserverImplObjectFactory.clonePointer(this),FfiConverterArrayTypeProvisionalPayment.lower(payments));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypePaymentObserverError.lift.bind(FfiConverterTypePaymentObserverError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */uniffiDestroy(){const ptr=this[destructorGuardSymbol];if(ptr!==undefined){const pointer=uniffiTypePaymentObserverImplObjectFactory.pointer(this);uniffiTypePaymentObserverImplObjectFactory.freePointer(pointer);uniffiTypePaymentObserverImplObjectFactory.unbless(ptr);delete this[destructorGuardSymbol];}}static instanceOf(obj){return uniffiTypePaymentObserverImplObjectFactory.isConcreteType(obj);}}const uniffiTypePaymentObserverImplObjectFactory={create(pointer){const instance=Object.create(PaymentObserverImpl.prototype);instance[pointerLiteralSymbol]=pointer;instance[destructorGuardSymbol]=this.bless(pointer);instance[uniffiTypeNameSymbol]='PaymentObserverImpl';return instance;},bless(p){return uniffiCaller.rustCall(/*caller:*/status=>nativeModule().ubrn_uniffi_internal_fn_method_paymentobserver_ffi__bless_pointer(p,status),/*liftString:*/FfiConverterString.lift);},unbless(ptr){ptr.markDestroyed();},pointer(obj){if(obj[destructorGuardSymbol]===undefined){throw new UniffiInternalError.UnexpectedNullPointer();}return obj[pointerLiteralSymbol];},clonePointer(obj){const pointer=this.pointer(obj);return uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_paymentobserver(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},freePointer(pointer){uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_paymentobserver(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},isConcreteType(obj){return obj[destructorGuardSymbol]&&obj[uniffiTypeNameSymbol]==='PaymentObserverImpl';}};// FfiConverter for PaymentObserver
const FfiConverterTypePaymentObserver=new FfiConverterObjectWithCallbacks(uniffiTypePaymentObserverImplObjectFactory);// Add a vtavble for the callbacks that go in PaymentObserver.
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePaymentObserver={// Create the VTable using a series of closures.
// ts automatically converts these into C callback functions.
vtable:{beforeSend:(uniffiHandle,payments,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypePaymentObserver.lift(uniffiHandle);return await jsCallback.beforeSend(FfiConverterArrayTypeProvisionalPayment.lift(payments),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/PaymentObserverError.instanceOf,/*lowerError:*/FfiConverterTypePaymentObserverError.lower.bind(FfiConverterTypePaymentObserverError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},uniffiFree:uniffiHandle=>{// PaymentObserver: this will throw a stale handle error if the handle isn't found.
FfiConverterTypePaymentObserver.drop(uniffiHandle);}},register:()=>{nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(uniffiCallbackInterfacePaymentObserver.vtable);}};export class RestClientImpl extends UniffiAbstractObject{[uniffiTypeNameSymbol]='RestClientImpl';// No primary constructor declared for this class.
constructor(pointer){super();this[pointerLiteralSymbol]=pointer;this[destructorGuardSymbol]=uniffiTypeRestClientImplObjectFactory.bless(pointer);}/**
   * Makes a GET request and logs on DEBUG.
   * ### Arguments
   * - `url`: the URL on which GET will be called
   * - `headers`: optional headers that will be set on the request
   */async getRequest(url,headers,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_restclient_get_request(uniffiTypeRestClientImplObjectFactory.clonePointer(this),FfiConverterString.lower(url),FfiConverterOptionalMapStringString.lower(headers));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeRestResponse.lift.bind(FfiConverterTypeRestResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeServiceConnectivityError.lift.bind(FfiConverterTypeServiceConnectivityError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Makes a POST request, and logs on DEBUG.
   * ### Arguments
   * - `url`: the URL on which POST will be called
   * - `headers`: the optional POST headers
   * - `body`: the optional POST body
   */async postRequest(url,headers,body,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_restclient_post_request(uniffiTypeRestClientImplObjectFactory.clonePointer(this),FfiConverterString.lower(url),FfiConverterOptionalMapStringString.lower(headers),FfiConverterOptionalString.lower(body));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeRestResponse.lift.bind(FfiConverterTypeRestResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeServiceConnectivityError.lift.bind(FfiConverterTypeServiceConnectivityError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Makes a DELETE request, and logs on DEBUG.
   * ### Arguments
   * - `url`: the URL on which DELETE will be called
   * - `headers`: the optional DELETE headers
   * - `body`: the optional DELETE body
   */async deleteRequest(url,headers,body,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_restclient_delete_request(uniffiTypeRestClientImplObjectFactory.clonePointer(this),FfiConverterString.lower(url),FfiConverterOptionalMapStringString.lower(headers),FfiConverterOptionalString.lower(body));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeRestResponse.lift.bind(FfiConverterTypeRestResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeServiceConnectivityError.lift.bind(FfiConverterTypeServiceConnectivityError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */uniffiDestroy(){const ptr=this[destructorGuardSymbol];if(ptr!==undefined){const pointer=uniffiTypeRestClientImplObjectFactory.pointer(this);uniffiTypeRestClientImplObjectFactory.freePointer(pointer);uniffiTypeRestClientImplObjectFactory.unbless(ptr);delete this[destructorGuardSymbol];}}static instanceOf(obj){return uniffiTypeRestClientImplObjectFactory.isConcreteType(obj);}}const uniffiTypeRestClientImplObjectFactory={create(pointer){const instance=Object.create(RestClientImpl.prototype);instance[pointerLiteralSymbol]=pointer;instance[destructorGuardSymbol]=this.bless(pointer);instance[uniffiTypeNameSymbol]='RestClientImpl';return instance;},bless(p){return uniffiCaller.rustCall(/*caller:*/status=>nativeModule().ubrn_uniffi_internal_fn_method_restclient_ffi__bless_pointer(p,status),/*liftString:*/FfiConverterString.lift);},unbless(ptr){ptr.markDestroyed();},pointer(obj){if(obj[destructorGuardSymbol]===undefined){throw new UniffiInternalError.UnexpectedNullPointer();}return obj[pointerLiteralSymbol];},clonePointer(obj){const pointer=this.pointer(obj);return uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_restclient(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},freePointer(pointer){uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_restclient(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},isConcreteType(obj){return obj[destructorGuardSymbol]&&obj[uniffiTypeNameSymbol]==='RestClientImpl';}};// FfiConverter for RestClient
const FfiConverterTypeRestClient=new FfiConverterObjectWithCallbacks(uniffiTypeRestClientImplObjectFactory);// Add a vtavble for the callbacks that go in RestClient.
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRestClient={// Create the VTable using a series of closures.
// ts automatically converts these into C callback functions.
vtable:{getRequest:(uniffiHandle,url,headers,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeRestClient.lift(uniffiHandle);return await jsCallback.getRequest(FfiConverterString.lift(url),FfiConverterOptionalMapStringString.lift(headers),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeRestResponse.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/ServiceConnectivityError.instanceOf,/*lowerError:*/FfiConverterTypeServiceConnectivityError.lower.bind(FfiConverterTypeServiceConnectivityError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},postRequest:(uniffiHandle,url,headers,body,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeRestClient.lift(uniffiHandle);return await jsCallback.postRequest(FfiConverterString.lift(url),FfiConverterOptionalMapStringString.lift(headers),FfiConverterOptionalString.lift(body),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeRestResponse.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/ServiceConnectivityError.instanceOf,/*lowerError:*/FfiConverterTypeServiceConnectivityError.lower.bind(FfiConverterTypeServiceConnectivityError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},deleteRequest:(uniffiHandle,url,headers,body,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeRestClient.lift(uniffiHandle);return await jsCallback.deleteRequest(FfiConverterString.lift(url),FfiConverterOptionalMapStringString.lift(headers),FfiConverterOptionalString.lift(body),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypeRestResponse.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/ServiceConnectivityError.instanceOf,/*lowerError:*/FfiConverterTypeServiceConnectivityError.lower.bind(FfiConverterTypeServiceConnectivityError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},uniffiFree:uniffiHandle=>{// RestClient: this will throw a stale handle error if the handle isn't found.
FfiConverterTypeRestClient.drop(uniffiHandle);}},register:()=>{nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient(uniffiCallbackInterfaceRestClient.vtable);}};/**
 * Builder for creating `BreezSdk` instances with customizable components.
 *//**
 * Builder for creating `BreezSdk` instances with customizable components.
 */export class SdkBuilder extends UniffiAbstractObject{[uniffiTypeNameSymbol]='SdkBuilder';/**
   * Creates a new `SdkBuilder` with the provided configuration.
   * Arguments:
   * - `config`: The configuration to be used.
   * - `seed`: The seed for wallet generation.
   */constructor(config,seed){super();const pointer=uniffiCaller.rustCall(/*caller:*/callStatus=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(FfiConverterTypeConfig.lower(config),FfiConverterTypeSeed.lower(seed),callStatus);},/*liftString:*/FfiConverterString.lift);this[pointerLiteralSymbol]=pointer;this[destructorGuardSymbol]=uniffiTypeSdkBuilderObjectFactory.bless(pointer);}/**
   * Builds the `BreezSdk` instance with the configured components.
   */async build(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(uniffiTypeSdkBuilderObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_pointer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_pointer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_pointer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_pointer,/*liftFunc:*/FfiConverterTypeBreezSdk.lift.bind(FfiConverterTypeBreezSdk),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Sets the chain service to be used by the SDK.
   * Arguments:
   * - `chain_service`: The chain service to be used.
   */async withChainService(chainService,asyncOpts_){const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(uniffiTypeSdkBuilderObjectFactory.clonePointer(this),FfiConverterTypeBitcoinChainService.lower(chainService));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_);}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Sets the root storage directory to initialize the default storage with.
   * This initializes both storage and real-time sync storage with the
   * default implementations.
   * Arguments:
   * - `storage_dir`: The data directory for storage.
   */async withDefaultStorage(storageDir,asyncOpts_){const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(uniffiTypeSdkBuilderObjectFactory.clonePointer(this),FfiConverterString.lower(storageDir));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_);}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Sets the fiat service to be used by the SDK.
   * Arguments:
   * - `fiat_service`: The fiat service to be used.
   */async withFiatService(fiatService,asyncOpts_){const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(uniffiTypeSdkBuilderObjectFactory.clonePointer(this),FfiConverterTypeFiatService.lower(fiatService));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_);}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Sets the key set type to be used by the SDK.
   * Arguments:
   * - `config`: Key set configuration containing the key set type, address index flag, and optional account number.
   */async withKeySet(config,asyncOpts_){const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(uniffiTypeSdkBuilderObjectFactory.clonePointer(this),FfiConverterTypeKeySetConfig.lower(config));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_);}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async withLnurlClient(lnurlClient,asyncOpts_){const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(uniffiTypeSdkBuilderObjectFactory.clonePointer(this),FfiConverterTypeRestClient.lower(lnurlClient));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_);}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Sets the payment observer to be used by the SDK.
   * Arguments:
   * - `payment_observer`: The payment observer to be used.
   */async withPaymentObserver(paymentObserver,asyncOpts_){const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(uniffiTypeSdkBuilderObjectFactory.clonePointer(this),FfiConverterTypePaymentObserver.lower(paymentObserver));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_);}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Sets the REST chain service to be used by the SDK.
   * Arguments:
   * - `url`: The base URL of the REST API.
   * - `api_type`: The API type to be used.
   * - `credentials`: Optional credentials for basic authentication.
   */async withRestChainService(url,apiType,credentials,asyncOpts_){const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(uniffiTypeSdkBuilderObjectFactory.clonePointer(this),FfiConverterString.lower(url),FfiConverterTypeChainApiType.lower(apiType),FfiConverterOptionalTypeCredentials.lower(credentials));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_);}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Sets the storage implementation to be used by the SDK.
   * Arguments:
   * - `storage`: The storage implementation to be used.
   */async withStorage(storage,asyncOpts_){const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(uniffiTypeSdkBuilderObjectFactory.clonePointer(this),FfiConverterTypeStorage.lower(storage));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_);}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */uniffiDestroy(){const ptr=this[destructorGuardSymbol];if(ptr!==undefined){const pointer=uniffiTypeSdkBuilderObjectFactory.pointer(this);uniffiTypeSdkBuilderObjectFactory.freePointer(pointer);uniffiTypeSdkBuilderObjectFactory.unbless(ptr);delete this[destructorGuardSymbol];}}static instanceOf(obj){return uniffiTypeSdkBuilderObjectFactory.isConcreteType(obj);}}const uniffiTypeSdkBuilderObjectFactory={create(pointer){const instance=Object.create(SdkBuilder.prototype);instance[pointerLiteralSymbol]=pointer;instance[destructorGuardSymbol]=this.bless(pointer);instance[uniffiTypeNameSymbol]='SdkBuilder';return instance;},bless(p){return uniffiCaller.rustCall(/*caller:*/status=>nativeModule().ubrn_uniffi_internal_fn_method_sdkbuilder_ffi__bless_pointer(p,status),/*liftString:*/FfiConverterString.lift);},unbless(ptr){ptr.markDestroyed();},pointer(obj){if(obj[destructorGuardSymbol]===undefined){throw new UniffiInternalError.UnexpectedNullPointer();}return obj[pointerLiteralSymbol];},clonePointer(obj){const pointer=this.pointer(obj);return uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_sdkbuilder(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},freePointer(pointer){uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_sdkbuilder(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},isConcreteType(obj){return obj[destructorGuardSymbol]&&obj[uniffiTypeNameSymbol]==='SdkBuilder';}};// FfiConverter for SdkBuilderInterface
const FfiConverterTypeSdkBuilder=new FfiConverterObject(uniffiTypeSdkBuilderObjectFactory);/**
 * Trait for persistent storage
 *//**
 * Trait for persistent storage
 */export class StorageImpl extends UniffiAbstractObject{[uniffiTypeNameSymbol]='StorageImpl';// No primary constructor declared for this class.
constructor(pointer){super();this[pointerLiteralSymbol]=pointer;this[destructorGuardSymbol]=uniffiTypeStorageImplObjectFactory.bless(pointer);}async deleteCachedItem(key,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterString.lower(key));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async getCachedItem(key,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterString.lower(key));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterOptionalString.lift.bind(FfiConverterOptionalString),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async setCachedItem(key,value,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterString.lower(key),FfiConverterString.lower(value));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Lists payments with optional filters and pagination
   *
   * # Arguments
   *
   * * `list_payments_request` - The request to list payments
   *
   * # Returns
   *
   * A vector of payments or a `StorageError`
   */async listPayments(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_payments(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterTypeListPaymentsRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayTypePayment.lift.bind(FfiConverterArrayTypePayment),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Inserts a payment into storage
   *
   * # Arguments
   *
   * * `payment` - The payment to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */async insertPayment(payment,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_insert_payment(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterTypePayment.lower(payment));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Inserts payment metadata into storage
   *
   * # Arguments
   *
   * * `payment_id` - The ID of the payment
   * * `metadata` - The metadata to insert
   *
   * # Returns
   *
   * Success or a `StorageError`
   */async insertPaymentMetadata(paymentId,metadata,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_insert_payment_metadata(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterString.lower(paymentId),FfiConverterTypePaymentMetadata.lower(metadata));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Gets a payment by its ID
   * # Arguments
   *
   * * `id` - The ID of the payment to retrieve
   *
   * # Returns
   *
   * The payment if found or None if not found
   */async getPaymentById(id,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterString.lower(id));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypePayment.lift.bind(FfiConverterTypePayment),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Gets a payment by its invoice
   * # Arguments
   *
   * * `invoice` - The invoice of the payment to retrieve
   * # Returns
   *
   * The payment if found or None if not found
   */async getPaymentByInvoice(invoice,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterString.lower(invoice));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterOptionalTypePayment.lift.bind(FfiConverterOptionalTypePayment),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Gets payments that have any of the specified parent payment IDs.
   * Used to load related payments for a set of parent payments.
   *
   * # Arguments
   *
   * * `parent_payment_ids` - The IDs of the parent payments
   *
   * # Returns
   *
   * A map of `parent_payment_id` -> Vec<Payment> or a `StorageError`
   */async getPaymentsByParentIds(parentPaymentIds,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_payments_by_parent_ids(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterArrayString.lower(parentPaymentIds));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterMapStringArrayTypePayment.lift.bind(FfiConverterMapStringArrayTypePayment),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Add a deposit to storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `amount_sats` - The amount of the deposit in sats
   *
   * # Returns
   *
   * Success or a `StorageError`
   */async addDeposit(txid,vout,amountSats,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_add_deposit(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout),FfiConverterUInt64.lower(amountSats));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Removes an unclaimed deposit from storage
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   *
   * # Returns
   *
   * Success or a `StorageError`
   */async deleteDeposit(txid,vout,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Lists all unclaimed deposits from storage
   * # Returns
   *
   * A vector of `DepositInfo` or a `StorageError`
   */async listDeposits(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_list_deposits(uniffiTypeStorageImplObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayTypeDepositInfo.lift.bind(FfiConverterArrayTypeDepositInfo),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Updates or inserts unclaimed deposit details
   * # Arguments
   *
   * * `txid` - The transaction ID of the deposit
   * * `vout` - The output index of the deposit
   * * `payload` - The payload for the update
   *
   * # Returns
   *
   * Success or a `StorageError`
   */async updateDeposit(txid,vout,payload,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_update_deposit(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout),FfiConverterTypeUpdateDepositPayload.lower(payload));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async setLnurlMetadata(metadata,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterArrayTypeSetLnurlMetadataItem.lower(metadata));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async addOutgoingChange(record,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_add_outgoing_change(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterTypeUnversionedRecordChange.lower(record));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_u64,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_u64,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_u64,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_u64,/*liftFunc:*/FfiConverterUInt64.lift.bind(FfiConverterUInt64),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async completeOutgoingSync(record,localRevision,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_complete_outgoing_sync(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterTypeRecord.lower(record),FfiConverterUInt64.lower(localRevision));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}async getPendingOutgoingChanges(limit,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_pending_outgoing_changes(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterUInt32.lower(limit));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayTypeOutgoingChange.lift.bind(FfiConverterArrayTypeOutgoingChange),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Get the last committed sync revision.
   *
   * The `sync_revision` table tracks the highest revision that has been committed
   * (i.e. acknowledged by the server or received from it). It does NOT include
   * pending outgoing queue ids. This value is used by the sync protocol to
   * request changes from the server.
   */async getLastRevision(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_last_revision(uniffiTypeStorageImplObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_u64,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_u64,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_u64,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_u64,/*liftFunc:*/FfiConverterUInt64.lift.bind(FfiConverterUInt64),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Insert incoming records from remote sync
   */async insertIncomingRecords(records,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_insert_incoming_records(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterArrayTypeRecord.lower(records));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Delete an incoming record after it has been processed
   */async deleteIncomingRecord(record,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_delete_incoming_record(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterTypeRecord.lower(record));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Get incoming records that need to be processed, up to the specified limit
   */async getIncomingRecords(limit,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_incoming_records(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterUInt32.lower(limit));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterArrayTypeIncomingChange.lift.bind(FfiConverterArrayTypeIncomingChange),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Get the latest outgoing record if any exists
   */async getLatestOutgoingChange(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_get_latest_outgoing_change(uniffiTypeStorageImplObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterOptionalTypeOutgoingChange.lift.bind(FfiConverterOptionalTypeOutgoingChange),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Update the sync state record from an incoming record
   */async updateRecordFromIncoming(record,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_storage_update_record_from_incoming(uniffiTypeStorageImplObjectFactory.clonePointer(this),FfiConverterTypeRecord.lower(record));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_void,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_void,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_void,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_void,/*liftFunc:*/_v=>{},/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeStorageError.lift.bind(FfiConverterTypeStorageError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */uniffiDestroy(){const ptr=this[destructorGuardSymbol];if(ptr!==undefined){const pointer=uniffiTypeStorageImplObjectFactory.pointer(this);uniffiTypeStorageImplObjectFactory.freePointer(pointer);uniffiTypeStorageImplObjectFactory.unbless(ptr);delete this[destructorGuardSymbol];}}static instanceOf(obj){return uniffiTypeStorageImplObjectFactory.isConcreteType(obj);}}const uniffiTypeStorageImplObjectFactory={create(pointer){const instance=Object.create(StorageImpl.prototype);instance[pointerLiteralSymbol]=pointer;instance[destructorGuardSymbol]=this.bless(pointer);instance[uniffiTypeNameSymbol]='StorageImpl';return instance;},bless(p){return uniffiCaller.rustCall(/*caller:*/status=>nativeModule().ubrn_uniffi_internal_fn_method_storage_ffi__bless_pointer(p,status),/*liftString:*/FfiConverterString.lift);},unbless(ptr){ptr.markDestroyed();},pointer(obj){if(obj[destructorGuardSymbol]===undefined){throw new UniffiInternalError.UnexpectedNullPointer();}return obj[pointerLiteralSymbol];},clonePointer(obj){const pointer=this.pointer(obj);return uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_storage(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},freePointer(pointer){uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_storage(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},isConcreteType(obj){return obj[destructorGuardSymbol]&&obj[uniffiTypeNameSymbol]==='StorageImpl';}};// FfiConverter for Storage
const FfiConverterTypeStorage=new FfiConverterObjectWithCallbacks(uniffiTypeStorageImplObjectFactory);// Add a vtavble for the callbacks that go in Storage.
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceStorage={// Create the VTable using a series of closures.
// ts automatically converts these into C callback functions.
vtable:{deleteCachedItem:(uniffiHandle,key,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.deleteCachedItem(FfiConverterString.lift(key),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getCachedItem:(uniffiHandle,key,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.getCachedItem(FfiConverterString.lift(key),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterOptionalString.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},setCachedItem:(uniffiHandle,key,value,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.setCachedItem(FfiConverterString.lift(key),FfiConverterString.lift(value),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},listPayments:(uniffiHandle,request,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.listPayments(FfiConverterTypeListPaymentsRequest.lift(request),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayTypePayment.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},insertPayment:(uniffiHandle,payment,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.insertPayment(FfiConverterTypePayment.lift(payment),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},insertPaymentMetadata:(uniffiHandle,paymentId,metadata,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.insertPaymentMetadata(FfiConverterString.lift(paymentId),FfiConverterTypePaymentMetadata.lift(metadata),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getPaymentById:(uniffiHandle,id,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.getPaymentById(FfiConverterString.lift(id),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterTypePayment.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getPaymentByInvoice:(uniffiHandle,invoice,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.getPaymentByInvoice(FfiConverterString.lift(invoice),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterOptionalTypePayment.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getPaymentsByParentIds:(uniffiHandle,parentPaymentIds,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.getPaymentsByParentIds(FfiConverterArrayString.lift(parentPaymentIds),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterMapStringArrayTypePayment.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},addDeposit:(uniffiHandle,txid,vout,amountSats,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.addDeposit(FfiConverterString.lift(txid),FfiConverterUInt32.lift(vout),FfiConverterUInt64.lift(amountSats),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},deleteDeposit:(uniffiHandle,txid,vout,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.deleteDeposit(FfiConverterString.lift(txid),FfiConverterUInt32.lift(vout),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},listDeposits:(uniffiHandle,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.listDeposits({signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayTypeDepositInfo.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},updateDeposit:(uniffiHandle,txid,vout,payload,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.updateDeposit(FfiConverterString.lift(txid),FfiConverterUInt32.lift(vout),FfiConverterTypeUpdateDepositPayload.lift(payload),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},setLnurlMetadata:(uniffiHandle,metadata,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.setLnurlMetadata(FfiConverterArrayTypeSetLnurlMetadataItem.lift(metadata),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},addOutgoingChange:(uniffiHandle,record,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.addOutgoingChange(FfiConverterTypeUnversionedRecordChange.lift(record),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructU64 */{returnValue:FfiConverterUInt64.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructU64 */{returnValue:0n,// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},completeOutgoingSync:(uniffiHandle,record,localRevision,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.completeOutgoingSync(FfiConverterTypeRecord.lift(record),FfiConverterUInt64.lift(localRevision),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getPendingOutgoingChanges:(uniffiHandle,limit,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.getPendingOutgoingChanges(FfiConverterUInt32.lift(limit),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayTypeOutgoingChange.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getLastRevision:(uniffiHandle,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.getLastRevision({signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructU64 */{returnValue:FfiConverterUInt64.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructU64 */{returnValue:0n,// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},insertIncomingRecords:(uniffiHandle,records,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.insertIncomingRecords(FfiConverterArrayTypeRecord.lift(records),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},deleteIncomingRecord:(uniffiHandle,record,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.deleteIncomingRecord(FfiConverterTypeRecord.lift(record),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getIncomingRecords:(uniffiHandle,limit,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.getIncomingRecords(FfiConverterUInt32.lift(limit),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterArrayTypeIncomingChange.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},getLatestOutgoingChange:(uniffiHandle,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.getLatestOutgoingChange({signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:FfiConverterOptionalTypeOutgoingChange.lower(returnValue),callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructRustBuffer */{returnValue:/*empty*/new Uint8Array(0),// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},updateRecordFromIncoming:(uniffiHandle,record,uniffiFutureCallback,uniffiCallbackData)=>{const uniffiMakeCall=async signal=>{const jsCallback=FfiConverterTypeStorage.lift(uniffiHandle);return await jsCallback.updateRecordFromIncoming(FfiConverterTypeRecord.lift(record),{signal});};const uniffiHandleSuccess=returnValue=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{callStatus:uniffiCaller.createCallStatus()});};const uniffiHandleError=(code,errorBuf)=>{uniffiFutureCallback(uniffiCallbackData,/* UniffiForeignFutureStructVoid */{// TODO create callstatus with error.
callStatus:{code,errorBuf}});};const uniffiForeignFuture=uniffiTraitInterfaceCallAsyncWithError(/*makeCall:*/uniffiMakeCall,/*handleSuccess:*/uniffiHandleSuccess,/*handleError:*/uniffiHandleError,/*isErrorType:*/StorageError.instanceOf,/*lowerError:*/FfiConverterTypeStorageError.lower.bind(FfiConverterTypeStorageError),/*lowerString:*/FfiConverterString.lower);return UniffiResult.success(uniffiForeignFuture);},uniffiFree:uniffiHandle=>{// Storage: this will throw a stale handle error if the handle isn't found.
FfiConverterTypeStorage.drop(uniffiHandle);}},register:()=>{nativeModule().ubrn_uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(uniffiCallbackInterfaceStorage.vtable);}};export class TokenIssuer extends UniffiAbstractObject{[uniffiTypeNameSymbol]='TokenIssuer';// No primary constructor declared for this class.
constructor(pointer){super();this[pointerLiteralSymbol]=pointer;this[destructorGuardSymbol]=uniffiTypeTokenIssuerObjectFactory.bless(pointer);}/**
   * Burns supply of the issuer token
   *
   * # Arguments
   *
   * * `request`: The request containing the amount of the supply to burn
   *
   * # Returns
   *
   * Result containing either:
   * * `Payment` - The payment representing the burn transaction
   * * `SdkError` - If there was an error during the burn process
   */async burnIssuerToken(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token(uniffiTypeTokenIssuerObjectFactory.clonePointer(this),FfiConverterTypeBurnIssuerTokenRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypePayment.lift.bind(FfiConverterTypePayment),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Creates a new issuer token
   *
   * # Arguments
   *
   * * `request`: The request containing the token parameters
   *
   * # Returns
   *
   * Result containing either:
   * * `TokenMetadata` - The metadata of the created token
   * * `SdkError` - If there was an error during the token creation
   */async createIssuerToken(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_token(uniffiTypeTokenIssuerObjectFactory.clonePointer(this),FfiConverterTypeCreateIssuerTokenRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeTokenMetadata.lift.bind(FfiConverterTypeTokenMetadata),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Freezes tokens held at the specified address
   *
   * # Arguments
   *
   * * `request`: The request containing the spark address where the tokens to be frozen are held
   *
   * # Returns
   *
   * Result containing either:
   * * `FreezeIssuerTokenResponse` - The response containing details of the freeze operation
   * * `SdkError` - If there was an error during the freeze process
   */async freezeIssuerToken(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_token(uniffiTypeTokenIssuerObjectFactory.clonePointer(this),FfiConverterTypeFreezeIssuerTokenRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeFreezeIssuerTokenResponse.lift.bind(FfiConverterTypeFreezeIssuerTokenResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Gets the issuer token balance
   *
   * # Returns
   *
   * Result containing either:
   * * `TokenBalance` - The balance of the issuer token
   * * `SdkError` - If there was an error during the retrieval or no issuer token exists
   */async getIssuerTokenBalance(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_balance(uniffiTypeTokenIssuerObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeTokenBalance.lift.bind(FfiConverterTypeTokenBalance),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Gets the issuer token metadata
   *
   * # Returns
   *
   * Result containing either:
   * * `TokenMetadata` - The metadata of the issuer token
   * * `SdkError` - If there was an error during the retrieval or no issuer token exists
   */async getIssuerTokenMetadata(asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_metadata(uniffiTypeTokenIssuerObjectFactory.clonePointer(this));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeTokenMetadata.lift.bind(FfiConverterTypeTokenMetadata),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Mints supply for the issuer token
   *
   * # Arguments
   *
   * * `request`: The request contiaining the amount of the supply to mint
   *
   * # Returns
   *
   * Result containing either:
   * * `Payment` - The payment representing the minting transaction
   * * `SdkError` - If there was an error during the minting process
   */async mintIssuerToken(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token(uniffiTypeTokenIssuerObjectFactory.clonePointer(this),FfiConverterTypeMintIssuerTokenRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypePayment.lift.bind(FfiConverterTypePayment),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * Unfreezes tokens held at the specified address
   *
   * # Arguments
   *
   * * `request`: The request containing the spark address where the tokens to be unfrozen are held
   *
   * # Returns
   *
   * Result containing either:
   * * `UnfreezeIssuerTokenResponse` - The response containing details of the unfreeze operation
   * * `SdkError` - If there was an error during the unfreeze process
   */async unfreezeIssuerToken(request,asyncOpts_)/*throws*/{const __stack=uniffiIsDebug?new Error().stack:undefined;try{return await uniffiRustCallAsync(/*rustCaller:*/uniffiCaller,/*rustFutureFunc:*/()=>{return nativeModule().ubrn_uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_token(uniffiTypeTokenIssuerObjectFactory.clonePointer(this),FfiConverterTypeUnfreezeIssuerTokenRequest.lower(request));},/*pollFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_poll_rust_buffer,/*cancelFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_cancel_rust_buffer,/*completeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_complete_rust_buffer,/*freeFunc:*/nativeModule().ubrn_ffi_breez_sdk_spark_rust_future_free_rust_buffer,/*liftFunc:*/FfiConverterTypeUnfreezeIssuerTokenResponse.lift.bind(FfiConverterTypeUnfreezeIssuerTokenResponse),/*liftString:*/FfiConverterString.lift,/*asyncOpts:*/asyncOpts_,/*errorHandler:*/FfiConverterTypeSdkError.lift.bind(FfiConverterTypeSdkError));}catch(__error){if(uniffiIsDebug&&__error instanceof Error){__error.stack=__stack;}throw __error;}}/**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */uniffiDestroy(){const ptr=this[destructorGuardSymbol];if(ptr!==undefined){const pointer=uniffiTypeTokenIssuerObjectFactory.pointer(this);uniffiTypeTokenIssuerObjectFactory.freePointer(pointer);uniffiTypeTokenIssuerObjectFactory.unbless(ptr);delete this[destructorGuardSymbol];}}static instanceOf(obj){return uniffiTypeTokenIssuerObjectFactory.isConcreteType(obj);}}const uniffiTypeTokenIssuerObjectFactory={create(pointer){const instance=Object.create(TokenIssuer.prototype);instance[pointerLiteralSymbol]=pointer;instance[destructorGuardSymbol]=this.bless(pointer);instance[uniffiTypeNameSymbol]='TokenIssuer';return instance;},bless(p){return uniffiCaller.rustCall(/*caller:*/status=>nativeModule().ubrn_uniffi_internal_fn_method_tokenissuer_ffi__bless_pointer(p,status),/*liftString:*/FfiConverterString.lift);},unbless(ptr){ptr.markDestroyed();},pointer(obj){if(obj[destructorGuardSymbol]===undefined){throw new UniffiInternalError.UnexpectedNullPointer();}return obj[pointerLiteralSymbol];},clonePointer(obj){const pointer=this.pointer(obj);return uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_clone_tokenissuer(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},freePointer(pointer){uniffiCaller.rustCall(/*caller:*/callStatus=>nativeModule().ubrn_uniffi_breez_sdk_spark_fn_free_tokenissuer(pointer,callStatus),/*liftString:*/FfiConverterString.lift);},isConcreteType(obj){return obj[destructorGuardSymbol]&&obj[uniffiTypeNameSymbol]==='TokenIssuer';}};// FfiConverter for TokenIssuerInterface
const FfiConverterTypeTokenIssuer=new FfiConverterObject(uniffiTypeTokenIssuerObjectFactory);// FfiConverter for boolean | undefined
const FfiConverterOptionalBool=new FfiConverterOptional(FfiConverterBool);// FfiConverter for ArrayBuffer | undefined
const FfiConverterOptionalArrayBuffer=new FfiConverterOptional(FfiConverterArrayBuffer);// FfiConverter for Logger | undefined
const FfiConverterOptionalTypeLogger=new FfiConverterOptional(FfiConverterTypeLogger);// FfiConverter for ConversionDetails | undefined
const FfiConverterOptionalTypeConversionDetails=new FfiConverterOptional(FfiConverterTypeConversionDetails);// FfiConverter for ConversionEstimate | undefined
const FfiConverterOptionalTypeConversionEstimate=new FfiConverterOptional(FfiConverterTypeConversionEstimate);// FfiConverter for ConversionInfo | undefined
const FfiConverterOptionalTypeConversionInfo=new FfiConverterOptional(FfiConverterTypeConversionInfo);// FfiConverter for ConversionOptions | undefined
const FfiConverterOptionalTypeConversionOptions=new FfiConverterOptional(FfiConverterTypeConversionOptions);// FfiConverter for Credentials | undefined
const FfiConverterOptionalTypeCredentials=new FfiConverterOptional(FfiConverterTypeCredentials);// FfiConverter for KeySetConfig | undefined
const FfiConverterOptionalTypeKeySetConfig=new FfiConverterOptional(FfiConverterTypeKeySetConfig);// FfiConverter for LightningAddressInfo | undefined
const FfiConverterOptionalTypeLightningAddressInfo=new FfiConverterOptional(FfiConverterTypeLightningAddressInfo);// FfiConverter for LnurlPayInfo | undefined
const FfiConverterOptionalTypeLnurlPayInfo=new FfiConverterOptional(FfiConverterTypeLnurlPayInfo);// FfiConverter for LnurlReceiveMetadata | undefined
const FfiConverterOptionalTypeLnurlReceiveMetadata=new FfiConverterOptional(FfiConverterTypeLnurlReceiveMetadata);// FfiConverter for LnurlWithdrawInfo | undefined
const FfiConverterOptionalTypeLnurlWithdrawInfo=new FfiConverterOptional(FfiConverterTypeLnurlWithdrawInfo);// FfiConverter for OutgoingChange | undefined
const FfiConverterOptionalTypeOutgoingChange=new FfiConverterOptional(FfiConverterTypeOutgoingChange);// FfiConverter for Payment | undefined
const FfiConverterOptionalTypePayment=new FfiConverterOptional(FfiConverterTypePayment);// FfiConverter for Record | undefined
const FfiConverterOptionalTypeRecord=new FfiConverterOptional(FfiConverterTypeRecord);// FfiConverter for SparkHtlcDetails | undefined
const FfiConverterOptionalTypeSparkHtlcDetails=new FfiConverterOptional(FfiConverterTypeSparkHtlcDetails);// FfiConverter for SparkHtlcOptions | undefined
const FfiConverterOptionalTypeSparkHtlcOptions=new FfiConverterOptional(FfiConverterTypeSparkHtlcOptions);// FfiConverter for SparkInvoicePaymentDetails | undefined
const FfiConverterOptionalTypeSparkInvoicePaymentDetails=new FfiConverterOptional(FfiConverterTypeSparkInvoicePaymentDetails);// FfiConverter for Symbol | undefined
const FfiConverterOptionalTypeSymbol=new FfiConverterOptional(FfiConverterTypeSymbol);// FfiConverter for TokenMetadata | undefined
const FfiConverterOptionalTypeTokenMetadata=new FfiConverterOptional(FfiConverterTypeTokenMetadata);// FfiConverter for string | undefined
const FfiConverterOptionalString=new FfiConverterOptional(FfiConverterString);// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32=new FfiConverterOptional(FfiConverterUInt32);// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64=new FfiConverterOptional(FfiConverterUInt64);// FfiConverter for Array<ArrayBuffer>
const FfiConverterArrayArrayBuffer=new FfiConverterArray(FfiConverterArrayBuffer);// FfiConverter for Array<Bip21Extra>
const FfiConverterArrayTypeBip21Extra=new FfiConverterArray(FfiConverterTypeBip21Extra);// FfiConverter for Array<Bolt11RouteHint>
const FfiConverterArrayTypeBolt11RouteHint=new FfiConverterArray(FfiConverterTypeBolt11RouteHint);// FfiConverter for Array<Bolt11RouteHintHop>
const FfiConverterArrayTypeBolt11RouteHintHop=new FfiConverterArray(FfiConverterTypeBolt11RouteHintHop);// FfiConverter for Array<Bolt12OfferBlindedPath>
const FfiConverterArrayTypeBolt12OfferBlindedPath=new FfiConverterArray(FfiConverterTypeBolt12OfferBlindedPath);// FfiConverter for Array<DepositInfo>
const FfiConverterArrayTypeDepositInfo=new FfiConverterArray(FfiConverterTypeDepositInfo);// FfiConverter for Array<ExternalInputParser>
const FfiConverterArrayTypeExternalInputParser=new FfiConverterArray(FfiConverterTypeExternalInputParser);// FfiConverter for Array<ExternalVerifiableSecretShare>
const FfiConverterArrayTypeExternalVerifiableSecretShare=new FfiConverterArray(FfiConverterTypeExternalVerifiableSecretShare);// FfiConverter for Array<FiatCurrency>
const FfiConverterArrayTypeFiatCurrency=new FfiConverterArray(FfiConverterTypeFiatCurrency);// FfiConverter for Array<IdentifierCommitmentPair>
const FfiConverterArrayTypeIdentifierCommitmentPair=new FfiConverterArray(FfiConverterTypeIdentifierCommitmentPair);// FfiConverter for Array<IdentifierPublicKeyPair>
const FfiConverterArrayTypeIdentifierPublicKeyPair=new FfiConverterArray(FfiConverterTypeIdentifierPublicKeyPair);// FfiConverter for Array<IdentifierSignaturePair>
const FfiConverterArrayTypeIdentifierSignaturePair=new FfiConverterArray(FfiConverterTypeIdentifierSignaturePair);// FfiConverter for Array<IncomingChange>
const FfiConverterArrayTypeIncomingChange=new FfiConverterArray(FfiConverterTypeIncomingChange);// FfiConverter for Array<LocaleOverrides>
const FfiConverterArrayTypeLocaleOverrides=new FfiConverterArray(FfiConverterTypeLocaleOverrides);// FfiConverter for Array<LocalizedName>
const FfiConverterArrayTypeLocalizedName=new FfiConverterArray(FfiConverterTypeLocalizedName);// FfiConverter for Array<OutgoingChange>
const FfiConverterArrayTypeOutgoingChange=new FfiConverterArray(FfiConverterTypeOutgoingChange);// FfiConverter for Array<Payment>
const FfiConverterArrayTypePayment=new FfiConverterArray(FfiConverterTypePayment);// FfiConverter for Array<ProvisionalPayment>
const FfiConverterArrayTypeProvisionalPayment=new FfiConverterArray(FfiConverterTypeProvisionalPayment);// FfiConverter for Array<Rate>
const FfiConverterArrayTypeRate=new FfiConverterArray(FfiConverterTypeRate);// FfiConverter for Array<Record>
const FfiConverterArrayTypeRecord=new FfiConverterArray(FfiConverterTypeRecord);// FfiConverter for Array<SetLnurlMetadataItem>
const FfiConverterArrayTypeSetLnurlMetadataItem=new FfiConverterArray(FfiConverterTypeSetLnurlMetadataItem);// FfiConverter for Array<TokenMetadata>
const FfiConverterArrayTypeTokenMetadata=new FfiConverterArray(FfiConverterTypeTokenMetadata);// FfiConverter for Array<Utxo>
const FfiConverterArrayTypeUtxo=new FfiConverterArray(FfiConverterTypeUtxo);// FfiConverter for Array<string>
const FfiConverterArrayString=new FfiConverterArray(FfiConverterString);// FfiConverter for Map<string, Array<Payment>>
const FfiConverterMapStringArrayTypePayment=new FfiConverterMap(FfiConverterString,FfiConverterArrayTypePayment);// FfiConverter for U128 | undefined
const FfiConverterOptionalTypeu128=new FfiConverterOptional(FfiConverterTypeu128);// FfiConverter for Amount | undefined
const FfiConverterOptionalTypeAmount=new FfiConverterOptional(FfiConverterTypeAmount);// FfiConverter for AssetFilter | undefined
const FfiConverterOptionalTypeAssetFilter=new FfiConverterOptional(FfiConverterTypeAssetFilter);// FfiConverter for ConversionPurpose | undefined
const FfiConverterOptionalTypeConversionPurpose=new FfiConverterOptional(FfiConverterTypeConversionPurpose);// FfiConverter for DepositClaimError | undefined
const FfiConverterOptionalTypeDepositClaimError=new FfiConverterOptional(FfiConverterTypeDepositClaimError);// FfiConverter for Fee | undefined
const FfiConverterOptionalTypeFee=new FfiConverterOptional(FfiConverterTypeFee);// FfiConverter for FeePolicy | undefined
const FfiConverterOptionalTypeFeePolicy=new FfiConverterOptional(FfiConverterTypeFeePolicy);// FfiConverter for MaxFee | undefined
const FfiConverterOptionalTypeMaxFee=new FfiConverterOptional(FfiConverterTypeMaxFee);// FfiConverter for PaymentDetails | undefined
const FfiConverterOptionalTypePaymentDetails=new FfiConverterOptional(FfiConverterTypePaymentDetails);// FfiConverter for SendPaymentOptions | undefined
const FfiConverterOptionalTypeSendPaymentOptions=new FfiConverterOptional(FfiConverterTypeSendPaymentOptions);// FfiConverter for SuccessAction | undefined
const FfiConverterOptionalTypeSuccessAction=new FfiConverterOptional(FfiConverterTypeSuccessAction);// FfiConverter for SuccessActionProcessed | undefined
const FfiConverterOptionalTypeSuccessActionProcessed=new FfiConverterOptional(FfiConverterTypeSuccessActionProcessed);// FfiConverter for TokenTransactionType | undefined
const FfiConverterOptionalTypeTokenTransactionType=new FfiConverterOptional(FfiConverterTypeTokenTransactionType);// FfiConverter for Map<string, string> | undefined
const FfiConverterOptionalMapStringString=new FfiConverterOptional(FfiConverterMapStringString);// FfiConverter for Array<ExternalInputParser> | undefined
const FfiConverterOptionalArrayTypeExternalInputParser=new FfiConverterOptional(FfiConverterArrayTypeExternalInputParser);// FfiConverter for Array<InputType>
const FfiConverterArrayTypeInputType=new FfiConverterArray(FfiConverterTypeInputType);// FfiConverter for Array<PaymentDetailsFilter>
const FfiConverterArrayTypePaymentDetailsFilter=new FfiConverterArray(FfiConverterTypePaymentDetailsFilter);// FfiConverter for Array<PaymentStatus>
const FfiConverterArrayTypePaymentStatus=new FfiConverterArray(FfiConverterTypePaymentStatus);// FfiConverter for Array<PaymentType>
const FfiConverterArrayTypePaymentType=new FfiConverterArray(FfiConverterTypePaymentType);// FfiConverter for Array<SparkHtlcStatus>
const FfiConverterArrayTypeSparkHtlcStatus=new FfiConverterArray(FfiConverterTypeSparkHtlcStatus);// FfiConverter for Array<PaymentDetailsFilter> | undefined
const FfiConverterOptionalArrayTypePaymentDetailsFilter=new FfiConverterOptional(FfiConverterArrayTypePaymentDetailsFilter);// FfiConverter for Array<PaymentStatus> | undefined
const FfiConverterOptionalArrayTypePaymentStatus=new FfiConverterOptional(FfiConverterArrayTypePaymentStatus);// FfiConverter for Array<PaymentType> | undefined
const FfiConverterOptionalArrayTypePaymentType=new FfiConverterOptional(FfiConverterArrayTypePaymentType);// FfiConverter for Array<SparkHtlcStatus> | undefined
const FfiConverterOptionalArrayTypeSparkHtlcStatus=new FfiConverterOptional(FfiConverterArrayTypeSparkHtlcStatus);/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */function uniffiEnsureInitialized(){// Get the bindings contract version from our ComponentInterface
const bindingsContractVersion=26;// Get the scaffolding contract version by calling the into the dylib
const scaffoldingContractVersion=nativeModule().ubrn_ffi_breez_sdk_spark_uniffi_contract_version();if(bindingsContractVersion!==scaffoldingContractVersion){throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion,bindingsContractVersion);}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_connect()!==40345){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_func_connect');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_connect_with_signer()!==1399){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_func_connect_with_signer');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_default_config()!==62194){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_func_default_config');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_default_external_signer()!==40694){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_func_default_external_signer');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_get_spark_status()!==62888){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_func_get_spark_status');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_func_init_logging()!==8518){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_func_init_logging');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos()!==20959){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status()!==23018){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex()!==59376){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction()!==65179){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees()!==43230){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener()!==37737){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_buy_bitcoin()!==32150){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_buy_bitcoin');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_optimization()!==56996){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_optimization');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available()!==31624){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message()!==4385){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit()!==43529){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment()!==57587){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address()!==44132){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect()!==330){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_conversion_limits()!==50958){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_conversion_limits');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info()!==6771){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_optimization_progress()!==38008){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_optimization_progress');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address()!==36552){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment()!==11540){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer()!==26649){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata()!==40125){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings()!==38537){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies()!==63366){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates()!==5904){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments()!==39170){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits()!==22486){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_auth()!==125){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_auth');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay()!==10147){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw()!==45652){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_parse()!==14285){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_parse');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay()!==37691){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment()!==34185){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment()!==36984){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees()!==16947){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit()!==33646){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address()!==530){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener()!==41066){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment()!==54349){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message()!==57563){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_optimization()!==22827){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_optimization');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet()!==30368){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings()!==1721){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_public_key()!==62941){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_public_key');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_public_key()!==23137){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_public_key');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa()!==37648){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_recoverable()!==3107){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_recoverable');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_ecies()!==60224){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_ecies');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_decrypt_ecies()!==59601){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_decrypt_ecies');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_schnorr()!==57220){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_schnorr');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_hmac_sha256()!==57517){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_hmac_sha256');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_signing_commitment()!==31862){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_signing_commitment');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_for_node()!==37434){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_for_node');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_secret()!==26114){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_secret');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_static_deposit_secret_encrypted()!==38925){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_static_deposit_secret_encrypted');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_static_deposit_secret()!==45280){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_static_deposit_secret');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_static_deposit_signing_key()!==62519){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_static_deposit_signing_key');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_secrets()!==45969){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_secrets');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_split_secret_with_proofs()!==19489){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_split_secret_with_proofs');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_secret_for_receiver()!==51627){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_secret_for_receiver');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_public_key_from_secret()!==53055){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_public_key_from_secret');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_frost()!==20635){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_frost');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_frost()!==53544){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_frost');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies()!==19092){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates()!==11512){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send()!==30686){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_restclient_get_request()!==8260){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_restclient_get_request');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_restclient_post_request()!==24889){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_restclient_post_request');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_restclient_delete_request()!==51072){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_restclient_delete_request');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build()!==8126){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service()!==2848){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage()!==14543){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service()!==37854){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set()!==50052){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client()!==51060){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer()!==21617){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service()!==63155){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage()!==59400){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item()!==6883){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item()!==30248){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item()!==7970){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_list_payments()!==19728){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_list_payments');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_insert_payment()!==28075){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_insert_payment');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_insert_payment_metadata()!==32757){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_insert_payment_metadata');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id()!==35394){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice()!==57075){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_payments_by_parent_ids()!==10948){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_get_payments_by_parent_ids');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_add_deposit()!==13181){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_add_deposit');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit()!==28477){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_list_deposits()!==62636){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_list_deposits');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_update_deposit()!==18714){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_update_deposit');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata()!==64210){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_add_outgoing_change()!==50774){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_add_outgoing_change');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_complete_outgoing_sync()!==8796){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_complete_outgoing_sync');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_pending_outgoing_changes()!==20314){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_get_pending_outgoing_changes');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_last_revision()!==48442){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_get_last_revision');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_insert_incoming_records()!==38174){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_insert_incoming_records');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_delete_incoming_record()!==26412){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_delete_incoming_record');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_incoming_records()!==13705){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_get_incoming_records');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_get_latest_outgoing_change()!==41859){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_get_latest_outgoing_change');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_storage_update_record_from_incoming()!==54499){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_storage_update_record_from_incoming');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token()!==56056){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token()!==33277){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token()!==32344){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance()!==9758){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata()!==57707){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token()!==36459){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token()!==65025){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new()!==65435){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event()!==24807){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event');}if(nativeModule().ubrn_uniffi_breez_sdk_spark_checksum_method_logger_log()!==11839){throw new UniffiInternalError.ApiChecksumMismatch('uniffi_breez_sdk_spark_checksum_method_logger_log');}uniffiCallbackInterfaceEventListener.register();uniffiCallbackInterfaceLogger.register();uniffiCallbackInterfaceBitcoinChainService.register();uniffiCallbackInterfaceExternalSigner.register();uniffiCallbackInterfaceFiatService.register();uniffiCallbackInterfacePaymentObserver.register();uniffiCallbackInterfaceRestClient.register();uniffiCallbackInterfaceStorage.register();}export default Object.freeze({initialize:uniffiEnsureInitialized,converters:{FfiConverterTypeAesSuccessActionData,FfiConverterTypeAesSuccessActionDataDecrypted,FfiConverterTypeAesSuccessActionDataResult,FfiConverterTypeAmount,FfiConverterTypeAssetFilter,FfiConverterTypeBip21Details,FfiConverterTypeBip21Extra,FfiConverterTypeBitcoinAddressDetails,FfiConverterTypeBitcoinChainService,FfiConverterTypeBitcoinNetwork,FfiConverterTypeBolt11Invoice,FfiConverterTypeBolt11InvoiceDetails,FfiConverterTypeBolt11RouteHint,FfiConverterTypeBolt11RouteHintHop,FfiConverterTypeBolt12Invoice,FfiConverterTypeBolt12InvoiceDetails,FfiConverterTypeBolt12InvoiceRequestDetails,FfiConverterTypeBolt12Offer,FfiConverterTypeBolt12OfferBlindedPath,FfiConverterTypeBolt12OfferDetails,FfiConverterTypeBreezSdk,FfiConverterTypeBurnIssuerTokenRequest,FfiConverterTypeBuyBitcoinRequest,FfiConverterTypeBuyBitcoinResponse,FfiConverterTypeChainApiType,FfiConverterTypeCheckLightningAddressRequest,FfiConverterTypeCheckMessageRequest,FfiConverterTypeCheckMessageResponse,FfiConverterTypeClaimDepositRequest,FfiConverterTypeClaimDepositResponse,FfiConverterTypeClaimHtlcPaymentRequest,FfiConverterTypeClaimHtlcPaymentResponse,FfiConverterTypeConfig,FfiConverterTypeConnectRequest,FfiConverterTypeConnectWithSignerRequest,FfiConverterTypeConversionDetails,FfiConverterTypeConversionEstimate,FfiConverterTypeConversionInfo,FfiConverterTypeConversionOptions,FfiConverterTypeConversionPurpose,FfiConverterTypeConversionStatus,FfiConverterTypeConversionStep,FfiConverterTypeConversionType,FfiConverterTypeCreateIssuerTokenRequest,FfiConverterTypeCredentials,FfiConverterTypeCurrencyInfo,FfiConverterTypeDepositClaimError,FfiConverterTypeDepositInfo,FfiConverterTypeEcdsaSignatureBytes,FfiConverterTypeExternalAggregateFrostRequest,FfiConverterTypeExternalEncryptedSecret,FfiConverterTypeExternalFrostCommitments,FfiConverterTypeExternalFrostSignature,FfiConverterTypeExternalFrostSignatureShare,FfiConverterTypeExternalIdentifier,FfiConverterTypeExternalInputParser,FfiConverterTypeExternalScalar,FfiConverterTypeExternalSecretShare,FfiConverterTypeExternalSecretSource,FfiConverterTypeExternalSecretToSplit,FfiConverterTypeExternalSignFrostRequest,FfiConverterTypeExternalSigner,FfiConverterTypeExternalSigningCommitments,FfiConverterTypeExternalTreeNodeId,FfiConverterTypeExternalVerifiableSecretShare,FfiConverterTypeFee,FfiConverterTypeFeePolicy,FfiConverterTypeFetchConversionLimitsRequest,FfiConverterTypeFetchConversionLimitsResponse,FfiConverterTypeFiatCurrency,FfiConverterTypeFiatService,FfiConverterTypeFreezeIssuerTokenRequest,FfiConverterTypeFreezeIssuerTokenResponse,FfiConverterTypeGetInfoRequest,FfiConverterTypeGetInfoResponse,FfiConverterTypeGetPaymentRequest,FfiConverterTypeGetPaymentResponse,FfiConverterTypeGetTokensMetadataRequest,FfiConverterTypeGetTokensMetadataResponse,FfiConverterTypeHashedMessageBytes,FfiConverterTypeIdentifierCommitmentPair,FfiConverterTypeIdentifierPublicKeyPair,FfiConverterTypeIdentifierSignaturePair,FfiConverterTypeIncomingChange,FfiConverterTypeInputType,FfiConverterTypeKeySetConfig,FfiConverterTypeKeySetType,FfiConverterTypeLightningAddressDetails,FfiConverterTypeLightningAddressInfo,FfiConverterTypeListFiatCurrenciesResponse,FfiConverterTypeListFiatRatesResponse,FfiConverterTypeListPaymentsRequest,FfiConverterTypeListPaymentsResponse,FfiConverterTypeListUnclaimedDepositsRequest,FfiConverterTypeListUnclaimedDepositsResponse,FfiConverterTypeLnurlAuthRequestDetails,FfiConverterTypeLnurlCallbackStatus,FfiConverterTypeLnurlErrorDetails,FfiConverterTypeLnurlInfo,FfiConverterTypeLnurlPayInfo,FfiConverterTypeLnurlPayRequest,FfiConverterTypeLnurlPayRequestDetails,FfiConverterTypeLnurlPayResponse,FfiConverterTypeLnurlReceiveMetadata,FfiConverterTypeLnurlWithdrawInfo,FfiConverterTypeLnurlWithdrawRequest,FfiConverterTypeLnurlWithdrawRequestDetails,FfiConverterTypeLnurlWithdrawResponse,FfiConverterTypeLocaleOverrides,FfiConverterTypeLocalizedName,FfiConverterTypeLogEntry,FfiConverterTypeMaxFee,FfiConverterTypeMessageBytes,FfiConverterTypeMessageSuccessActionData,FfiConverterTypeMintIssuerTokenRequest,FfiConverterTypeNetwork,FfiConverterTypeOnchainConfirmationSpeed,FfiConverterTypeOptimizationConfig,FfiConverterTypeOptimizationEvent,FfiConverterTypeOptimizationProgress,FfiConverterTypeOutgoingChange,FfiConverterTypePayment,FfiConverterTypePaymentDetails,FfiConverterTypePaymentDetailsFilter,FfiConverterTypePaymentMetadata,FfiConverterTypePaymentMethod,FfiConverterTypePaymentObserver,FfiConverterTypePaymentRequestSource,FfiConverterTypePaymentStatus,FfiConverterTypePaymentType,FfiConverterTypePrepareLnurlPayRequest,FfiConverterTypePrepareLnurlPayResponse,FfiConverterTypePrepareSendPaymentRequest,FfiConverterTypePrepareSendPaymentResponse,FfiConverterTypeProvisionalPayment,FfiConverterTypeProvisionalPaymentDetails,FfiConverterTypePublicKeyBytes,FfiConverterTypeRate,FfiConverterTypeReceivePaymentMethod,FfiConverterTypeReceivePaymentRequest,FfiConverterTypeReceivePaymentResponse,FfiConverterTypeRecommendedFees,FfiConverterTypeRecord,FfiConverterTypeRecordChange,FfiConverterTypeRecordId,FfiConverterTypeRecoverableEcdsaSignatureBytes,FfiConverterTypeRefundDepositRequest,FfiConverterTypeRefundDepositResponse,FfiConverterTypeRegisterLightningAddressRequest,FfiConverterTypeRestClient,FfiConverterTypeRestResponse,FfiConverterTypeSchnorrSignatureBytes,FfiConverterTypeSdkBuilder,FfiConverterTypeSdkEvent,FfiConverterTypeSecretBytes,FfiConverterTypeSeed,FfiConverterTypeSendOnchainFeeQuote,FfiConverterTypeSendOnchainSpeedFeeQuote,FfiConverterTypeSendPaymentMethod,FfiConverterTypeSendPaymentOptions,FfiConverterTypeSendPaymentRequest,FfiConverterTypeSendPaymentResponse,FfiConverterTypeServiceStatus,FfiConverterTypeSetLnurlMetadataItem,FfiConverterTypeSignMessageRequest,FfiConverterTypeSignMessageResponse,FfiConverterTypeSilentPaymentAddressDetails,FfiConverterTypeSparkAddressDetails,FfiConverterTypeSparkHtlcDetails,FfiConverterTypeSparkHtlcOptions,FfiConverterTypeSparkHtlcStatus,FfiConverterTypeSparkInvoiceDetails,FfiConverterTypeSparkInvoicePaymentDetails,FfiConverterTypeSparkStatus,FfiConverterTypeStorage,FfiConverterTypeSuccessAction,FfiConverterTypeSuccessActionProcessed,FfiConverterTypeSymbol,FfiConverterTypeSyncWalletRequest,FfiConverterTypeSyncWalletResponse,FfiConverterTypeTokenBalance,FfiConverterTypeTokenIssuer,FfiConverterTypeTokenMetadata,FfiConverterTypeTokenTransactionType,FfiConverterTypeTxStatus,FfiConverterTypeUnfreezeIssuerTokenRequest,FfiConverterTypeUnfreezeIssuerTokenResponse,FfiConverterTypeUnversionedRecordChange,FfiConverterTypeUpdateDepositPayload,FfiConverterTypeUpdateUserSettingsRequest,FfiConverterTypeUrlSuccessActionData,FfiConverterTypeUserSettings,FfiConverterTypeUtxo,FfiConverterTypeu128}});
//# sourceMappingURL=breez_sdk_spark.js.map